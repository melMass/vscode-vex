{
	"if": {
			"prefix": "if",
			"body": "if ($1) {\n$2\n}",
			"description": "If Statement",
			"scope": "source.vex"
	},
	"else": {
			"prefix": "else",
			"body": "else {\n$1\n}",
			"description": "Else Statement",
			"scope": "source.vex"
	},
	"while": {
			"prefix": "while",
			"body": "while ($1) {\n$2\n}",
			"description": "While Loop",
			"scope": "source.vex"
	},
	"for": {
			"prefix": "for",
			"body": "for (int ${2:i} = 0; $2 < ${1:count}; ${3:++$2}){\n    ${0:/* code */}\n}\n",
			"description": "For Loop (int)",
			"scope": "source.vex"
	},
	"foreach": {
			"prefix": "foreach",
			"body": "foreach (${1:item_type}; ${2:item}; ${3:array}){\n    ${0:/* code */}\n}\n",
			"description": "Foreach Loop",
			"scope": "source.vex"
	},
	"Point Cloud Iterate Excluding Search Point": {
			"prefix": "pce",
			"body": "float search_rad = ${1:10.0};\nint   max_points = ${2:10};\n\nint handle = pcopen(@OpInput1, \"P\", @P, search_rad, max_points+1);\n\nint near_pt;\nvector near_p;\n\nwhile( pciterate(handle) ) {\n    pcimport(handle, \"point:number\", near_pt);\n    if (@ptnum != near_pt) {\n        // found a nearby point that isn't the search position\n        pcimport(handle, \"P\", near_p);\n    }\n}\n\npcclose(handle);\n",
			"description": "Point Cloud Iterate Excluding Search Point (VEXpression)",
			"scope": "source.vex"
	},
	"Point Cloud Iterate (VEXpression)": {
			"prefix": "pci",
			"body": "float search_rad = ${1:10.0};\nint   max_points = ${2:10};\n\nint handle = pcopen(${3:0}, \"P\", @P, search_rad, max_points);\n\nvector near_p;\n\nwhile( pciterate(handle) ) {\n    pcimport(handle, \"P\", near_p);\n}\n\npcclose(handle);\n",
			"description": "Point Cloud Iterate (VEXpression)",
			"scope": "source.vex"
	},
	"usd_blockprimvar: stagehandle primpath name": {
			"prefix": "usd_blockprimvar(stagehandle, primpath, name)",
			"body": "usd_blockprimvar(${1:stagehandle}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Blocks the primvar."
	},
	"interpolate: val sx sy": {
			"prefix": "interpolate(val, sx, sy)",
			"body": "interpolate(${1:val}, ${2:sx}, ${3:sy})",
			"scope": "source.vex",
			"description": "Interpolates a value across the currently shaded micropolygon."
	},
	"cregioncapturetransform: path": {
			"prefix": "cregioncapturetransform(path)",
			"body": "cregioncapturetransform(${1:path})",
			"scope": "source.vex",
			"description": "Returns the capture transform associated with a Capture Region SOP."
	},
	"cregioncapturetransform: path time": {
			"prefix": "cregioncapturetransform(path, time)",
			"body": "cregioncapturetransform(${1:path}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the capture transform associated with a Capture Region SOP."
	},
	"cregioncapturetransform: op_id": {
			"prefix": "cregioncapturetransform(op_id)",
			"body": "cregioncapturetransform(${1:op_id})",
			"scope": "source.vex",
			"description": "Returns the capture transform associated with a Capture Region SOP."
	},
	"cregioncapturetransform: op_id time": {
			"prefix": "cregioncapturetransform(op_id, time)",
			"body": "cregioncapturetransform(${1:op_id}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the capture transform associated with a Capture Region SOP."
	},
	"chexpr: channel new_expr_function": {
			"prefix": "chexpr(channel, new_expr_function)",
			"body": "chexpr(${1:channel}, ${2:new_expr_function})",
			"scope": "source.vex",
			"description": "Evaluates a channel with a new segment expression."
	},
	"fastshadow: P D bias ...": {
			"prefix": "fastshadow(P, D, bias, ...)",
			"body": "fastshadow(${1:P}, ${2:D}, ${3:bias}, ${4:...})",
			"scope": "source.vex",
			"description": "Sends a ray from the position P along the direction specified by the\ndirection D."
	},
	"hasprimattrib: geometry attribute_name": {
			"prefix": "hasprimattrib(geometry, attribute_name)",
			"body": "hasprimattrib(${1:geometry}, ${2:attribute_name})",
			"scope": "source.vex",
			"description": "Returns if a geometry prim attribute exists."
	},
	"random_sobol: seed offset": {
			"prefix": "random_sobol(seed, offset)",
			"body": "random_sobol(${1:seed}, ${2:offset})",
			"scope": "source.vex",
			"description": "Generate a uniformly distributed random number."
	},
	"primfind: geometry min max": {
			"prefix": "primfind(geometry, min, max)",
			"body": "primfind(${1:geometry}, ${2:min}, ${3:max})",
			"scope": "source.vex",
			"description": "Returns a list of primitives potentially intersecting a given bounding box."
	},
	"primfind: geometry group min max": {
			"prefix": "primfind(geometry, group, min, max)",
			"body": "primfind(${1:geometry}, ${2:group}, ${3:min}, ${4:max})",
			"scope": "source.vex",
			"description": "Returns a list of primitives potentially intersecting a given bounding box."
	},
	"usd_transformsuffix: name": {
			"prefix": "usd_transformsuffix(name)",
			"body": "usd_transformsuffix(${1:name})",
			"scope": "source.vex",
			"description": "Extracts the transform operation suffix from the full name"
	},
	"sample_hypersphere_uniform: u": {
			"prefix": "sample_hypersphere_uniform(u)",
			"body": "sample_hypersphere_uniform(${1:u})",
			"scope": "source.vex",
			"description": "Generates a uniform vector4 with length < 1, given a vector4 of uniform numbers between 0 and 1."
	},
	"getprimid: ": {
			"prefix": "getprimid()",
			"body": "getprimid()",
			"scope": "source.vex",
			"description": "Returns the number of the current primitive."
	},
	"detailattribsize: geometry attribute_name": {
			"prefix": "detailattribsize(geometry, attribute_name)",
			"body": "detailattribsize(${1:geometry}, ${2:attribute_name})",
			"scope": "source.vex",
			"description": "Returns the size of a geometry detail attribute."
	},
	"chrampderiv: channel ramppos": {
			"prefix": "chrampderiv(channel, ramppos)",
			"body": "chrampderiv(${1:channel}, ${2:ramppos})",
			"scope": "source.vex",
			"description": "Evaluates the derivative of a parm parameter with respect to position."
	},
	"chrampderiv: channel ramppos time": {
			"prefix": "chrampderiv(channel, ramppos, time)",
			"body": "chrampderiv(${1:channel}, ${2:ramppos}, ${3:time})",
			"scope": "source.vex",
			"description": "Evaluates the derivative of a parm parameter with respect to position."
	},
	"getmaterialid: ": {
			"prefix": "getmaterialid()",
			"body": "getmaterialid()",
			"scope": "source.vex",
			"description": "Returns material id of shaded primitive."
	},
	"usd_isvisible: stage primpath": {
			"prefix": "usd_isvisible(stage, primpath)",
			"body": "usd_isvisible(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Checks if the primitive is visible."
	},
	"usd_isvisible: stage primpath timecode": {
			"prefix": "usd_isvisible(stage, primpath, timecode)",
			"body": "usd_isvisible(${1:stage}, ${2:primpath}, ${3:timecode})",
			"scope": "source.vex",
			"description": "Checks if the primitive is visible."
	},
	"tw_vspace: v": {
			"prefix": "tw_vspace(v)",
			"body": "tw_vspace(${1:v})",
			"scope": "source.vex",
			"description": "Transforms a direction vector from Texture to World space."
	},
	"usd_transformname: transformtype suffix": {
			"prefix": "usd_transformname(transformtype, suffix)",
			"body": "usd_transformname(${1:transformtype}, ${2:suffix})",
			"scope": "source.vex",
			"description": "Constructs a full name of a transform operation"
	},
	"atof: str": {
			"prefix": "atof(str)",
			"body": "atof(${1:str})",
			"scope": "source.vex",
			"description": "Converts a string to a float."
	},
	"usd_setprimvarelementsize: stagehandle primpath name size": {
			"prefix": "usd_setprimvarelementsize(stagehandle, primpath, name, size)",
			"body": "usd_setprimvarelementsize(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:size})",
			"scope": "source.vex",
			"description": "Sets the element size of a primvar."
	},
	"agentcollisionlayer: geometry prim": {
			"prefix": "agentcollisionlayer(geometry, prim)",
			"body": "agentcollisionlayer(${1:geometry}, ${2:prim})",
			"scope": "source.vex",
			"description": "Returns the name of the collision layer of an agent primitive."
	},
	"shl: a bits": {
			"prefix": "shl(a, bits)",
			"body": "shl(${1:a}, ${2:bits})",
			"scope": "source.vex",
			"description": "Bit-shifts an integer left."
	},
	"rayhittest: P D bias ...": {
			"prefix": "rayhittest(P, D, bias, ...)",
			"body": "rayhittest(${1:P}, ${2:D}, ${3:bias}, ${4:...})",
			"scope": "source.vex",
			"description": "Sends a ray from the position P along the direction D."
	},
	"rayhittest: P D pHit nHit bias ...": {
			"prefix": "rayhittest(P, D, pHit, nHit, bias, ...)",
			"body": "rayhittest(${1:P}, ${2:D}, ${3:pHit}, ${4:nHit}, ${5:bias}, ${6:...})",
			"scope": "source.vex",
			"description": "Sends a ray from the position P along the direction D."
	},
	"shadowmap: filename Pndc spread bias quality ...": {
			"prefix": "shadowmap(filename, Pndc, spread, bias, quality, ...)",
			"body": "shadowmap(${1:filename}, ${2:Pndc}, ${3:spread}, ${4:bias}, ${5:quality}, ${6:...})",
			"scope": "source.vex",
			"description": "The shadowmap function will treat the shadow map as if the image were\nrendered from a light source."
	},
	"shadowmap: filename Pndc1 Pndc2 Pndc3 Pndc4 spread bias quality ...": {
			"prefix": "shadowmap(filename, Pndc1, Pndc2, Pndc3, Pndc4, spread, bias, quality, ...)",
			"body": "shadowmap(${1:filename}, ${2:Pndc1}, ${3:Pndc2}, ${4:Pndc3}, ${5:Pndc4}, ${6:spread}, ${7:bias}, ${8:quality}, ${9:...})",
			"scope": "source.vex",
			"description": "The shadowmap function will treat the shadow map as if the image were\nrendered from a light source."
	},
	"pcimportbyidxi: handle channel_name idx": {
			"prefix": "pcimportbyidxi(handle, channel_name, idx)",
			"body": "pcimportbyidxi(${1:handle}, ${2:channel_name}, ${3:idx})",
			"scope": "source.vex",
			"description": "Imports channel data from a point cloud outside a pciterate or a pcunshaded loop."
	},
	"sample_orientation_cone: center maxangle u": {
			"prefix": "sample_orientation_cone(center, maxangle, u)",
			"body": "sample_orientation_cone(${1:center}, ${2:maxangle}, ${3:u})",
			"scope": "source.vex",
			"description": "Generates a uniform unit vector4, within maxangle of center, given a vector of uniform numbers between 0 and 1."
	},
	"fuzzy_xor: a b ...": {
			"prefix": "fuzzy_xor(a, b, ...)",
			"body": "fuzzy_xor(${1:a}, ${2:b}, ${3:...})",
			"scope": "source.vex",
			"description": ""
	},
	"usd_isarraymetadata: stage path name": {
			"prefix": "usd_isarraymetadata(stage, path, name)",
			"body": "usd_isarraymetadata(${1:stage}, ${2:path}, ${3:name})",
			"scope": "source.vex",
			"description": "Checks if the given metadata is an array."
	},
	"chopt: filename channel sample time": {
			"prefix": "chopt(filename, channel, sample, time)",
			"body": "chopt(${1:filename}, ${2:channel}, ${3:sample}, ${4:time})",
			"scope": "source.vex",
			"description": "Returns the value of a CHOP channel at the specified sample and evaluation time."
	},
	"primvertexcount: geometry prim_num": {
			"prefix": "primvertexcount(geometry, prim_num)",
			"body": "primvertexcount(${1:geometry}, ${2:prim_num})",
			"scope": "source.vex",
			"description": "Returns number of vertices in a primitive in a geometry."
	},
	"pointvertices: geometry ptnum": {
			"prefix": "pointvertices(geometry, ptnum)",
			"body": "pointvertices(${1:geometry}, ${2:ptnum})",
			"scope": "source.vex",
			"description": "Returns the list of vertices connected to a point."
	},
	"chsop: channel": {
			"prefix": "chsop(channel)",
			"body": "chsop(${1:channel})",
			"scope": "source.vex",
			"description": "Evaluates an operator path parameter and return the path to the operator."
	},
	"chsop: channel time": {
			"prefix": "chsop(channel, time)",
			"body": "chsop(${1:channel}, ${2:time})",
			"scope": "source.vex",
			"description": "Evaluates an operator path parameter and return the path to the operator."
	},
	"refractlight: cf of af P D bias max_contrib ...": {
			"prefix": "refractlight(cf, of, af, P, D, bias, max_contrib, ...)",
			"body": "refractlight(${1:cf}, ${2:of}, ${3:af}, ${4:P}, ${5:D}, ${6:bias}, ${7:max_contrib}, ${8:...})",
			"scope": "source.vex",
			"description": "Computes the illumination of surfaces refracted by the current\nsurface."
	},
	"refractlight: cf of af P N I eta bias max_contrib ...": {
			"prefix": "refractlight(cf, of, af, P, N, I, eta, bias, max_contrib, ...)",
			"body": "refractlight(${1:cf}, ${2:of}, ${3:af}, ${4:P}, ${5:N}, ${6:I}, ${7:eta}, ${8:bias}, ${9:max_contrib}, ${10:...})",
			"scope": "source.vex",
			"description": "Computes the illumination of surfaces refracted by the current\nsurface."
	},
	"pcopenlod: filename Pchannel P min_pts ...": {
			"prefix": "pcopenlod(filename, Pchannel, P, min_pts, ...)",
			"body": "pcopenlod(${1:filename}, ${2:Pchannel}, ${3:P}, ${4:min_pts}, ${5:...})",
			"scope": "source.vex",
			"description": "Returns a handle to a point cloud file."
	},
	"setagentcollisionlayer: geohandle prim layername": {
			"prefix": "setagentcollisionlayer(geohandle, prim, layername)",
			"body": "setagentcollisionlayer(${1:geohandle}, ${2:prim}, ${3:layername})",
			"scope": "source.vex",
			"description": "Sets the collision layer of an agent primitive."
	},
	"random_shash: seed": {
			"prefix": "random_shash(seed)",
			"body": "random_shash(${1:seed})",
			"scope": "source.vex",
			"description": "Hashes a string to an integer."
	},
	"sample_normal: u": {
			"prefix": "sample_normal(u)",
			"body": "sample_normal(${1:u})",
			"scope": "source.vex",
			"description": "Samples the normal (Gaussian) distribution."
	},
	"sample_normal: mean stddev u": {
			"prefix": "sample_normal(mean, stddev, u)",
			"body": "sample_normal(${1:mean}, ${2:stddev}, ${3:u})",
			"scope": "source.vex",
			"description": "Samples the normal (Gaussian) distribution."
	},
	"sample_normal: origmean origstddev minvalue maxvalue u": {
			"prefix": "sample_normal(origmean, origstddev, minvalue, maxvalue, u)",
			"body": "sample_normal(${1:origmean}, ${2:origstddev}, ${3:minvalue}, ${4:maxvalue}, ${5:u})",
			"scope": "source.vex",
			"description": "Samples the normal (Gaussian) distribution."
	},
	"qrotate: quaternion v": {
			"prefix": "qrotate(quaternion, v)",
			"body": "qrotate(${1:quaternion}, ${2:v})",
			"scope": "source.vex",
			"description": "Rotates a vector by a quaternion."
	},
	"qmultiply: q1 q2": {
			"prefix": "qmultiply(q1, q2)",
			"body": "qmultiply(${1:q1}, ${2:q2})",
			"scope": "source.vex",
			"description": "Multiplies two quaternions and returns the result."
	},
	"chid: channel_path op_id parm_index vector_index": {
			"prefix": "chid(channel_path, op_id, parm_index, vector_index)",
			"body": "chid(${1:channel_path}, ${2:op_id}, ${3:parm_index}, ${4:vector_index})",
			"scope": "source.vex",
			"description": "Resolves a channel string (or parameter) and return op_id, parm_index and vector_index."
	},
	"chid: op_path channel_name op_id parm_index vector_index": {
			"prefix": "chid(op_path, channel_name, op_id, parm_index, vector_index)",
			"body": "chid(${1:op_path}, ${2:channel_name}, ${3:op_id}, ${4:parm_index}, ${5:vector_index})",
			"scope": "source.vex",
			"description": "Resolves a channel string (or parameter) and return op_id, parm_index and vector_index."
	},
	"chid: op_id parm_index vector_index": {
			"prefix": "chid(op_id, parm_index, vector_index)",
			"body": "chid(${1:op_id}, ${2:parm_index}, ${3:vector_index})",
			"scope": "source.vex",
			"description": "Resolves a channel string (or parameter) and return op_id, parm_index and vector_index."
	},
	"setprimgroup: geohandle name prim_num value mode": {
			"prefix": "setprimgroup(geohandle, name, prim_num, value, mode)",
			"body": "setprimgroup(${1:geohandle}, ${2:name}, ${3:prim_num}, ${4:value}, ${5:mode})",
			"scope": "source.vex",
			"description": "Adds or removes a primitive to/from a group in a geometry."
	},
	"choplocalt: filename channel sample time": {
			"prefix": "choplocalt(filename, channel, sample, time)",
			"body": "choplocalt(${1:filename}, ${2:channel}, ${3:sample}, ${4:time})",
			"scope": "source.vex",
			"description": "Returns the value of a CHOP local transform channel at the specified sample and evaluation time."
	},
	"detailattribtype: geometry attribute_name": {
			"prefix": "detailattribtype(geometry, attribute_name)",
			"body": "detailattribtype(${1:geometry}, ${2:attribute_name})",
			"scope": "source.vex",
			"description": "Returns the type of a geometry detail attribute."
	},
	"ambient: ...": {
			"prefix": "ambient(...)",
			"body": "ambient(${1:...})",
			"scope": "source.vex",
			"description": "Returns the color of ambient light in the scene."
	},
	"usd_pointinstance_getbbox_size: stage primpath instance_index purpose": {
			"prefix": "usd_pointinstance_getbbox_size(stage, primpath, instance_index, purpose)",
			"body": "usd_pointinstance_getbbox_size(${1:stage}, ${2:primpath}, ${3:instance_index}, ${4:purpose})",
			"scope": "source.vex",
			"description": "Returns the size of the bounding box for the instance inside a point instancer primitive."
	},
	"primvertices: geometry primnum": {
			"prefix": "primvertices(geometry, primnum)",
			"body": "primvertices(${1:geometry}, ${2:primnum})",
			"scope": "source.vex",
			"description": "Returns the list of vertices on a primitive."
	},
	"addvertexattrib: geohandle name defvalue": {
			"prefix": "addvertexattrib(geohandle, name, defvalue)",
			"body": "addvertexattrib(${1:geohandle}, ${2:name}, ${3:defvalue})",
			"scope": "source.vex",
			"description": "Adds a vertex attribute to a geometry."
	},
	"addvertexattrib: geohandle name defvalue typeinfo": {
			"prefix": "addvertexattrib(geohandle, name, defvalue, typeinfo)",
			"body": "addvertexattrib(${1:geohandle}, ${2:name}, ${3:defvalue}, ${4:typeinfo})",
			"scope": "source.vex",
			"description": "Adds a vertex attribute to a geometry."
	},
	"len: v": {
			"prefix": "len(v)",
			"body": "len(${1:v})",
			"scope": "source.vex",
			"description": "Returns the length of an array."
	},
	"len: m": {
			"prefix": "len(m)",
			"body": "len(${1:m})",
			"scope": "source.vex",
			"description": "Returns the length of an array."
	},
	"len: array": {
			"prefix": "len(array)",
			"body": "len(${1:array})",
			"scope": "source.vex",
			"description": "Returns the length of an array."
	},
	"len: s": {
			"prefix": "len(s)",
			"body": "len(${1:s})",
			"scope": "source.vex",
			"description": "Returns the length of an array."
	},
	"random_fhash: seed": {
			"prefix": "random_fhash(seed)",
			"body": "random_fhash(${1:seed})",
			"scope": "source.vex",
			"description": "Hashes floating point numbers to integers."
	},
	"random_fhash: seed seed2": {
			"prefix": "random_fhash(seed, seed2)",
			"body": "random_fhash(${1:seed}, ${2:seed2})",
			"scope": "source.vex",
			"description": "Hashes floating point numbers to integers."
	},
	"frac: n": {
			"prefix": "frac(n)",
			"body": "frac(${1:n})",
			"scope": "source.vex",
			"description": "Returns the fractional component of the floating point number."
	},
	"frac: v": {
			"prefix": "frac(v)",
			"body": "frac(${1:v})",
			"scope": "source.vex",
			"description": "Returns the fractional component of the floating point number."
	},
	"cspline: t val1 ...": {
			"prefix": "cspline(t, val1, ...)",
			"body": "cspline(${1:t}, ${2:val1}, ${3:...})",
			"scope": "source.vex",
			"description": "Samples a Catmull-Rom (Cardinal) spline defined by uniformly spaced keys."
	},
	"rand: seed": {
			"prefix": "rand(seed)",
			"body": "rand(${1:seed})",
			"scope": "source.vex",
			"description": "Creates a random number between 0 and 1 from a seed."
	},
	"rand: seed seed2": {
			"prefix": "rand(seed, seed2)",
			"body": "rand(${1:seed}, ${2:seed2})",
			"scope": "source.vex",
			"description": "Creates a random number between 0 and 1 from a seed."
	},
	"ocio_import: space property value": {
			"prefix": "ocio_import(space, property, value)",
			"body": "ocio_import(${1:space}, ${2:property}, ${3:value})",
			"scope": "source.vex",
			"description": "Imports attributes from OpenColorIO spaces."
	},
	"pointname: ": {
			"prefix": "pointname()",
			"body": "pointname()",
			"scope": "source.vex",
			"description": "Returns the default name of the point plane (as it appears in the\ncompositor preferences)."
	},
	"chattr: attrname success": {
			"prefix": "chattr(attrname, success)",
			"body": "chattr(${1:attrname}, ${2:success})",
			"scope": "source.vex",
			"description": "Reads from a CHOP attribute."
	},
	"chattr: opinput attrname success": {
			"prefix": "chattr(opinput, attrname, success)",
			"body": "chattr(${1:opinput}, ${2:attrname}, ${3:success})",
			"scope": "source.vex",
			"description": "Reads from a CHOP attribute."
	},
	"chattr: attrname channel success": {
			"prefix": "chattr(attrname, channel, success)",
			"body": "chattr(${1:attrname}, ${2:channel}, ${3:success})",
			"scope": "source.vex",
			"description": "Reads from a CHOP attribute."
	},
	"chattr: opinput attrname channel success": {
			"prefix": "chattr(opinput, attrname, channel, success)",
			"body": "chattr(${1:opinput}, ${2:attrname}, ${3:channel}, ${4:success})",
			"scope": "source.vex",
			"description": "Reads from a CHOP attribute."
	},
	"chattr: attrname channel sample success": {
			"prefix": "chattr(attrname, channel, sample, success)",
			"body": "chattr(${1:attrname}, ${2:channel}, ${3:sample}, ${4:success})",
			"scope": "source.vex",
			"description": "Reads from a CHOP attribute."
	},
	"chattr: opinput attrname channel sample success": {
			"prefix": "chattr(opinput, attrname, channel, sample, success)",
			"body": "chattr(${1:opinput}, ${2:attrname}, ${3:channel}, ${4:sample}, ${5:success})",
			"scope": "source.vex",
			"description": "Reads from a CHOP attribute."
	},
	"chattr: attrclass attrname channel sample success": {
			"prefix": "chattr(attrclass, attrname, channel, sample, success)",
			"body": "chattr(${1:attrclass}, ${2:attrname}, ${3:channel}, ${4:sample}, ${5:success})",
			"scope": "source.vex",
			"description": "Reads from a CHOP attribute."
	},
	"chattr: opinput attribclass attrname channel sample success": {
			"prefix": "chattr(opinput, attribclass, attrname, channel, sample, success)",
			"body": "chattr(${1:opinput}, ${2:attribclass}, ${3:attrname}, ${4:channel}, ${5:sample}, ${6:success})",
			"scope": "source.vex",
			"description": "Reads from a CHOP attribute."
	},
	"tw_space: ": {
			"prefix": "tw_space()",
			"body": "tw_space()",
			"scope": "source.vex",
			"description": "Transforms a position value from Texture to World space."
	},
	"tw_space: v": {
			"prefix": "tw_space(v)",
			"body": "tw_space(${1:v})",
			"scope": "source.vex",
			"description": "Transforms a position value from Texture to World space."
	},
	"usd_pointinstancetransform: stage primpath index": {
			"prefix": "usd_pointinstancetransform(stage, primpath, index)",
			"body": "usd_pointinstancetransform(${1:stage}, ${2:primpath}, ${3:index})",
			"scope": "source.vex",
			"description": "Obtains the transform for the given point instance"
	},
	"usd_pointinstancetransform: stage primpath index timecode": {
			"prefix": "usd_pointinstancetransform(stage, primpath, index, timecode)",
			"body": "usd_pointinstancetransform(${1:stage}, ${2:primpath}, ${3:index}, ${4:timecode})",
			"scope": "source.vex",
			"description": "Obtains the transform for the given point instance"
	},
	"addvisualizer: geohandle op_url": {
			"prefix": "addvisualizer(geohandle, op_url)",
			"body": "addvisualizer(${1:geohandle}, ${2:op_url})",
			"scope": "source.vex",
			"description": "Appends to a geometry\u2019s visualizer detail attribute."
	},
	"hedge_dstvertex: geometry hedge": {
			"prefix": "hedge_dstvertex(geometry, hedge)",
			"body": "hedge_dstvertex(${1:geometry}, ${2:hedge})",
			"scope": "source.vex",
			"description": "Returns the destination vertex of a half-edge."
	},
	"usd_setmetadataelement: stagehandle path name index value": {
			"prefix": "usd_setmetadataelement(stagehandle, path, name, index, value)",
			"body": "usd_setmetadataelement(${1:stagehandle}, ${2:path}, ${3:name}, ${4:index}, ${5:value})",
			"scope": "source.vex",
			"description": "Sets the value of an element in an array metadata."
	},
	"sample_circle_ring_uniform: u alpha": {
			"prefix": "sample_circle_ring_uniform(u, alpha)",
			"body": "sample_circle_ring_uniform(${1:u}, ${2:alpha})",
			"scope": "source.vex",
			"description": "Generates a uniform vector2 with alpha < length < 1, where 0 < alpha < 1, given a vector2 of uniform numbers between 0 and 1."
	},
	"getbounces: b": {
			"prefix": "getbounces(b)",
			"body": "getbounces(${1:b})",
			"scope": "source.vex",
			"description": ""
	},
	"teximport: map attribute value": {
			"prefix": "teximport(map, attribute, value)",
			"body": "teximport(${1:map}, ${2:attribute}, ${3:value})",
			"scope": "source.vex",
			"description": "Imports attributes from texture files."
	},
	"teximport: map token values": {
			"prefix": "teximport(map, token, values)",
			"body": "teximport(${1:map}, ${2:token}, ${3:values})",
			"scope": "source.vex",
			"description": "Imports attributes from texture files."
	},
	"agentlayerbindings: geometry prim layername shapetype": {
			"prefix": "agentlayerbindings(geometry, prim, layername, shapetype)",
			"body": "agentlayerbindings(${1:geometry}, ${2:prim}, ${3:layername}, ${4:shapetype})",
			"scope": "source.vex",
			"description": "Returns the transform that each shape in an agent\u2019s layer is bound to."
	},
	"usd_makepropertypath: stage primpath name": {
			"prefix": "usd_makepropertypath(stage, primpath, name)",
			"body": "usd_makepropertypath(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Constructs an property path from a primitive path and an property name."
	},
	"findattribval: geometry attribclass attribute_name value which": {
			"prefix": "findattribval(geometry, attribclass, attribute_name, value, which)",
			"body": "findattribval(${1:geometry}, ${2:attribclass}, ${3:attribute_name}, ${4:value}, ${5:which})",
			"scope": "source.vex",
			"description": "Finds a primitive/point/vertex that has a certain attribute value."
	},
	"findattribval: geometry attribclass attribute_name value": {
			"prefix": "findattribval(geometry, attribclass, attribute_name, value)",
			"body": "findattribval(${1:geometry}, ${2:attribclass}, ${3:attribute_name}, ${4:value})",
			"scope": "source.vex",
			"description": "Finds a primitive/point/vertex that has a certain attribute value."
	},
	"dsmpixel: map channel x y values": {
			"prefix": "dsmpixel(map, channel, x, y, values)",
			"body": "dsmpixel(${1:map}, ${2:channel}, ${3:x}, ${4:y}, ${5:values})",
			"scope": "source.vex",
			"description": "Reads the z-records stored in a pixel of a deep shadow map\nor deep camera map."
	},
	"getsamplestore: channel P value": {
			"prefix": "getsamplestore(channel, P, value)",
			"body": "getsamplestore(${1:channel}, ${2:P}, ${3:value})",
			"scope": "source.vex",
			"description": "Looks up sample data in a channel, referenced by a point."
	},
	"newsampler: ...": {
			"prefix": "newsampler(...)",
			"body": "newsampler(${1:...})",
			"scope": "source.vex",
			"description": "Initializes a sampling sequence for the nextsample function."
	},
	"newsampler: seed ...": {
			"prefix": "newsampler(seed, ...)",
			"body": "newsampler(${1:seed}, ${2:...})",
			"scope": "source.vex",
			"description": "Initializes a sampling sequence for the nextsample function."
	},
	"ocio_transform: dest clr": {
			"prefix": "ocio_transform(dest, clr)",
			"body": "ocio_transform(${1:dest}, ${2:clr})",
			"scope": "source.vex",
			"description": "Transform colors using Open Color IO"
	},
	"ocio_transform: src dest clr": {
			"prefix": "ocio_transform(src, dest, clr)",
			"body": "ocio_transform(${1:src}, ${2:dest}, ${3:clr})",
			"scope": "source.vex",
			"description": "Transform colors using Open Color IO"
	},
	"ocio_transform: src dest looks clr": {
			"prefix": "ocio_transform(src, dest, looks, clr)",
			"body": "ocio_transform(${1:src}, ${2:dest}, ${3:looks}, ${4:clr})",
			"scope": "source.vex",
			"description": "Transform colors using Open Color IO"
	},
	"getptextureid: ": {
			"prefix": "getptextureid()",
			"body": "getptextureid()",
			"scope": "source.vex",
			"description": "Returns the ptexture face id for the current primitive."
	},
	"usd_istype: stage primpath type": {
			"prefix": "usd_istype(stage, primpath, type)",
			"body": "usd_istype(${1:stage}, ${2:primpath}, ${3:type})",
			"scope": "source.vex",
			"description": "Checks if the primitive is of a given type."
	},
	"setprimattrib: geohandle name prim_num value mode": {
			"prefix": "setprimattrib(geohandle, name, prim_num, value, mode)",
			"body": "setprimattrib(${1:geohandle}, ${2:name}, ${3:prim_num}, ${4:value}, ${5:mode})",
			"scope": "source.vex",
			"description": "Sets a primitive attribute in a geometry."
	},
	"hasattrib: geometry attribclass attribute_name": {
			"prefix": "hasattrib(geometry, attribclass, attribute_name)",
			"body": "hasattrib(${1:geometry}, ${2:attribclass}, ${3:attribute_name})",
			"scope": "source.vex",
			"description": "Checks whether a geometry attribute exists."
	},
	"usd_transformorder: stage primpath": {
			"prefix": "usd_transformorder(stage, primpath)",
			"body": "usd_transformorder(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Obtains the primitive\u2019s transform order"
	},
	"solid_angle: b mask": {
			"prefix": "solid_angle(b, mask)",
			"body": "solid_angle(${1:b}, ${2:mask})",
			"scope": "source.vex",
			"description": "Computes the solid angle (in steradians) a BSDF function subtends."
	},
	"usd_attribtimesamples: stage primpath name": {
			"prefix": "usd_attribtimesamples(stage, primpath, name)",
			"body": "usd_attribtimesamples(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Returns the time codes at which the attribute values are authored."
	},
	"chrename: channel_index new_name": {
			"prefix": "chrename(channel_index, new_name)",
			"body": "chrename(${1:channel_index}, ${2:new_name})",
			"scope": "source.vex",
			"description": "Renames a CHOP channel."
	},
	"chrename: channel_name new_name": {
			"prefix": "chrename(channel_name, new_name)",
			"body": "chrename(${1:channel_name}, ${2:new_name})",
			"scope": "source.vex",
			"description": "Renames a CHOP channel."
	},
	"nametopoint: geometry name": {
			"prefix": "nametopoint(geometry, name)",
			"body": "nametopoint(${1:geometry}, ${2:name})",
			"scope": "source.vex",
			"description": "Finds a point by its name attribute."
	},
	"prim_normal: geometry prim_number uvw": {
			"prefix": "prim_normal(geometry, prim_number, uvw)",
			"body": "prim_normal(${1:geometry}, ${2:prim_number}, ${3:uvw})",
			"scope": "source.vex",
			"description": "Returns the normal of the primitive (prim_number) at parametric location u, v."
	},
	"prim_normal: geometry prim_number u v": {
			"prefix": "prim_normal(geometry, prim_number, u, v)",
			"body": "prim_normal(${1:geometry}, ${2:prim_number}, ${3:u}, ${4:v})",
			"scope": "source.vex",
			"description": "Returns the normal of the primitive (prim_number) at parametric location u, v."
	},
	"prim_normal: geometry prim_number u v w": {
			"prefix": "prim_normal(geometry, prim_number, u, v, w)",
			"body": "prim_normal(${1:geometry}, ${2:prim_number}, ${3:u}, ${4:v}, ${5:w})",
			"scope": "source.vex",
			"description": "Returns the normal of the primitive (prim_number) at parametric location u, v."
	},
	"setsamplestore: channel P value": {
			"prefix": "setsamplestore(channel, P, value)",
			"body": "setsamplestore(${1:channel}, ${2:P}, ${3:value})",
			"scope": "source.vex",
			"description": "Stores sample data in a channel, referenced by a point."
	},
	"atan: n": {
			"prefix": "atan(n)",
			"body": "atan(${1:n})",
			"scope": "source.vex",
			"description": "Returns the inverse tangent of the argument."
	},
	"atan: y x": {
			"prefix": "atan(y, x)",
			"body": "atan(${1:y}, ${2:x})",
			"scope": "source.vex",
			"description": "Returns the inverse tangent of the argument."
	},
	"atan: v": {
			"prefix": "atan(v)",
			"body": "atan(${1:v})",
			"scope": "source.vex",
			"description": "Returns the inverse tangent of the argument."
	},
	"usd_isstage: stage": {
			"prefix": "usd_isstage(stage)",
			"body": "usd_isstage(${1:stage})",
			"scope": "source.vex",
			"description": "Checks if the stage is valid."
	},
	"sampledisk: x y sx sy": {
			"prefix": "sampledisk(x, y, sx, sy)",
			"body": "sampledisk(${1:x}, ${2:y}, ${3:sx}, ${4:sy})",
			"scope": "source.vex",
			"description": "Warps uniform random samples to a disk."
	},
	"usd_ismetadata: stage path name": {
			"prefix": "usd_ismetadata(stage, path, name)",
			"body": "usd_ismetadata(${1:stage}, ${2:path}, ${3:name})",
			"scope": "source.vex",
			"description": "Checks if the primitive has metadata by the given name."
	},
	"getbbox_center: geometry": {
			"prefix": "getbbox_center(geometry)",
			"body": "getbbox_center(${1:geometry})",
			"scope": "source.vex",
			"description": "Returns the center of the bounding box for the geometry."
	},
	"getbbox_center: geometry primgroup": {
			"prefix": "getbbox_center(geometry, primgroup)",
			"body": "getbbox_center(${1:geometry}, ${2:primgroup})",
			"scope": "source.vex",
			"description": "Returns the center of the bounding box for the geometry."
	},
	"primpoint: geometry primnum vertex": {
			"prefix": "primpoint(geometry, primnum, vertex)",
			"body": "primpoint(${1:geometry}, ${2:primnum}, ${3:vertex})",
			"scope": "source.vex",
			"description": "Converts a primitive/vertex pair into a point number."
	},
	"flownoise: xyz flow": {
			"prefix": "flownoise(xyz, flow)",
			"body": "flownoise(${1:xyz}, ${2:flow})",
			"scope": "source.vex",
			"description": "Generates 1D and 3D Perlin Flow Noise from 3D and 4D data."
	},
	"flownoise: xyzt flow": {
			"prefix": "flownoise(xyzt, flow)",
			"body": "flownoise(${1:xyzt}, ${2:flow})",
			"scope": "source.vex",
			"description": "Generates 1D and 3D Perlin Flow Noise from 3D and 4D data."
	},
	"flownoise: x y flow": {
			"prefix": "flownoise(x, y, flow)",
			"body": "flownoise(${1:x}, ${2:y}, ${3:flow})",
			"scope": "source.vex",
			"description": "Generates 1D and 3D Perlin Flow Noise from 3D and 4D data."
	},
	"usd_variants: stage primpath variantset": {
			"prefix": "usd_variants(stage, primpath, variantset)",
			"body": "usd_variants(${1:stage}, ${2:primpath}, ${3:variantset})",
			"scope": "source.vex",
			"description": "Returns the variants belonging to the given variant set on a primitive."
	},
	"haslight: mat P light ...": {
			"prefix": "haslight(mat, P, light, ...)",
			"body": "haslight(${1:mat}, ${2:P}, ${3:light}, ${4:...})",
			"scope": "source.vex",
			"description": "Returns whether a light illuminates the given material."
	},
	"ctransform: fromspace tospace clr": {
			"prefix": "ctransform(fromspace, tospace, clr)",
			"body": "ctransform(${1:fromspace}, ${2:tospace}, ${3:clr})",
			"scope": "source.vex",
			"description": "Transforms between color spaces."
	},
	"ctransform: tospace clr": {
			"prefix": "ctransform(tospace, clr)",
			"body": "ctransform(${1:tospace}, ${2:clr})",
			"scope": "source.vex",
			"description": "Transforms between color spaces."
	},
	"primduv: geometry prim_number uv du dv": {
			"prefix": "primduv(geometry, prim_number, uv, du, dv)",
			"body": "primduv(${1:geometry}, ${2:prim_number}, ${3:uv}, ${4:du}, ${5:dv})",
			"scope": "source.vex",
			"description": "Returns position derivative on a primitive at a certain parametric (u, v) position."
	},
	"encodeparm: str": {
			"prefix": "encodeparm(str)",
			"body": "encodeparm(${1:str})",
			"scope": "source.vex",
			"description": "Encodes any string into a valid node parameter name."
	},
	"usd_relationshiptargets: stage primpath name": {
			"prefix": "usd_relationshiptargets(stage, primpath, name)",
			"body": "usd_relationshiptargets(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Obtains the relationship targets."
	},
	"mattrib: name P": {
			"prefix": "mattrib(name, P)",
			"body": "mattrib(${1:name}, ${2:P})",
			"scope": "source.vex",
			"description": "Returns the value of the point attribute for the metaballs if\nmetaball geometry is specified to i3dgen."
	},
	"agentcurrentlayer: geometry prim": {
			"prefix": "agentcurrentlayer(geometry, prim)",
			"body": "agentcurrentlayer(${1:geometry}, ${2:prim})",
			"scope": "source.vex",
			"description": "Returns the name of the current layer of an agent primitive."
	},
	"usd_typename: stage primpath": {
			"prefix": "usd_typename(stage, primpath)",
			"body": "usd_typename(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Returns the name of the primitive\u2019s type."
	},
	"predicate_incircle: a b c d": {
			"prefix": "predicate_incircle(a, b, c, d)",
			"body": "predicate_incircle(${1:a}, ${2:b}, ${3:c}, ${4:d})",
			"scope": "source.vex",
			"description": "Determines if a point is inside or outside a triangle circumcircle."
	},
	"abs: n": {
			"prefix": "abs(n)",
			"body": "abs(${1:n})",
			"scope": "source.vex",
			"description": "Returns the absolute value of the argument."
	},
	"abs: v": {
			"prefix": "abs(v)",
			"body": "abs(${1:v})",
			"scope": "source.vex",
			"description": "Returns the absolute value of the argument."
	},
	"depthname: ": {
			"prefix": "depthname()",
			"body": "depthname()",
			"scope": "source.vex",
			"description": "Returns the default name of the depth plane (as it appears in the\ncompositor preferences)."
	},
	"rotate: m amount": {
			"prefix": "rotate(m, amount)",
			"body": "rotate(${1:m}, ${2:amount})",
			"scope": "source.vex",
			"description": "Applies a rotation to the given matrix."
	},
	"rotate: m amount axis": {
			"prefix": "rotate(m, amount, axis)",
			"body": "rotate(${1:m}, ${2:amount}, ${3:axis})",
			"scope": "source.vex",
			"description": "Applies a rotation to the given matrix."
	},
	"rotate: m angles xyz": {
			"prefix": "rotate(m, angles, xyz)",
			"body": "rotate(${1:m}, ${2:angles}, ${3:xyz})",
			"scope": "source.vex",
			"description": "Applies a rotation to the given matrix."
	},
	"rotate: m angle axis": {
			"prefix": "rotate(m, angle, axis)",
			"body": "rotate(${1:m}, ${2:angle}, ${3:axis})",
			"scope": "source.vex",
			"description": "Applies a rotation to the given matrix."
	},
	"usd_pointinstance_getbbox: stage primpath instance_index purpose min max": {
			"prefix": "usd_pointinstance_getbbox(stage, primpath, instance_index, purpose, min, max)",
			"body": "usd_pointinstance_getbbox(${1:stage}, ${2:primpath}, ${3:instance_index}, ${4:purpose}, ${5:min}, ${6:max})",
			"scope": "source.vex",
			"description": "Sets two vectors to the minimum and maximum corners of the bounding box for the given instance inside point instancer."
	},
	"sample_direction_uniform: u": {
			"prefix": "sample_direction_uniform(u)",
			"body": "sample_direction_uniform(${1:u})",
			"scope": "source.vex",
			"description": "Generates a uniform unit vector, given a vector2 of uniform numbers between 0 and 1."
	},
	"cone: normal dir angle ...": {
			"prefix": "cone(normal, dir, angle, ...)",
			"body": "cone(${1:normal}, ${2:dir}, ${3:angle}, ${4:...})",
			"scope": "source.vex",
			"description": "Returns a cone reflection BSDF."
	},
	"cone: dir angle ...": {
			"prefix": "cone(dir, angle, ...)",
			"body": "cone(${1:dir}, ${2:angle}, ${3:...})",
			"scope": "source.vex",
			"description": "Returns a cone reflection BSDF."
	},
	"flowpnoise: xyz p flow": {
			"prefix": "flowpnoise(xyz, p, flow)",
			"body": "flowpnoise(${1:xyz}, ${2:p}, ${3:flow})",
			"scope": "source.vex",
			"description": "There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space."
	},
	"flowpnoise: xyzt p flow": {
			"prefix": "flowpnoise(xyzt, p, flow)",
			"body": "flowpnoise(${1:xyzt}, ${2:p}, ${3:flow})",
			"scope": "source.vex",
			"description": "There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space."
	},
	"flowpnoise: x y px py flow": {
			"prefix": "flowpnoise(x, y, px, py, flow)",
			"body": "flowpnoise(${1:x}, ${2:y}, ${3:px}, ${4:py}, ${5:flow})",
			"scope": "source.vex",
			"description": "There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space."
	},
	"flowpnoise: xyz px py pz flow": {
			"prefix": "flowpnoise(xyz, px, py, pz, flow)",
			"body": "flowpnoise(${1:xyz}, ${2:px}, ${3:py}, ${4:pz}, ${5:flow})",
			"scope": "source.vex",
			"description": "There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space."
	},
	"flowpnoise: xyzt px py pz pt flow": {
			"prefix": "flowpnoise(xyzt, px, py, pz, pt, flow)",
			"body": "flowpnoise(${1:xyzt}, ${2:px}, ${3:py}, ${4:pz}, ${5:pt}, ${6:flow})",
			"scope": "source.vex",
			"description": "There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space."
	},
	"nuniqueval: geometry attribclass attribute_name": {
			"prefix": "nuniqueval(geometry, attribclass, attribute_name)",
			"body": "nuniqueval(${1:geometry}, ${2:attribclass}, ${3:attribute_name})",
			"scope": "source.vex",
			"description": "Returns the number of unique values from an integer or string attribute."
	},
	"attribdataid: geometry attribclass attribute_name": {
			"prefix": "attribdataid(geometry, attribclass, attribute_name)",
			"body": "attribdataid(${1:geometry}, ${2:attribclass}, ${3:attribute_name})",
			"scope": "source.vex",
			"description": "Returns the data id of a geometry attribute."
	},
	"setagentchannelvalues: geohandle prim values": {
			"prefix": "setagentchannelvalues(geohandle, prim, values)",
			"body": "setagentchannelvalues(${1:geohandle}, ${2:prim}, ${3:values})",
			"scope": "source.vex",
			"description": "Overrides the values of an agent primitive\u2019s channels."
	},
	"isdigit: str": {
			"prefix": "isdigit(str)",
			"body": "isdigit(${1:str})",
			"scope": "source.vex",
			"description": "Returns 1 if all the characters in the string are numeric"
	},
	"addpoint: geohandle point_number": {
			"prefix": "addpoint(geohandle, point_number)",
			"body": "addpoint(${1:geohandle}, ${2:point_number})",
			"scope": "source.vex",
			"description": "Adds a point to the geometry."
	},
	"addpoint: geohandle pos": {
			"prefix": "addpoint(geohandle, pos)",
			"body": "addpoint(${1:geohandle}, ${2:pos})",
			"scope": "source.vex",
			"description": "Adds a point to the geometry."
	},
	"usd_primvarsize: stage primpath name": {
			"prefix": "usd_primvarsize(stage, primpath, name)",
			"body": "usd_primvarsize(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Returns the tuple size of the primvar."
	},
	"array: ...": {
			"prefix": "array(...)",
			"body": "array(${1:...})",
			"scope": "source.vex",
			"description": "Efficiently creates an array from its arguments."
	},
	"hsvtorgb: hsv": {
			"prefix": "hsvtorgb(hsv)",
			"body": "hsvtorgb(${1:hsv})",
			"scope": "source.vex",
			"description": "Convert HSV color space into RGB color space."
	},
	"hsvtorgb: hue sat val": {
			"prefix": "hsvtorgb(hue, sat, val)",
			"body": "hsvtorgb(${1:hue}, ${2:sat}, ${3:val})",
			"scope": "source.vex",
			"description": "Convert HSV color space into RGB color space."
	},
	"distance: a b": {
			"prefix": "distance(a, b)",
			"body": "distance(${1:a}, ${2:b})",
			"scope": "source.vex",
			"description": "Returns the distance between two points."
	},
	"hasdetailattrib: geometry attribute_name": {
			"prefix": "hasdetailattrib(geometry, attribute_name)",
			"body": "hasdetailattrib(${1:geometry}, ${2:attribute_name})",
			"scope": "source.vex",
			"description": "Returns if a geometry detail attribute exists."
	},
	"hedge_primary: geometry hedge": {
			"prefix": "hedge_primary(geometry, hedge)",
			"body": "hedge_primary(${1:geometry}, ${2:hedge})",
			"scope": "source.vex",
			"description": "Returns the primary half-edge equivalent to a given half-edge."
	},
	"translate: m amount": {
			"prefix": "translate(m, amount)",
			"body": "translate(${1:m}, ${2:amount})",
			"scope": "source.vex",
			"description": "Translates a matrix by a vector."
	},
	"pcimport: handle channel_name value": {
			"prefix": "pcimport(handle, channel_name, value)",
			"body": "pcimport(${1:handle}, ${2:channel_name}, ${3:value})",
			"scope": "source.vex",
			"description": "Imports channel data from a point cloud inside a pciterate or a pcunshaded loop."
	},
	"agentclipstarttime: geometry prim clipname": {
			"prefix": "agentclipstarttime(geometry, prim, clipname)",
			"body": "agentclipstarttime(${1:geometry}, ${2:prim}, ${3:clipname})",
			"scope": "source.vex",
			"description": "Returns the start time (in seconds) of an agent\u2019s animation clip."
	},
	"volumeres: geometry primnum": {
			"prefix": "volumeres(geometry, primnum)",
			"body": "volumeres(${1:geometry}, ${2:primnum})",
			"scope": "source.vex",
			"description": "Gets the resolution of a volume primitive."
	},
	"volumeres: geometry volumename": {
			"prefix": "volumeres(geometry, volumename)",
			"body": "volumeres(${1:geometry}, ${2:volumename})",
			"scope": "source.vex",
			"description": "Gets the resolution of a volume primitive."
	},
	"intersect_lights: lightids pos dir time idx dist clr scale ...": {
			"prefix": "intersect_lights(lightids, pos, dir, time, idx, dist, clr, scale, ...)",
			"body": "intersect_lights(${1:lightids}, ${2:pos}, ${3:dir}, ${4:time}, ${5:idx}, ${6:dist}, ${7:clr}, ${8:scale}, ${9:...})",
			"scope": "source.vex",
			"description": "Finds the nearest intersection of a ray with any of a list of (area) lights and runs the light shader at the intersection point."
	},
	"sample_cdf: cdf uniform_rand": {
			"prefix": "sample_cdf(cdf, uniform_rand)",
			"body": "sample_cdf(${1:cdf}, ${2:uniform_rand})",
			"scope": "source.vex",
			"description": "Samples a CDF."
	},
	"sample_cdf: cdf uniform_rand index x": {
			"prefix": "sample_cdf(cdf, uniform_rand, index, x)",
			"body": "sample_cdf(${1:cdf}, ${2:uniform_rand}, ${3:index}, ${4:x})",
			"scope": "source.vex",
			"description": "Samples a CDF."
	},
	"sample_cdf: cdf uniform_rand index x pdf": {
			"prefix": "sample_cdf(cdf, uniform_rand, index, x, pdf)",
			"body": "sample_cdf(${1:cdf}, ${2:uniform_rand}, ${3:index}, ${4:x}, ${5:pdf})",
			"scope": "source.vex",
			"description": "Samples a CDF."
	},
	"usd_worldtransform: stage primpath": {
			"prefix": "usd_worldtransform(stage, primpath)",
			"body": "usd_worldtransform(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Obtains the primitive\u2019s world transform"
	},
	"usd_worldtransform: stage primpath timecode": {
			"prefix": "usd_worldtransform(stage, primpath, timecode)",
			"body": "usd_worldtransform(${1:stage}, ${2:primpath}, ${3:timecode})",
			"scope": "source.vex",
			"description": "Obtains the primitive\u2019s world transform"
	},
	"cvex_bsdf: eval_cvex_shader sampler_cvex_shader ...": {
			"prefix": "cvex_bsdf(eval_cvex_shader, sampler_cvex_shader, ...)",
			"body": "cvex_bsdf(${1:eval_cvex_shader}, ${2:sampler_cvex_shader}, ${3:...})",
			"scope": "source.vex",
			"description": "Creates a bsdf object from two CVEX shader strings."
	},
	"quaternion: rotations": {
			"prefix": "quaternion(rotations)",
			"body": "quaternion(${1:rotations})",
			"scope": "source.vex",
			"description": "Creates a vector4 representing a quaternion."
	},
	"quaternion: angle axis": {
			"prefix": "quaternion(angle, axis)",
			"body": "quaternion(${1:angle}, ${2:axis})",
			"scope": "source.vex",
			"description": "Creates a vector4 representing a quaternion."
	},
	"quaternion: angleaxis": {
			"prefix": "quaternion(angleaxis)",
			"body": "quaternion(${1:angleaxis})",
			"scope": "source.vex",
			"description": "Creates a vector4 representing a quaternion."
	},
	"planesize: planeindex": {
			"prefix": "planesize(planeindex)",
			"body": "planesize(${1:planeindex})",
			"scope": "source.vex",
			"description": "Returns the number of components in the plane (1 for scalar planes\nand up to 4 for vector planes)."
	},
	"chramp: channel ramppos": {
			"prefix": "chramp(channel, ramppos)",
			"body": "chramp(${1:channel}, ${2:ramppos})",
			"scope": "source.vex",
			"description": "Evaluates a ramp parameter and return its value."
	},
	"chramp: channel ramppos time": {
			"prefix": "chramp(channel, ramppos, time)",
			"body": "chramp(${1:channel}, ${2:ramppos}, ${3:time})",
			"scope": "source.vex",
			"description": "Evaluates a ramp parameter and return its value."
	},
	"fuzzy_or: a b ...": {
			"prefix": "fuzzy_or(a, b, ...)",
			"body": "fuzzy_or(${1:a}, ${2:b}, ${3:...})",
			"scope": "source.vex",
			"description": ""
	},
	"fromNDC: v": {
			"prefix": "fromNDC(v)",
			"body": "fromNDC(${1:v})",
			"scope": "source.vex",
			"description": "Transforms a position from normal device coordinates to the\ncoordinates in the appropriate space."
	},
	"fromNDC: space v": {
			"prefix": "fromNDC(space, v)",
			"body": "fromNDC(${1:space}, ${2:v})",
			"scope": "source.vex",
			"description": "Transforms a position from normal device coordinates to the\ncoordinates in the appropriate space."
	},
	"nprimitivesgroup: geometry groupname": {
			"prefix": "nprimitivesgroup(geometry, groupname)",
			"body": "nprimitivesgroup(${1:geometry}, ${2:groupname})",
			"scope": "source.vex",
			"description": "Returns the number of primitives in the group."
	},
	"isuvrendering: ": {
			"prefix": "isuvrendering()",
			"body": "isuvrendering()",
			"scope": "source.vex",
			"description": "Indicates whether the shader is being evaluated while doing UV rendering (e.g. texture unwrapping)"
	},
	"agentcliplength: geometry prim clipname": {
			"prefix": "agentcliplength(geometry, prim, clipname)",
			"body": "agentcliplength(${1:geometry}, ${2:prim}, ${3:clipname})",
			"scope": "source.vex",
			"description": "Returns the length (in seconds) of an agent\u2019s animation clip."
	},
	"osd_limitsurfacevertex: geometry attrib_name face_id u v result": {
			"prefix": "osd_limitsurfacevertex(geometry, attrib_name, face_id, u, v, result)",
			"body": "osd_limitsurfacevertex(${1:geometry}, ${2:attrib_name}, ${3:face_id}, ${4:u}, ${5:v}, ${6:result})",
			"scope": "source.vex",
			"description": "Evaluates a vertex attribute at the subdivision limit surface using Open Subdiv."
	},
	"fuzzy_and: a b ...": {
			"prefix": "fuzzy_and(a, b, ...)",
			"body": "fuzzy_and(${1:a}, ${2:b}, ${3:...})",
			"scope": "source.vex",
			"description": ""
	},
	"chrate: ": {
			"prefix": "chrate()",
			"body": "chrate()",
			"scope": "source.vex",
			"description": "Returns the sample rate of the input specified."
	},
	"chrate: opinput": {
			"prefix": "chrate(opinput)",
			"body": "chrate(${1:opinput})",
			"scope": "source.vex",
			"description": "Returns the sample rate of the input specified."
	},
	"snoise: pos": {
			"prefix": "snoise(pos)",
			"body": "snoise(${1:pos})",
			"scope": "source.vex",
			"description": "These functions are similar to wnoise."
	},
	"snoise: pos turbulence rough atten": {
			"prefix": "snoise(pos, turbulence, rough, atten)",
			"body": "snoise(${1:pos}, ${2:turbulence}, ${3:rough}, ${4:atten})",
			"scope": "source.vex",
			"description": "These functions are similar to wnoise."
	},
	"snoise: pos periodX periodY periodZ": {
			"prefix": "snoise(pos, periodX, periodY, periodZ)",
			"body": "snoise(${1:pos}, ${2:periodX}, ${3:periodY}, ${4:periodZ})",
			"scope": "source.vex",
			"description": "These functions are similar to wnoise."
	},
	"snoise: pos periodX periodY periodZ turbulence rough atten": {
			"prefix": "snoise(pos, periodX, periodY, periodZ, turbulence, rough, atten)",
			"body": "snoise(${1:pos}, ${2:periodX}, ${3:periodY}, ${4:periodZ}, ${5:turbulence}, ${6:rough}, ${7:atten})",
			"scope": "source.vex",
			"description": "These functions are similar to wnoise."
	},
	"re_match: regex input": {
			"prefix": "re_match(regex, input)",
			"body": "re_match(${1:regex}, ${2:input})",
			"scope": "source.vex",
			"description": "Returns 1 if the entire input string matches the expression"
	},
	"sssapprox: albedo meanFreePath roughness scale ...": {
			"prefix": "sssapprox(albedo, meanFreePath, roughness, scale, ...)",
			"body": "sssapprox(${1:albedo}, ${2:meanFreePath}, ${3:roughness}, ${4:scale}, ${5:...})",
			"scope": "source.vex",
			"description": "Creates an approximate SSS BSDF."
	},
	"usd_clearmetadata: stagehandle path name": {
			"prefix": "usd_clearmetadata(stagehandle, path, name)",
			"body": "usd_clearmetadata(${1:stagehandle}, ${2:path}, ${3:name})",
			"scope": "source.vex",
			"description": "Clears the value of the metadata."
	},
	"hscript_sturb: pos turbulence": {
			"prefix": "hscript_sturb(pos, turbulence)",
			"body": "hscript_sturb(${1:pos}, ${2:turbulence})",
			"scope": "source.vex",
			"description": ""
	},
	"clip: result p0 p1 plane": {
			"prefix": "clip(result, p0, p1, plane)",
			"body": "clip(${1:result}, ${2:p0}, ${3:p1}, ${4:plane})",
			"scope": "source.vex",
			"description": "Clip the line segment between p0 and p1."
	},
	"clip: result p0 p1 min max": {
			"prefix": "clip(result, p0, p1, min, max)",
			"body": "clip(${1:result}, ${2:p0}, ${3:p1}, ${4:min}, ${5:max})",
			"scope": "source.vex",
			"description": "Clip the line segment between p0 and p1."
	},
	"split_bsdf: lobes source weights": {
			"prefix": "split_bsdf(lobes, source, weights)",
			"body": "split_bsdf(${1:lobes}, ${2:source}, ${3:weights})",
			"scope": "source.vex",
			"description": "Splits a bsdf into its component lobes."
	},
	"split_bsdf: lobes source weights mask": {
			"prefix": "split_bsdf(lobes, source, weights, mask)",
			"body": "split_bsdf(${1:lobes}, ${2:source}, ${3:weights}, ${4:mask})",
			"scope": "source.vex",
			"description": "Splits a bsdf into its component lobes."
	},
	"split_bsdf: lobes source weights mask type": {
			"prefix": "split_bsdf(lobes, source, weights, mask, type)",
			"body": "split_bsdf(${1:lobes}, ${2:source}, ${3:weights}, ${4:mask}, ${5:type})",
			"scope": "source.vex",
			"description": "Splits a bsdf into its component lobes."
	},
	"split_bsdf: lobes source weights mask type u": {
			"prefix": "split_bsdf(lobes, source, weights, mask, type, u)",
			"body": "split_bsdf(${1:lobes}, ${2:source}, ${3:weights}, ${4:mask}, ${5:type}, ${6:u})",
			"scope": "source.vex",
			"description": "Splits a bsdf into its component lobes."
	},
	"split_bsdf: lobes source weights mask type u cdf": {
			"prefix": "split_bsdf(lobes, source, weights, mask, type, u, cdf)",
			"body": "split_bsdf(${1:lobes}, ${2:source}, ${3:weights}, ${4:mask}, ${5:type}, ${6:u}, ${7:cdf})",
			"scope": "source.vex",
			"description": "Splits a bsdf into its component lobes."
	},
	"ashikhmin: exponentx exponenty framex framey ...": {
			"prefix": "ashikhmin(exponentx, exponenty, framex, framey, ...)",
			"body": "ashikhmin(${1:exponentx}, ${2:exponenty}, ${3:framex}, ${4:framey}, ${5:...})",
			"scope": "source.vex",
			"description": "Returns a specular BSDF using the Ashikhmin shading model."
	},
	"ashikhmin: nml exponentx exponenty framex framey ...": {
			"prefix": "ashikhmin(nml, exponentx, exponenty, framex, framey, ...)",
			"body": "ashikhmin(${1:nml}, ${2:exponentx}, ${3:exponenty}, ${4:framex}, ${5:framey}, ${6:...})",
			"scope": "source.vex",
			"description": "Returns a specular BSDF using the Ashikhmin shading model."
	},
	"getraylevel: ": {
			"prefix": "getraylevel()",
			"body": "getraylevel()",
			"scope": "source.vex",
			"description": "Returns the depth of the ray tree for the current shading."
	},
	"usd_isprim: stage primpath": {
			"prefix": "usd_isprim(stage, primpath)",
			"body": "usd_isprim(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Checks if the path refers to a valid primitive."
	},
	"sin: n": {
			"prefix": "sin(n)",
			"body": "sin(${1:n})",
			"scope": "source.vex",
			"description": "Returns the sine of the argument."
	},
	"cos: n": {
			"prefix": "cos(n)",
			"body": "cos(${1:n})",
			"scope": "source.vex",
			"description": "Returns the cosine of the argument."
	},
	"metadata: opinput name": {
			"prefix": "metadata(opinput, name)",
			"body": "metadata(${1:opinput}, ${2:name})",
			"scope": "source.vex",
			"description": "Returns a metadata value from a composite operator."
	},
	"metadata: opinput name index": {
			"prefix": "metadata(opinput, name, index)",
			"body": "metadata(${1:opinput}, ${2:name}, ${3:index})",
			"scope": "source.vex",
			"description": "Returns a metadata value from a composite operator."
	},
	"hedge_postdstvertex: geometry hedge": {
			"prefix": "hedge_postdstvertex(geometry, hedge)",
			"body": "hedge_postdstvertex(${1:geometry}, ${2:hedge})",
			"scope": "source.vex",
			"description": "Returns the vertex following the destination vertex of a half-edge in its primitive."
	},
	"iendtime: opinput": {
			"prefix": "iendtime(opinput)",
			"body": "iendtime(${1:opinput})",
			"scope": "source.vex",
			"description": "Returns the end time of the specified input."
	},
	"re_find: regex input": {
			"prefix": "re_find(regex, input)",
			"body": "re_find(${1:regex}, ${2:input})",
			"scope": "source.vex",
			"description": "Matches a regular expression in a string"
	},
	"re_find: regex input start": {
			"prefix": "re_find(regex, input, start)",
			"body": "re_find(${1:regex}, ${2:input}, ${3:start})",
			"scope": "source.vex",
			"description": "Matches a regular expression in a string"
	},
	"re_find: regex input start end": {
			"prefix": "re_find(regex, input, start, end)",
			"body": "re_find(${1:regex}, ${2:input}, ${3:start}, ${4:end})",
			"scope": "source.vex",
			"description": "Matches a regular expression in a string"
	},
	"re_find: start_pos end_pos regex input": {
			"prefix": "re_find(start_pos, end_pos, regex, input)",
			"body": "re_find(${1:start_pos}, ${2:end_pos}, ${3:regex}, ${4:input})",
			"scope": "source.vex",
			"description": "Matches a regular expression in a string"
	},
	"re_find: start_pos end_pos regex input start": {
			"prefix": "re_find(start_pos, end_pos, regex, input, start)",
			"body": "re_find(${1:start_pos}, ${2:end_pos}, ${3:regex}, ${4:input}, ${5:start})",
			"scope": "source.vex",
			"description": "Matches a regular expression in a string"
	},
	"re_find: start_pos end_pos regex input start end": {
			"prefix": "re_find(start_pos, end_pos, regex, input, start, end)",
			"body": "re_find(${1:start_pos}, ${2:end_pos}, ${3:regex}, ${4:input}, ${5:start}, ${6:end})",
			"scope": "source.vex",
			"description": "Matches a regular expression in a string"
	},
	"reflectlight: bias max_contrib ...": {
			"prefix": "reflectlight(bias, max_contrib, ...)",
			"body": "reflectlight(${1:bias}, ${2:max_contrib}, ${3:...})",
			"scope": "source.vex",
			"description": "Computes the amount of reflected light which hits the surface."
	},
	"reflectlight: P D bias max_contrib ...": {
			"prefix": "reflectlight(P, D, bias, max_contrib, ...)",
			"body": "reflectlight(${1:P}, ${2:D}, ${3:bias}, ${4:max_contrib}, ${5:...})",
			"scope": "source.vex",
			"description": "Computes the amount of reflected light which hits the surface."
	},
	"reflectlight: P N I bias max_contrib ...": {
			"prefix": "reflectlight(P, N, I, bias, max_contrib, ...)",
			"body": "reflectlight(${1:P}, ${2:N}, ${3:I}, ${4:bias}, ${5:max_contrib}, ${6:...})",
			"scope": "source.vex",
			"description": "Computes the amount of reflected light which hits the surface."
	},
	"agenttransformgroups: geometry prim": {
			"prefix": "agenttransformgroups(geometry, prim)",
			"body": "agenttransformgroups(${1:geometry}, ${2:prim})",
			"scope": "source.vex",
			"description": "Returns the names of the transform groups in an agent\u2019s definition."
	},
	"curlxnoise: xyz": {
			"prefix": "curlxnoise(xyz)",
			"body": "curlxnoise(${1:xyz})",
			"scope": "source.vex",
			"description": "Computes divergence free noise based on Simplex noise."
	},
	"curlxnoise: xyzt": {
			"prefix": "curlxnoise(xyzt)",
			"body": "curlxnoise(${1:xyzt})",
			"scope": "source.vex",
			"description": "Computes divergence free noise based on Simplex noise."
	},
	"getpointbbox_min: geometry": {
			"prefix": "getpointbbox_min(geometry)",
			"body": "getpointbbox_min(${1:geometry})",
			"scope": "source.vex",
			"description": "Returns the minimum of the bounding box for the geometry."
	},
	"getpointbbox_min: geometry pointgroup": {
			"prefix": "getpointbbox_min(geometry, pointgroup)",
			"body": "getpointbbox_min(${1:geometry}, ${2:pointgroup})",
			"scope": "source.vex",
			"description": "Returns the minimum of the bounding box for the geometry."
	},
	"usd_addrotate: stagehandle primpath suffix axis angle": {
			"prefix": "usd_addrotate(stagehandle, primpath, suffix, axis, angle)",
			"body": "usd_addrotate(${1:stagehandle}, ${2:primpath}, ${3:suffix}, ${4:axis}, ${5:angle})",
			"scope": "source.vex",
			"description": "Applies a rotation to the primitive"
	},
	"usd_addrotate: stagehandle primpath suffix xyz angles": {
			"prefix": "usd_addrotate(stagehandle, primpath, suffix, xyz, angles)",
			"body": "usd_addrotate(${1:stagehandle}, ${2:primpath}, ${3:suffix}, ${4:xyz}, ${5:angles})",
			"scope": "source.vex",
			"description": "Applies a rotation to the primitive"
	},
	"cbrt: n": {
			"prefix": "cbrt(n)",
			"body": "cbrt(${1:n})",
			"scope": "source.vex",
			"description": "Returns the cube root of the argument."
	},
	"cbrt: v": {
			"prefix": "cbrt(v)",
			"body": "cbrt(${1:v})",
			"scope": "source.vex",
			"description": "Returns the cube root of the argument."
	},
	"pcconvex: handle channel N": {
			"prefix": "pcconvex(handle, channel, N)",
			"body": "pcconvex(${1:handle}, ${2:channel}, ${3:N})",
			"scope": "source.vex",
			"description": ""
	},
	"usd_iskind: stage primpath kind": {
			"prefix": "usd_iskind(stage, primpath, kind)",
			"body": "usd_iskind(${1:stage}, ${2:primpath}, ${3:kind})",
			"scope": "source.vex",
			"description": "Checks if the primitive is of a given kind."
	},
	"removeindex: array index": {
			"prefix": "removeindex(array, index)",
			"body": "removeindex(${1:array}, ${2:index})",
			"scope": "source.vex",
			"description": "Removes an item at the given index from an array."
	},
	"ocio_spaces: ": {
			"prefix": "ocio_spaces()",
			"body": "ocio_spaces()",
			"scope": "source.vex",
			"description": "Returns the names of color spaces supported in Open Color IO."
	},
	"removevertex: geohandle linear_vertex_index": {
			"prefix": "removevertex(geohandle, linear_vertex_index)",
			"body": "removevertex(${1:geohandle}, ${2:linear_vertex_index})",
			"scope": "source.vex",
			"description": "Removes a vertex from the geometry."
	},
	"ixres: opinput": {
			"prefix": "ixres(opinput)",
			"body": "ixres(${1:opinput})",
			"scope": "source.vex",
			"description": "Returns the X resolution of the specified input."
	},
	"agentrigfind: geometry prim transformname": {
			"prefix": "agentrigfind(geometry, prim, transformname)",
			"body": "agentrigfind(${1:geometry}, ${2:prim}, ${3:transformname})",
			"scope": "source.vex",
			"description": "Finds the index of a transform in an agent primitive\u2019s rig."
	},
	"decode: str": {
			"prefix": "decode(str)",
			"body": "decode(${1:str})",
			"scope": "source.vex",
			"description": "Decodes a variable name that was previously encoded."
	},
	"strlen: string": {
			"prefix": "strlen(string)",
			"body": "strlen(${1:string})",
			"scope": "source.vex",
			"description": "Returns the length of the string."
	},
	"isconnected: opinput": {
			"prefix": "isconnected(opinput)",
			"body": "isconnected(${1:opinput})",
			"scope": "source.vex",
			"description": "Returns 1 if input_number is connected, or 0 if the input is not connected."
	},
	"volumeindexorigin: geometry primnum": {
			"prefix": "volumeindexorigin(geometry, primnum)",
			"body": "volumeindexorigin(${1:geometry}, ${2:primnum})",
			"scope": "source.vex",
			"description": "Gets the index of the bottom left of a volume primitive."
	},
	"volumeindexorigin: geometry volumename": {
			"prefix": "volumeindexorigin(geometry, volumename)",
			"body": "volumeindexorigin(${1:geometry}, ${2:volumename})",
			"scope": "source.vex",
			"description": "Gets the index of the bottom left of a volume primitive."
	},
	"getspace: fromspace tospace": {
			"prefix": "getspace(fromspace, tospace)",
			"body": "getspace(${1:fromspace}, ${2:tospace})",
			"scope": "source.vex",
			"description": "Returns a transform from one space to another."
	},
	"upush: array value": {
			"prefix": "upush(array, value)",
			"body": "upush(${1:array}, ${2:value})",
			"scope": "source.vex",
			"description": "Adds a uniform item to an array."
	},
	"hedge_presrcvertex: geometry hedge": {
			"prefix": "hedge_presrcvertex(geometry, hedge)",
			"body": "hedge_presrcvertex(${1:geometry}, ${2:hedge})",
			"scope": "source.vex",
			"description": "Returns the vertex that precedes the source vertex of a half-edge in its primitive."
	},
	"irate: opinput": {
			"prefix": "irate(opinput)",
			"body": "irate(${1:opinput})",
			"scope": "source.vex",
			"description": "Returns the frame rate of the specified input."
	},
	"wt_space: ": {
			"prefix": "wt_space()",
			"body": "wt_space()",
			"scope": "source.vex",
			"description": "Transforms a position value from World to Texture space."
	},
	"wt_space: v": {
			"prefix": "wt_space(v)",
			"body": "wt_space(${1:v})",
			"scope": "source.vex",
			"description": "Transforms a position value from World to Texture space."
	},
	"solvecubic: a b c d t1 t2 t3": {
			"prefix": "solvecubic(a, b, c, d, t1, t2, t3)",
			"body": "solvecubic(${1:a}, ${2:b}, ${3:c}, ${4:d}, ${5:t1}, ${6:t2}, ${7:t3})",
			"scope": "source.vex",
			"description": "Solves a cubic function returning the number of real roots."
	},
	"sample_geometry: origin sample time ...": {
			"prefix": "sample_geometry(origin, sample, time, ...)",
			"body": "sample_geometry(${1:origin}, ${2:sample}, ${3:time}, ${4:...})",
			"scope": "source.vex",
			"description": "Samples geometry in the scene and returns information from the shaders of surfaces that were sampled."
	},
	"hasmetadata: opinput name": {
			"prefix": "hasmetadata(opinput, name)",
			"body": "hasmetadata(${1:opinput}, ${2:name})",
			"scope": "source.vex",
			"description": "Queries if metadata exists on a composite operator."
	},
	"setagentchannelvalue: geohandle prim value channel": {
			"prefix": "setagentchannelvalue(geohandle, prim, value, channel)",
			"body": "setagentchannelvalue(${1:geohandle}, ${2:prim}, ${3:value}, ${4:channel})",
			"scope": "source.vex",
			"description": "Overrides the value of an agent primitive\u2019s channel."
	},
	"usd_primvarindices: stage primpath name": {
			"prefix": "usd_primvarindices(stage, primpath, name)",
			"body": "usd_primvarindices(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Returns the index array of an indexed primvar."
	},
	"usd_primvarindices: stage primpath name timecode": {
			"prefix": "usd_primvarindices(stage, primpath, name, timecode)",
			"body": "usd_primvarindices(${1:stage}, ${2:primpath}, ${3:name}, ${4:timecode})",
			"scope": "source.vex",
			"description": "Returns the index array of an indexed primvar."
	},
	"usd_relbbox: stage primpath purpose position": {
			"prefix": "usd_relbbox(stage, primpath, purpose, position)",
			"body": "usd_relbbox(${1:stage}, ${2:primpath}, ${3:purpose}, ${4:position})",
			"scope": "source.vex",
			"description": "Returns the relative position of the point given with respect to the bounding box of the geometry."
	},
	"isframes: ": {
			"prefix": "isframes()",
			"body": "isframes()",
			"scope": "source.vex",
			"description": "Returns 1 if the Vex CHOP\u2019s Unit Menu is currently set to 'frames', 0\notherwise."
	},
	"ocio_roles: ": {
			"prefix": "ocio_roles()",
			"body": "ocio_roles()",
			"scope": "source.vex",
			"description": "Returns the names of roles supported in Open Color IO"
	},
	"alphaname: ": {
			"prefix": "alphaname()",
			"body": "alphaname()",
			"scope": "source.vex",
			"description": "Returns the default name of the alpha plane (as it appears in the\ncompositor preferences)."
	},
	"xnoise: x": {
			"prefix": "xnoise(x)",
			"body": "xnoise(${1:x})",
			"scope": "source.vex",
			"description": "Simplex noise is very close to Perlin noise, except with the samples on a simplex mesh rather than a grid.  This results in less grid artifacts.  It also uses a higher order bspline to provide better derivatives."
	},
	"xnoise: x y": {
			"prefix": "xnoise(x, y)",
			"body": "xnoise(${1:x}, ${2:y})",
			"scope": "source.vex",
			"description": "Simplex noise is very close to Perlin noise, except with the samples on a simplex mesh rather than a grid.  This results in less grid artifacts.  It also uses a higher order bspline to provide better derivatives."
	},
	"xnoise: xyz": {
			"prefix": "xnoise(xyz)",
			"body": "xnoise(${1:xyz})",
			"scope": "source.vex",
			"description": "Simplex noise is very close to Perlin noise, except with the samples on a simplex mesh rather than a grid.  This results in less grid artifacts.  It also uses a higher order bspline to provide better derivatives."
	},
	"xnoise: xyzt": {
			"prefix": "xnoise(xyzt)",
			"body": "xnoise(${1:xyzt})",
			"scope": "source.vex",
			"description": "Simplex noise is very close to Perlin noise, except with the samples on a simplex mesh rather than a grid.  This results in less grid artifacts.  It also uses a higher order bspline to provide better derivatives."
	},
	"cracktransform: trs xyz c pivot pivot_rotate xform": {
			"prefix": "cracktransform(trs, xyz, c, pivot, pivot_rotate, xform)",
			"body": "cracktransform(${1:trs}, ${2:xyz}, ${3:c}, ${4:pivot}, ${5:pivot_rotate}, ${6:xform})",
			"scope": "source.vex",
			"description": "Depending on the value of c, returns the translate (c=0), rotate\n(c=1), scale (c=2), or shears (c=3)  component of the transform (xform)."
	},
	"cracktransform: trs xyz c pivot xform": {
			"prefix": "cracktransform(trs, xyz, c, pivot, xform)",
			"body": "cracktransform(${1:trs}, ${2:xyz}, ${3:c}, ${4:pivot}, ${5:xform})",
			"scope": "source.vex",
			"description": "Depending on the value of c, returns the translate (c=0), rotate\n(c=1), scale (c=2), or shears (c=3)  component of the transform (xform)."
	},
	"cracktransform: trs xyz pivot pivot_rotate xform t r s shears": {
			"prefix": "cracktransform(trs, xyz, pivot, pivot_rotate, xform, t, r, s, shears)",
			"body": "cracktransform(${1:trs}, ${2:xyz}, ${3:pivot}, ${4:pivot_rotate}, ${5:xform}, ${6:t}, ${7:r}, ${8:s}, ${9:shears})",
			"scope": "source.vex",
			"description": "Depending on the value of c, returns the translate (c=0), rotate\n(c=1), scale (c=2), or shears (c=3)  component of the transform (xform)."
	},
	"cracktransform: trs xyz pivot xform t r s": {
			"prefix": "cracktransform(trs, xyz, pivot, xform, t, r, s)",
			"body": "cracktransform(${1:trs}, ${2:xyz}, ${3:pivot}, ${4:xform}, ${5:t}, ${6:r}, ${7:s})",
			"scope": "source.vex",
			"description": "Depending on the value of c, returns the translate (c=0), rotate\n(c=1), scale (c=2), or shears (c=3)  component of the transform (xform)."
	},
	"qdistance: q1 q2": {
			"prefix": "qdistance(q1, q2)",
			"body": "qdistance(${1:q1}, ${2:q2})",
			"scope": "source.vex",
			"description": "Finds distance between two quaternions."
	},
	"pcsegment_radius: geometry PChannel RadChannel radscale P0 P1 max_distance maxpoints": {
			"prefix": "pcsegment_radius(geometry, PChannel, RadChannel, radscale, P0, P1, max_distance, maxpoints)",
			"body": "pcsegment_radius(${1:geometry}, ${2:PChannel}, ${3:RadChannel}, ${4:radscale}, ${5:P0}, ${6:P1}, ${7:max_distance}, ${8:maxpoints})",
			"scope": "source.vex",
			"description": "Returns a list of closest points to a line segment from a specified file"
	},
	"pcsegment_radius: geometry ptgroup PChannel RadChannel radscale P0 P1 max_distance maxpoints": {
			"prefix": "pcsegment_radius(geometry, ptgroup, PChannel, RadChannel, radscale, P0, P1, max_distance, maxpoints)",
			"body": "pcsegment_radius(${1:geometry}, ${2:ptgroup}, ${3:PChannel}, ${4:RadChannel}, ${5:radscale}, ${6:P0}, ${7:P1}, ${8:max_distance}, ${9:maxpoints})",
			"scope": "source.vex",
			"description": "Returns a list of closest points to a line segment from a specified file"
	},
	"pcsegment_radius: geometry PChannel RadChannel radscale P0 P1 max_distance maxpoints distances": {
			"prefix": "pcsegment_radius(geometry, PChannel, RadChannel, radscale, P0, P1, max_distance, maxpoints, distances)",
			"body": "pcsegment_radius(${1:geometry}, ${2:PChannel}, ${3:RadChannel}, ${4:radscale}, ${5:P0}, ${6:P1}, ${7:max_distance}, ${8:maxpoints}, ${9:distances})",
			"scope": "source.vex",
			"description": "Returns a list of closest points to a line segment from a specified file"
	},
	"pcsegment_radius: geometry ptgroup PChannel RadChannel radscale P0 P1 max_distance maxpoints distances": {
			"prefix": "pcsegment_radius(geometry, ptgroup, PChannel, RadChannel, radscale, P0, P1, max_distance, maxpoints, distances)",
			"body": "pcsegment_radius(${1:geometry}, ${2:ptgroup}, ${3:PChannel}, ${4:RadChannel}, ${5:radscale}, ${6:P0}, ${7:P1}, ${8:max_distance}, ${9:maxpoints}, ${10:distances})",
			"scope": "source.vex",
			"description": "Returns a list of closest points to a line segment from a specified file"
	},
	"qconvert: quaternion": {
			"prefix": "qconvert(quaternion)",
			"body": "qconvert(${1:quaternion})",
			"scope": "source.vex",
			"description": "Converts a quaternion represented by a vector4 to a matrix3 representation."
	},
	"qconvert: quaternion offset": {
			"prefix": "qconvert(quaternion, offset)",
			"body": "qconvert(${1:quaternion}, ${2:offset})",
			"scope": "source.vex",
			"description": "Converts a quaternion represented by a vector4 to a matrix3 representation."
	},
	"usd_metadatalen: stage path name": {
			"prefix": "usd_metadatalen(stage, path, name)",
			"body": "usd_metadatalen(${1:stage}, ${2:path}, ${3:name})",
			"scope": "source.vex",
			"description": "Returns the length of the array metadata."
	},
	"chattrnames: opinput attribclass": {
			"prefix": "chattrnames(opinput, attribclass)",
			"body": "chattrnames(${1:opinput}, ${2:attribclass})",
			"scope": "source.vex",
			"description": "Reads CHOP attribute names of a given attribute class from a CHOP input."
	},
	"chattrnames: attrclass": {
			"prefix": "chattrnames(attrclass)",
			"body": "chattrnames(${1:attrclass})",
			"scope": "source.vex",
			"description": "Reads CHOP attribute names of a given attribute class from a CHOP input."
	},
	"sign: n": {
			"prefix": "sign(n)",
			"body": "sign(${1:n})",
			"scope": "source.vex",
			"description": "Returns -1, 0, or 1 depending on the sign of the argument."
	},
	"sign: v": {
			"prefix": "sign(v)",
			"body": "sign(${1:v})",
			"scope": "source.vex",
			"description": "Returns -1, 0, or 1 depending on the sign of the argument."
	},
	"matchvex_specular: exponent ...": {
			"prefix": "matchvex_specular(exponent, ...)",
			"body": "matchvex_specular(${1:exponent}, ${2:...})",
			"scope": "source.vex",
			"description": "Returns a BSDF that matches the output of the traditional VEX specular function."
	},
	"matchvex_specular: nml exponent ...": {
			"prefix": "matchvex_specular(nml, exponent, ...)",
			"body": "matchvex_specular(${1:nml}, ${2:exponent}, ${3:...})",
			"scope": "source.vex",
			"description": "Returns a BSDF that matches the output of the traditional VEX specular function."
	},
	"usd_setkind: stagehandle primpath kind": {
			"prefix": "usd_setkind(stagehandle, primpath, kind)",
			"body": "usd_setkind(${1:stagehandle}, ${2:primpath}, ${3:kind})",
			"scope": "source.vex",
			"description": "Sets the primitive\u2019s kind."
	},
	"chwritebuf: index value": {
			"prefix": "chwritebuf(index, value)",
			"body": "chwritebuf(${1:index}, ${2:value})",
			"scope": "source.vex",
			"description": "Writes a value of CHOP context temporary buffer at the specified index."
	},
	"chwritebuf: index t r s": {
			"prefix": "chwritebuf(index, t, r, s)",
			"body": "chwritebuf(${1:index}, ${2:t}, ${3:r}, ${4:s})",
			"scope": "source.vex",
			"description": "Writes a value of CHOP context temporary buffer at the specified index."
	},
	"osd_limitsurface: geometry attrib_name patch_id u v result": {
			"prefix": "osd_limitsurface(geometry, attrib_name, patch_id, u, v, result)",
			"body": "osd_limitsurface(${1:geometry}, ${2:attrib_name}, ${3:patch_id}, ${4:u}, ${5:v}, ${6:result})",
			"scope": "source.vex",
			"description": "Evaluates a point attribute at the subdivision limit surface using Open Subdiv."
	},
	"usd_setrelationshiptargets: stagehandle primpath name targets": {
			"prefix": "usd_setrelationshiptargets(stagehandle, primpath, name, targets)",
			"body": "usd_setrelationshiptargets(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:targets})",
			"scope": "source.vex",
			"description": "Sets the targets in the primitive\u2019s relationship"
	},
	"getglobalraylevel: ": {
			"prefix": "getglobalraylevel()",
			"body": "getglobalraylevel()",
			"scope": "source.vex",
			"description": "Returns the depth of the ray tree for computing global\nillumination."
	},
	"setcurrentlight: lightid": {
			"prefix": "setcurrentlight(lightid)",
			"body": "setcurrentlight(${1:lightid})",
			"scope": "source.vex",
			"description": "Sets the current light"
	},
	"surfacedist: geometry ptgroup P_attribute search_pt closest_pt distance_metric": {
			"prefix": "surfacedist(geometry, ptgroup, P_attribute, search_pt, closest_pt, distance_metric)",
			"body": "surfacedist(${1:geometry}, ${2:ptgroup}, ${3:P_attribute}, ${4:search_pt}, ${5:closest_pt}, ${6:distance_metric})",
			"scope": "source.vex",
			"description": "Finds the distance of a point to a group of points along the surface of a geometry."
	},
	"surfacedist: geometry ptgroup P_attribute search_pt max_radius closest_pt distance_metric": {
			"prefix": "surfacedist(geometry, ptgroup, P_attribute, search_pt, max_radius, closest_pt, distance_metric)",
			"body": "surfacedist(${1:geometry}, ${2:ptgroup}, ${3:P_attribute}, ${4:search_pt}, ${5:max_radius}, ${6:closest_pt}, ${7:distance_metric})",
			"scope": "source.vex",
			"description": "Finds the distance of a point to a group of points along the surface of a geometry."
	},
	"cregiondeformtransform: path": {
			"prefix": "cregiondeformtransform(path)",
			"body": "cregiondeformtransform(${1:path})",
			"scope": "source.vex",
			"description": "Returns the deform transform associated with a Capture Region SOP."
	},
	"cregiondeformtransform: path time": {
			"prefix": "cregiondeformtransform(path, time)",
			"body": "cregiondeformtransform(${1:path}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the deform transform associated with a Capture Region SOP."
	},
	"cregiondeformtransform: op_id": {
			"prefix": "cregiondeformtransform(op_id)",
			"body": "cregiondeformtransform(${1:op_id})",
			"scope": "source.vex",
			"description": "Returns the deform transform associated with a Capture Region SOP."
	},
	"cregiondeformtransform: op_id time": {
			"prefix": "cregiondeformtransform(op_id, time)",
			"body": "cregiondeformtransform(${1:op_id}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the deform transform associated with a Capture Region SOP."
	},
	"lightid: lp": {
			"prefix": "lightid(lp)",
			"body": "lightid(${1:lp})",
			"scope": "source.vex",
			"description": "Returns the light id for a light struct."
	},
	"usd_name: stage primpath": {
			"prefix": "usd_name(stage, primpath)",
			"body": "usd_name(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Returns the name of the primitive."
	},
	"metamarch: index filename p0 p1 displace_bound": {
			"prefix": "metamarch(index, filename, p0, p1, displace_bound)",
			"body": "metamarch(${1:index}, ${2:filename}, ${3:p0}, ${4:p1}, ${5:displace_bound})",
			"scope": "source.vex",
			"description": "Takes the ray defined by p0 and p1 and partitions it into zero or\nmore sub-intervals where each interval intersects a cluster of metaballs\nfrom filename."
	},
	"expand_udim: u v path ...": {
			"prefix": "expand_udim(u, v, path, ...)",
			"body": "expand_udim(${1:u}, ${2:v}, ${3:path}, ${4:...})",
			"scope": "source.vex",
			"description": "Perform UDIM or UVTILE texture filename expansion."
	},
	"pcfind: geometry Pchannel P radius maxpoints": {
			"prefix": "pcfind(geometry, Pchannel, P, radius, maxpoints)",
			"body": "pcfind(${1:geometry}, ${2:Pchannel}, ${3:P}, ${4:radius}, ${5:maxpoints})",
			"scope": "source.vex",
			"description": "Returns a list of closest points from a file."
	},
	"pcfind: geometry ptgroup Pchannel P radius maxpoints": {
			"prefix": "pcfind(geometry, ptgroup, Pchannel, P, radius, maxpoints)",
			"body": "pcfind(${1:geometry}, ${2:ptgroup}, ${3:Pchannel}, ${4:P}, ${5:radius}, ${6:maxpoints})",
			"scope": "source.vex",
			"description": "Returns a list of closest points from a file."
	},
	"pcfind: geometry Pchannel P radius maxpoints distances": {
			"prefix": "pcfind(geometry, Pchannel, P, radius, maxpoints, distances)",
			"body": "pcfind(${1:geometry}, ${2:Pchannel}, ${3:P}, ${4:radius}, ${5:maxpoints}, ${6:distances})",
			"scope": "source.vex",
			"description": "Returns a list of closest points from a file."
	},
	"pcfind: geometry ptgroup Pchannel P radius maxpoints distances": {
			"prefix": "pcfind(geometry, ptgroup, Pchannel, P, radius, maxpoints, distances)",
			"body": "pcfind(${1:geometry}, ${2:ptgroup}, ${3:Pchannel}, ${4:P}, ${5:radius}, ${6:maxpoints}, ${7:distances})",
			"scope": "source.vex",
			"description": "Returns a list of closest points from a file."
	},
	"titlecase: str": {
			"prefix": "titlecase(str)",
			"body": "titlecase(${1:str})",
			"scope": "source.vex",
			"description": "Returns a string that is the titlecase version of the input string."
	},
	"ow_space: ": {
			"prefix": "ow_space()",
			"body": "ow_space()",
			"scope": "source.vex",
			"description": "Transforms a position value from Object to World space."
	},
	"ow_space: v": {
			"prefix": "ow_space(v)",
			"body": "ow_space(${1:v})",
			"scope": "source.vex",
			"description": "Transforms a position value from Object to World space."
	},
	"oppretransform: path": {
			"prefix": "oppretransform(path)",
			"body": "oppretransform(${1:path})",
			"scope": "source.vex",
			"description": "Returns the pretransform associated with an OP."
	},
	"oppretransform: path time": {
			"prefix": "oppretransform(path, time)",
			"body": "oppretransform(${1:path}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the pretransform associated with an OP."
	},
	"oppretransform: opid": {
			"prefix": "oppretransform(opid)",
			"body": "oppretransform(${1:opid})",
			"scope": "source.vex",
			"description": "Returns the pretransform associated with an OP."
	},
	"oppretransform: opid time": {
			"prefix": "oppretransform(opid, time)",
			"body": "oppretransform(${1:opid}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the pretransform associated with an OP."
	},
	"haspointattrib: geometry attribute_name": {
			"prefix": "haspointattrib(geometry, attribute_name)",
			"body": "haspointattrib(${1:geometry}, ${2:attribute_name})",
			"scope": "source.vex",
			"description": "Returns if a geometry point attribute exists."
	},
	"relpointbbox: geometry position": {
			"prefix": "relpointbbox(geometry, position)",
			"body": "relpointbbox(${1:geometry}, ${2:position})",
			"scope": "source.vex",
			"description": "Returns the relative position of the point given with respect to the bounding box of the geometry."
	},
	"relpointbbox: geometry pointgroup position": {
			"prefix": "relpointbbox(geometry, pointgroup, position)",
			"body": "relpointbbox(${1:geometry}, ${2:pointgroup}, ${3:position})",
			"scope": "source.vex",
			"description": "Returns the relative position of the point given with respect to the bounding box of the geometry."
	},
	"point: geometry attribute_name pointnumber": {
			"prefix": "point(geometry, attribute_name, pointnumber)",
			"body": "point(${1:geometry}, ${2:attribute_name}, ${3:pointnumber})",
			"scope": "source.vex",
			"description": "Reads a point attribute value from a geometry."
	},
	"agentclipnames: geometry prim": {
			"prefix": "agentclipnames(geometry, prim)",
			"body": "agentclipnames(${1:geometry}, ${2:prim})",
			"scope": "source.vex",
			"description": "Returns an agent primitive\u2019s current animation clips."
	},
	"idtopoint: geometry id": {
			"prefix": "idtopoint(geometry, id)",
			"body": "idtopoint(${1:geometry}, ${2:id})",
			"scope": "source.vex",
			"description": "Finds a point by its id attribute."
	},
	"avg: a": {
			"prefix": "avg(a)",
			"body": "avg(${1:a})",
			"scope": "source.vex",
			"description": "Returns the average value of the input(s)"
	},
	"avg: a b ...": {
			"prefix": "avg(a, b, ...)",
			"body": "avg(${1:a}, ${2:b}, ${3:...})",
			"scope": "source.vex",
			"description": "Returns the average value of the input(s)"
	},
	"avg: v": {
			"prefix": "avg(v)",
			"body": "avg(${1:v})",
			"scope": "source.vex",
			"description": "Returns the average value of the input(s)"
	},
	"avg: arr": {
			"prefix": "avg(arr)",
			"body": "avg(${1:arr})",
			"scope": "source.vex",
			"description": "Returns the average value of the input(s)"
	},
	"agentrigchildren: geometry prim transform": {
			"prefix": "agentrigchildren(geometry, prim, transform)",
			"body": "agentrigchildren(${1:geometry}, ${2:prim}, ${3:transform})",
			"scope": "source.vex",
			"description": "Returns the child transforms of a transform in an agent primitive\u2019s rig."
	},
	"clamp: value min max": {
			"prefix": "clamp(value, min, max)",
			"body": "clamp(${1:value}, ${2:min}, ${3:max})",
			"scope": "source.vex",
			"description": "Returns value clamped between min and max."
	},
	"isbound: variable_name": {
			"prefix": "isbound(variable_name)",
			"body": "isbound(${1:variable_name})",
			"scope": "source.vex",
			"description": "Parameters in VEX can be overridden by geometry attributes (if the attributes exist on the surface being rendered)."
	},
	"setdetailattrib: geohandle name value mode": {
			"prefix": "setdetailattrib(geohandle, name, value, mode)",
			"body": "setdetailattrib(${1:geohandle}, ${2:name}, ${3:value}, ${4:mode})",
			"scope": "source.vex",
			"description": "Sets a detail attribute in a geometry."
	},
	"detailattribtypeinfo: geometry attribute_name": {
			"prefix": "detailattribtypeinfo(geometry, attribute_name)",
			"body": "detailattribtypeinfo(${1:geometry}, ${2:attribute_name})",
			"scope": "source.vex",
			"description": "Returns the type info of a geometry attribute."
	},
	"blackbody: temperature luminance": {
			"prefix": "blackbody(temperature, luminance)",
			"body": "blackbody(${1:temperature}, ${2:luminance})",
			"scope": "source.vex",
			"description": "Compute the color value of an incandescent black body."
	},
	"normalname: ": {
			"prefix": "normalname()",
			"body": "normalname()",
			"scope": "source.vex",
			"description": "Returns the default name of the normal plane (as it appears in the\ncompositor preferences)."
	},
	"fit: value omin omax nmin nmax": {
			"prefix": "fit(value, omin, omax, nmin, nmax)",
			"body": "fit(${1:value}, ${2:omin}, ${3:omax}, ${4:nmin}, ${5:nmax})",
			"scope": "source.vex",
			"description": "Takes the value in one range and shifts it to the corresponding value in a new range."
	},
	"vertexprim: geometry linearvertex": {
			"prefix": "vertexprim(geometry, linearvertex)",
			"body": "vertexprim(${1:geometry}, ${2:linearvertex})",
			"scope": "source.vex",
			"description": "Returns the number of the primitive containing a given vertex."
	},
	"curlnoise2d: x y": {
			"prefix": "curlnoise2d(x, y)",
			"body": "curlnoise2d(${1:x}, ${2:y})",
			"scope": "source.vex",
			"description": "Computes 2d divergence free noise based on Perlin noise."
	},
	"curlnoise2d: xyt": {
			"prefix": "curlnoise2d(xyt)",
			"body": "curlnoise2d(${1:xyt})",
			"scope": "source.vex",
			"description": "Computes 2d divergence free noise based on Perlin noise."
	},
	"getlocalcurvature: s t": {
			"prefix": "getlocalcurvature(s, t)",
			"body": "getlocalcurvature(${1:s}, ${2:t})",
			"scope": "source.vex",
			"description": "Evaluates local curvature of primitive grid, using the same curvature evaluation method as Measure SOPs."
	},
	"usd_parentpath: stage primpath": {
			"prefix": "usd_parentpath(stage, primpath)",
			"body": "usd_parentpath(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Returns the path of the primitive\u2019s parent."
	},
	"pcline_radius: geometry PChannel RadChannel radscale P dir max_distance maxpoints": {
			"prefix": "pcline_radius(geometry, PChannel, RadChannel, radscale, P, dir, max_distance, maxpoints)",
			"body": "pcline_radius(${1:geometry}, ${2:PChannel}, ${3:RadChannel}, ${4:radscale}, ${5:P}, ${6:dir}, ${7:max_distance}, ${8:maxpoints})",
			"scope": "source.vex",
			"description": "Returns a list of closest points to an infinite line from a specified file"
	},
	"pcline_radius: geometry ptgroup PChannel RadChannel radscale P dir max_distance maxpoints": {
			"prefix": "pcline_radius(geometry, ptgroup, PChannel, RadChannel, radscale, P, dir, max_distance, maxpoints)",
			"body": "pcline_radius(${1:geometry}, ${2:ptgroup}, ${3:PChannel}, ${4:RadChannel}, ${5:radscale}, ${6:P}, ${7:dir}, ${8:max_distance}, ${9:maxpoints})",
			"scope": "source.vex",
			"description": "Returns a list of closest points to an infinite line from a specified file"
	},
	"solveik: lengths targetpos twistpos twist twistflag dampen resiststraight trackingthres relmat constraints": {
			"prefix": "solveik(lengths, targetpos, twistpos, twist, twistflag, dampen, resiststraight, trackingthres, relmat, constraints)",
			"body": "solveik(${1:lengths}, ${2:targetpos}, ${3:twistpos}, ${4:twist}, ${5:twistflag}, ${6:dampen}, ${7:resiststraight}, ${8:trackingthres}, ${9:relmat}, ${10:constraints})",
			"scope": "source.vex",
			"description": "Applies an inverse kinematics algorithm to a skeleton."
	},
	"addvariablename: aname vname": {
			"prefix": "addvariablename(aname, vname)",
			"body": "addvariablename(${1:aname}, ${2:vname})",
			"scope": "source.vex",
			"description": "Adds a mapping for an attribute to a local variable."
	},
	"addvariablename: geohandle aname vname": {
			"prefix": "addvariablename(geohandle, aname, vname)",
			"body": "addvariablename(${1:geohandle}, ${2:aname}, ${3:vname})",
			"scope": "source.vex",
			"description": "Adds a mapping for an attribute to a local variable."
	},
	"primpoints: geometry primnum": {
			"prefix": "primpoints(geometry, primnum)",
			"body": "primpoints(${1:geometry}, ${2:primnum})",
			"scope": "source.vex",
			"description": "Returns the list of points on a primitive."
	},
	"chindex: opinput name": {
			"prefix": "chindex(opinput, name)",
			"body": "chindex(${1:opinput}, ${2:name})",
			"scope": "source.vex",
			"description": "Returns the channel index from a input given a channel name."
	},
	"chindex: name": {
			"prefix": "chindex(name)",
			"body": "chindex(${1:name})",
			"scope": "source.vex",
			"description": "Returns the channel index from a input given a channel name."
	},
	"chindex: names": {
			"prefix": "chindex(names)",
			"body": "chindex(${1:names})",
			"scope": "source.vex",
			"description": "Returns the channel index from a input given a channel name."
	},
	"nametoprim: geometry name": {
			"prefix": "nametoprim(geometry, name)",
			"body": "nametoprim(${1:geometry}, ${2:name})",
			"scope": "source.vex",
			"description": "Finds a primitive by its name attribute."
	},
	"quaterniontoeuler: orient order": {
			"prefix": "quaterniontoeuler(orient, order)",
			"body": "quaterniontoeuler(${1:orient}, ${2:order})",
			"scope": "source.vex",
			"description": "Creates a euler angle representing a quaternion."
	},
	"osd_facecount: geometry": {
			"prefix": "osd_facecount(geometry)",
			"body": "osd_facecount(${1:geometry})",
			"scope": "source.vex",
			"description": ""
	},
	"getlightscope: mat scope categories": {
			"prefix": "getlightscope(mat, scope, categories)",
			"body": "getlightscope(${1:mat}, ${2:scope}, ${3:categories})",
			"scope": "source.vex",
			"description": "Returns a selection of lights that illuminate a given material."
	},
	"hedge_dstpoint: geometry hedge": {
			"prefix": "hedge_dstpoint(geometry, hedge)",
			"body": "hedge_dstpoint(${1:geometry}, ${2:hedge})",
			"scope": "source.vex",
			"description": "Returns the destination point of a half-edge."
	},
	"isfogray: ": {
			"prefix": "isfogray()",
			"body": "isfogray()",
			"scope": "source.vex",
			"description": "Returns 1 if the shader is being called to evaluate illumination for\nfog objects, or 0 if the light or shadow shader is being called to\nevaluate surface illumination."
	},
	"setedgegroup: geohandle name pt0 pt1 value": {
			"prefix": "setedgegroup(geohandle, name, pt0, pt1, value)",
			"body": "setedgegroup(${1:geohandle}, ${2:name}, ${3:pt0}, ${4:pt1}, ${5:value})",
			"scope": "source.vex",
			"description": "Sets edge group membership in a geometry."
	},
	"warning: format ...": {
			"prefix": "warning(format, ...)",
			"body": "warning(${1:format}, ${2:...})",
			"scope": "source.vex",
			"description": "Reports a custom runtime VEX warning."
	},
	"metanext: handle": {
			"prefix": "metanext(handle)",
			"body": "metanext(${1:handle})",
			"scope": "source.vex",
			"description": "Iterate to the next metaball in the list of metaballs returned by the metastart() function."
	},
	"ihasplane: opinput planename": {
			"prefix": "ihasplane(opinput, planename)",
			"body": "ihasplane(${1:opinput}, ${2:planename})",
			"scope": "source.vex",
			"description": "Returns 1 if the specified input has a plane named planename."
	},
	"itoa: number": {
			"prefix": "itoa(number)",
			"body": "itoa(${1:number})",
			"scope": "source.vex",
			"description": "Converts an integer to a string."
	},
	"opid: op_path": {
			"prefix": "opid(op_path)",
			"body": "opid(${1:op_path})",
			"scope": "source.vex",
			"description": "Resolves an operator path string and return its op_id."
	},
	"opid: op_id": {
			"prefix": "opid(op_id)",
			"body": "opid(${1:op_id})",
			"scope": "source.vex",
			"description": "Resolves an operator path string and return its op_id."
	},
	"ggx: ng nn xg yg F0 F90 alphax alphay masking fresblend eta reflect refract reflectmask refractmask dispersion ...": {
			"prefix": "ggx(ng, nn, xg, yg, F0, F90, alphax, alphay, masking, fresblend, eta, reflect, refract, reflectmask, refractmask, dispersion, ...)",
			"body": "ggx(${1:ng}, ${2:nn}, ${3:xg}, ${4:yg}, ${5:F0}, ${6:F90}, ${7:alphax}, ${8:alphay}, ${9:masking}, ${10:fresblend}, ${11:eta}, ${12:reflect}, ${13:refract}, ${14:reflectmask}, ${15:refractmask}, ${16:dispersion}, ${17:...})",
			"scope": "source.vex",
			"description": "Returns a ggx BSDF."
	},
	"agentchannelvalues: geometry prim": {
			"prefix": "agentchannelvalues(geometry, prim)",
			"body": "agentchannelvalues(${1:geometry}, ${2:prim})",
			"scope": "source.vex",
			"description": "Returns the current values of an agent primitive\u2019s channels."
	},
	"gradient: val ...": {
			"prefix": "gradient(val, ...)",
			"body": "gradient(${1:val}, ${2:...})",
			"scope": "source.vex",
			"description": "Returns the gradient of a field."
	},
	"gradient: P val ...": {
			"prefix": "gradient(P, val, ...)",
			"body": "gradient(${1:P}, ${2:val}, ${3:...})",
			"scope": "source.vex",
			"description": "Returns the gradient of a field."
	},
	"usd_metadatanames: stage path": {
			"prefix": "usd_metadatanames(stage, path)",
			"body": "usd_metadatanames(${1:stage}, ${2:path})",
			"scope": "source.vex",
			"description": "Returns the names of the metadata available on the object."
	},
	"degrees: num_in_rads": {
			"prefix": "degrees(num_in_rads)",
			"body": "degrees(${1:num_in_rads})",
			"scope": "source.vex",
			"description": "Converts the argument from radians into degrees."
	},
	"degrees: nums_in_rads": {
			"prefix": "degrees(nums_in_rads)",
			"body": "degrees(${1:nums_in_rads})",
			"scope": "source.vex",
			"description": "Converts the argument from radians into degrees."
	},
	"vertexattribsize: geometry attribute_name": {
			"prefix": "vertexattribsize(geometry, attribute_name)",
			"body": "vertexattribsize(${1:geometry}, ${2:attribute_name})",
			"scope": "source.vex",
			"description": "Returns the size of a geometry vertex attribute."
	},
	"usd_localtransform: stage primpath": {
			"prefix": "usd_localtransform(stage, primpath)",
			"body": "usd_localtransform(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Obtains the primitive\u2019s local transform"
	},
	"usd_localtransform: stage primpath timecode": {
			"prefix": "usd_localtransform(stage, primpath, timecode)",
			"body": "usd_localtransform(${1:stage}, ${2:primpath}, ${3:timecode})",
			"scope": "source.vex",
			"description": "Obtains the primitive\u2019s local transform"
	},
	"expandpointgroup: geometry groupname": {
			"prefix": "expandpointgroup(geometry, groupname)",
			"body": "expandpointgroup(${1:geometry}, ${2:groupname})",
			"scope": "source.vex",
			"description": "Returns an array of point numbers corresponding to a group string."
	},
	"iplanesize: opinput planeindex": {
			"prefix": "iplanesize(opinput, planeindex)",
			"body": "iplanesize(${1:opinput}, ${2:planeindex})",
			"scope": "source.vex",
			"description": "Returns the number of components in the plane named planename in\nthe specified input."
	},
	"uvunwrap: object_path u v time P I": {
			"prefix": "uvunwrap(object_path, u, v, time, P, I)",
			"body": "uvunwrap(${1:object_path}, ${2:u}, ${3:v}, ${4:time}, ${5:P}, ${6:I})",
			"scope": "source.vex",
			"description": "Computes the position and normal at given (u, v) coordinates."
	},
	"uvunwrap: object_path u v time P I mikkelsenUtan mikkelsenVtan": {
			"prefix": "uvunwrap(object_path, u, v, time, P, I, mikkelsenUtan, mikkelsenVtan)",
			"body": "uvunwrap(${1:object_path}, ${2:u}, ${3:v}, ${4:time}, ${5:P}, ${6:I}, ${7:mikkelsenUtan}, ${8:mikkelsenVtan})",
			"scope": "source.vex",
			"description": "Computes the position and normal at given (u, v) coordinates."
	},
	"lightbounces: lp": {
			"prefix": "lightbounces(lp)",
			"body": "lightbounces(${1:lp})",
			"scope": "source.vex",
			"description": "Returns the bounce mask for a light struct."
	},
	"usd_attriblen: stage primpath name": {
			"prefix": "usd_attriblen(stage, primpath, name)",
			"body": "usd_attriblen(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Returns the length of the array attribute."
	},
	"usd_attriblen: stage primpath name timecode": {
			"prefix": "usd_attriblen(stage, primpath, name, timecode)",
			"body": "usd_attriblen(${1:stage}, ${2:primpath}, ${3:name}, ${4:timecode})",
			"scope": "source.vex",
			"description": "Returns the length of the array attribute."
	},
	"diagonalizesymmetric: symmat diag": {
			"prefix": "diagonalizesymmetric(symmat, diag)",
			"body": "diagonalizesymmetric(${1:symmat}, ${2:diag})",
			"scope": "source.vex",
			"description": "Diagonalizes Symmetric Matrices."
	},
	"volumesamplev: geometry primnum pos": {
			"prefix": "volumesamplev(geometry, primnum, pos)",
			"body": "volumesamplev(${1:geometry}, ${2:primnum}, ${3:pos})",
			"scope": "source.vex",
			"description": "Samples the volume primitive\u2019s vector value."
	},
	"volumesamplev: geometry volumename pos": {
			"prefix": "volumesamplev(geometry, volumename, pos)",
			"body": "volumesamplev(${1:geometry}, ${2:volumename}, ${3:pos})",
			"scope": "source.vex",
			"description": "Samples the volume primitive\u2019s vector value."
	},
	"sample_direction_cone: center maxangle u": {
			"prefix": "sample_direction_cone(center, maxangle, u)",
			"body": "sample_direction_cone(${1:center}, ${2:maxangle}, ${3:u})",
			"scope": "source.vex",
			"description": "Generates a uniform unit vector, within maxangle of center, given a vector2 of uniform numbers between 0 and 1."
	},
	"chsraw: channel": {
			"prefix": "chsraw(channel)",
			"body": "chsraw(${1:channel})",
			"scope": "source.vex",
			"description": "Returns the raw string channel (or parameter)."
	},
	"xyzdist: geometry origin": {
			"prefix": "xyzdist(geometry, origin)",
			"body": "xyzdist(${1:geometry}, ${2:origin})",
			"scope": "source.vex",
			"description": "Finds the distance of a point to a geometry."
	},
	"xyzdist: geometry origin prim uv": {
			"prefix": "xyzdist(geometry, origin, prim, uv)",
			"body": "xyzdist(${1:geometry}, ${2:origin}, ${3:prim}, ${4:uv})",
			"scope": "source.vex",
			"description": "Finds the distance of a point to a geometry."
	},
	"xyzdist: geometry origin prim uv maxdist": {
			"prefix": "xyzdist(geometry, origin, prim, uv, maxdist)",
			"body": "xyzdist(${1:geometry}, ${2:origin}, ${3:prim}, ${4:uv}, ${5:maxdist})",
			"scope": "source.vex",
			"description": "Finds the distance of a point to a geometry."
	},
	"xyzdist: geometry primgroup origin": {
			"prefix": "xyzdist(geometry, primgroup, origin)",
			"body": "xyzdist(${1:geometry}, ${2:primgroup}, ${3:origin})",
			"scope": "source.vex",
			"description": "Finds the distance of a point to a geometry."
	},
	"xyzdist: geometry primgroup origin prim uv": {
			"prefix": "xyzdist(geometry, primgroup, origin, prim, uv)",
			"body": "xyzdist(${1:geometry}, ${2:primgroup}, ${3:origin}, ${4:prim}, ${5:uv})",
			"scope": "source.vex",
			"description": "Finds the distance of a point to a geometry."
	},
	"xyzdist: geometry primgroup origin prim uv maxdist": {
			"prefix": "xyzdist(geometry, primgroup, origin, prim, uv, maxdist)",
			"body": "xyzdist(${1:geometry}, ${2:primgroup}, ${3:origin}, ${4:prim}, ${5:uv}, ${6:maxdist})",
			"scope": "source.vex",
			"description": "Finds the distance of a point to a geometry."
	},
	"usd_uniquetransformname: stage primpath transformtype suffix": {
			"prefix": "usd_uniquetransformname(stage, primpath, transformtype, suffix)",
			"body": "usd_uniquetransformname(${1:stage}, ${2:primpath}, ${3:transformtype}, ${4:suffix})",
			"scope": "source.vex",
			"description": "Constructs a unique full name of a transform operation"
	},
	"chnames: ": {
			"prefix": "chnames()",
			"body": "chnames()",
			"scope": "source.vex",
			"description": "Returns all the CHOP channel names of a given CHOP input."
	},
	"chnames: opinput": {
			"prefix": "chnames(opinput)",
			"body": "chnames(${1:opinput})",
			"scope": "source.vex",
			"description": "Returns all the CHOP channel names of a given CHOP input."
	},
	"chs: channel": {
			"prefix": "chs(channel)",
			"body": "chs(${1:channel})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"chs: channel time": {
			"prefix": "chs(channel, time)",
			"body": "chs(${1:channel}, ${2:time})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"ch2: channel": {
			"prefix": "ch2(channel)",
			"body": "ch2(${1:channel})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"ch2: channel time": {
			"prefix": "ch2(channel, time)",
			"body": "ch2(${1:channel}, ${2:time})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"ch3: channel": {
			"prefix": "ch3(channel)",
			"body": "ch3(${1:channel})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"ch3: channel time": {
			"prefix": "ch3(channel, time)",
			"body": "ch3(${1:channel}, ${2:time})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"chr: value": {
			"prefix": "chr(value)",
			"body": "chr(${1:value})",
			"scope": "source.vex",
			"description": "Converts an unicode codepoint to a UTF8 string."
	},
	"min: value1 value2 ...": {
			"prefix": "min(value1, value2, ...)",
			"body": "min(${1:value1}, ${2:value2}, ${3:...})",
			"scope": "source.vex",
			"description": ""
	},
	"min: values": {
			"prefix": "min(values)",
			"body": "min(${1:values})",
			"scope": "source.vex",
			"description": ""
	},
	"min: v": {
			"prefix": "min(v)",
			"body": "min(${1:v})",
			"scope": "source.vex",
			"description": ""
	},
	"min: value": {
			"prefix": "min(value)",
			"body": "min(${1:value})",
			"scope": "source.vex",
			"description": ""
	},
	"irradiance: P N ...": {
			"prefix": "irradiance(P, N, ...)",
			"body": "irradiance(${1:P}, ${2:N}, ${3:...})",
			"scope": "source.vex",
			"description": "Computes irradiance (global illumination) at the point P with the normal N."
	},
	"opparenttransform: path": {
			"prefix": "opparenttransform(path)",
			"body": "opparenttransform(${1:path})",
			"scope": "source.vex",
			"description": "Returns the parent transform associated with an OP."
	},
	"opparenttransform: path time": {
			"prefix": "opparenttransform(path, time)",
			"body": "opparenttransform(${1:path}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the parent transform associated with an OP."
	},
	"opparenttransform: opid": {
			"prefix": "opparenttransform(opid)",
			"body": "opparenttransform(${1:opid})",
			"scope": "source.vex",
			"description": "Returns the parent transform associated with an OP."
	},
	"opparenttransform: opid time": {
			"prefix": "opparenttransform(opid, time)",
			"body": "opparenttransform(${1:opid}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the parent transform associated with an OP."
	},
	"hasvertexattrib: geometry attribute_name": {
			"prefix": "hasvertexattrib(geometry, attribute_name)",
			"body": "hasvertexattrib(${1:geometry}, ${2:attribute_name})",
			"scope": "source.vex",
			"description": "Returns if a geometry vertex attribute exists."
	},
	"curlnoise: xyz": {
			"prefix": "curlnoise(xyz)",
			"body": "curlnoise(${1:xyz})",
			"scope": "source.vex",
			"description": "Computes divergence free noise based on Perlin noise."
	},
	"curlnoise: xyzt": {
			"prefix": "curlnoise(xyzt)",
			"body": "curlnoise(${1:xyzt})",
			"scope": "source.vex",
			"description": "Computes divergence free noise based on Perlin noise."
	},
	"vertexattribtypeinfo: geometry attribute_name": {
			"prefix": "vertexattribtypeinfo(geometry, attribute_name)",
			"body": "vertexattribtypeinfo(${1:geometry}, ${2:attribute_name})",
			"scope": "source.vex",
			"description": "Returns the type info of a geometry attribute."
	},
	"vertexattribtype: geometry attribute_name": {
			"prefix": "vertexattribtype(geometry, attribute_name)",
			"body": "vertexattribtype(${1:geometry}, ${2:attribute_name})",
			"scope": "source.vex",
			"description": "Returns the type of a geometry vertex attribute."
	},
	"optransform: path": {
			"prefix": "optransform(path)",
			"body": "optransform(${1:path})",
			"scope": "source.vex",
			"description": "Returns the transform associated with an OP."
	},
	"optransform: path time": {
			"prefix": "optransform(path, time)",
			"body": "optransform(${1:path}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the transform associated with an OP."
	},
	"optransform: op_id": {
			"prefix": "optransform(op_id)",
			"body": "optransform(${1:op_id})",
			"scope": "source.vex",
			"description": "Returns the transform associated with an OP."
	},
	"optransform: op_id time": {
			"prefix": "optransform(op_id, time)",
			"body": "optransform(${1:op_id}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the transform associated with an OP."
	},
	"agenttransformtoworld: geometry prim transforms": {
			"prefix": "agenttransformtoworld(geometry, prim, transforms)",
			"body": "agenttransformtoworld(${1:geometry}, ${2:prim}, ${3:transforms})",
			"scope": "source.vex",
			"description": "Converts transforms from local space to world space for an agent primitive."
	},
	"usd_getbbox_max: stage primpath purpose": {
			"prefix": "usd_getbbox_max(stage, primpath, purpose)",
			"body": "usd_getbbox_max(${1:stage}, ${2:primpath}, ${3:purpose})",
			"scope": "source.vex",
			"description": "Returns the maximum of the bounding box for the primitive."
	},
	"usd_makecollectionpath: stage primpath name": {
			"prefix": "usd_makecollectionpath(stage, primpath, name)",
			"body": "usd_makecollectionpath(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Constructs a collection path from a primitive path and a collection name."
	},
	"variance: variable mean sample_size": {
			"prefix": "variance(variable, mean, sample_size)",
			"body": "variance(${1:variable}, ${2:mean}, ${3:sample_size})",
			"scope": "source.vex",
			"description": "Computes the mean value and variance for a value."
	},
	"chremoveattr: attrclass attrname": {
			"prefix": "chremoveattr(attrclass, attrname)",
			"body": "chremoveattr(${1:attrclass}, ${2:attrname})",
			"scope": "source.vex",
			"description": "Removes a CHOP attribute."
	},
	"chremoveattr: attrclass attrnames": {
			"prefix": "chremoveattr(attrclass, attrnames)",
			"body": "chremoveattr(${1:attrclass}, ${2:attrnames})",
			"scope": "source.vex",
			"description": "Removes a CHOP attribute."
	},
	"chremoveattr: attrname": {
			"prefix": "chremoveattr(attrname)",
			"body": "chremoveattr(${1:attrname})",
			"scope": "source.vex",
			"description": "Removes a CHOP attribute."
	},
	"chremoveattr: attrnames": {
			"prefix": "chremoveattr(attrnames)",
			"body": "chremoveattr(${1:attrnames})",
			"scope": "source.vex",
			"description": "Removes a CHOP attribute."
	},
	"chop: filename channel sample": {
			"prefix": "chop(filename, channel, sample)",
			"body": "chop(${1:filename}, ${2:channel}, ${3:sample})",
			"scope": "source.vex",
			"description": "Returns the value of a CHOP channel at the specified sample."
	},
	"sprintf: format ...": {
			"prefix": "sprintf(format, ...)",
			"body": "sprintf(${1:format}, ${2:...})",
			"scope": "source.vex",
			"description": "Formats a string like printf but returns the result as a string\ninstead of printing it."
	},
	"usd_setmetadata: stagehandle path name value": {
			"prefix": "usd_setmetadata(stagehandle, path, name, value)",
			"body": "usd_setmetadata(${1:stagehandle}, ${2:path}, ${3:name}, ${4:value})",
			"scope": "source.vex",
			"description": "Sets the value of an metadata."
	},
	"pretranslate: m amount": {
			"prefix": "pretranslate(m, amount)",
			"body": "pretranslate(${1:m}, ${2:amount})",
			"scope": "source.vex",
			"description": "Pretranslates a matrix by a vector."
	},
	"nvertices: geometry": {
			"prefix": "nvertices(geometry)",
			"body": "nvertices(${1:geometry})",
			"scope": "source.vex",
			"description": "Returns the number of vertices in the input or geometry file."
	},
	"area: p ...": {
			"prefix": "area(p, ...)",
			"body": "area(${1:p}, ${2:...})",
			"scope": "source.vex",
			"description": "Returns the area of the micropolygon containing a variable such as P."
	},
	"usd_relationshipforwardedtargets: stage primpath name": {
			"prefix": "usd_relationshipforwardedtargets(stage, primpath, name)",
			"body": "usd_relationshipforwardedtargets(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Obtains the relationship forwarded targets."
	},
	"bouncemask: labels": {
			"prefix": "bouncemask(labels)",
			"body": "bouncemask(${1:labels})",
			"scope": "source.vex",
			"description": ""
	},
	"scale: m scale_vector": {
			"prefix": "scale(m, scale_vector)",
			"body": "scale(${1:m}, ${2:scale_vector})",
			"scope": "source.vex",
			"description": "Scales the given matrix in three directions simultaneously (X, Y, Z -\ngiven by the components of the scale_vector)."
	},
	"usd_primvarelementsize: stage primpath name": {
			"prefix": "usd_primvarelementsize(stage, primpath, name)",
			"body": "usd_primvarelementsize(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Returns the element size of the primvar."
	},
	"setagentclipnames: geohandle prim clipnames": {
			"prefix": "setagentclipnames(geohandle, prim, clipnames)",
			"body": "setagentclipnames(${1:geohandle}, ${2:prim}, ${3:clipnames})",
			"scope": "source.vex",
			"description": "Sets the current animation clips for an agent primitive."
	},
	"insert: str index value": {
			"prefix": "insert(str, index, value)",
			"body": "insert(${1:str}, ${2:index}, ${3:value})",
			"scope": "source.vex",
			"description": "Inserts an item, array, or string into an array or string."
	},
	"insert: array index value": {
			"prefix": "insert(array, index, value)",
			"body": "insert(${1:array}, ${2:index}, ${3:value})",
			"scope": "source.vex",
			"description": "Inserts an item, array, or string into an array or string."
	},
	"insert: array index values": {
			"prefix": "insert(array, index, values)",
			"body": "insert(${1:array}, ${2:index}, ${3:values})",
			"scope": "source.vex",
			"description": "Inserts an item, array, or string into an array or string."
	},
	"smoothrotation: order r r_reference": {
			"prefix": "smoothrotation(order, r, r_reference)",
			"body": "smoothrotation(${1:order}, ${2:r}, ${3:r_reference})",
			"scope": "source.vex",
			"description": "Returns the closest equivalent Euler rotations to a reference rotation."
	},
	"usd_drawmode: stage primpath": {
			"prefix": "usd_drawmode(stage, primpath)",
			"body": "usd_drawmode(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Returns the primitive\u2019s draw mode."
	},
	"isvalidindex: array index": {
			"prefix": "isvalidindex(array, index)",
			"body": "isvalidindex(${1:array}, ${2:index})",
			"scope": "source.vex",
			"description": "Checks if the index given is valid for the array or string given."
	},
	"isvalidindex: str index": {
			"prefix": "isvalidindex(str, index)",
			"body": "isvalidindex(${1:str}, ${2:index})",
			"scope": "source.vex",
			"description": "Checks if the index given is valid for the array or string given."
	},
	"solvefbik: xforms parents targets targetxforms iters": {
			"prefix": "solvefbik(xforms, parents, targets, targetxforms, iters)",
			"body": "solvefbik(${1:xforms}, ${2:parents}, ${3:targets}, ${4:targetxforms}, ${5:iters})",
			"scope": "source.vex",
			"description": "Applies a full-body inverse kinematics algorithm to a skeleton."
	},
	"solvefbik: xforms parents targets targetxforms iters tolerance pinroot": {
			"prefix": "solvefbik(xforms, parents, targets, targetxforms, iters, tolerance, pinroot)",
			"body": "solvefbik(${1:xforms}, ${2:parents}, ${3:targets}, ${4:targetxforms}, ${5:iters}, ${6:tolerance}, ${7:pinroot})",
			"scope": "source.vex",
			"description": "Applies a full-body inverse kinematics algorithm to a skeleton."
	},
	"solvefbik: xforms parents targets targetxforms iters tolerance pinroot targetweights targetpriorities targetdepths": {
			"prefix": "solvefbik(xforms, parents, targets, targetxforms, iters, tolerance, pinroot, targetweights, targetpriorities, targetdepths)",
			"body": "solvefbik(${1:xforms}, ${2:parents}, ${3:targets}, ${4:targetxforms}, ${5:iters}, ${6:tolerance}, ${7:pinroot}, ${8:targetweights}, ${9:targetpriorities}, ${10:targetdepths})",
			"scope": "source.vex",
			"description": "Applies a full-body inverse kinematics algorithm to a skeleton."
	},
	"solvefbik: xforms parents targets targetxforms iters tolerance pinroot targetweights targetpriorities targetdepths targettypes targetoffsets": {
			"prefix": "solvefbik(xforms, parents, targets, targetxforms, iters, tolerance, pinroot, targetweights, targetpriorities, targetdepths, targettypes, targetoffsets)",
			"body": "solvefbik(${1:xforms}, ${2:parents}, ${3:targets}, ${4:targetxforms}, ${5:iters}, ${6:tolerance}, ${7:pinroot}, ${8:targetweights}, ${9:targetpriorities}, ${10:targetdepths}, ${11:targettypes}, ${12:targetoffsets})",
			"scope": "source.vex",
			"description": "Applies a full-body inverse kinematics algorithm to a skeleton."
	},
	"solvefbik: xforms parents targets targetxforms iters tolerance pinroot targetweights targetpriorities targetdepths goalxforms constrainedxforms jointlimits": {
			"prefix": "solvefbik(xforms, parents, targets, targetxforms, iters, tolerance, pinroot, targetweights, targetpriorities, targetdepths, goalxforms, constrainedxforms, jointlimits)",
			"body": "solvefbik(${1:xforms}, ${2:parents}, ${3:targets}, ${4:targetxforms}, ${5:iters}, ${6:tolerance}, ${7:pinroot}, ${8:targetweights}, ${9:targetpriorities}, ${10:targetdepths}, ${11:goalxforms}, ${12:constrainedxforms}, ${13:jointlimits})",
			"scope": "source.vex",
			"description": "Applies a full-body inverse kinematics algorithm to a skeleton."
	},
	"solvefbik: xforms parents targets targetxforms iters tolerance pinroot targetweights targetpriorities targetdepths targettypes targetoffsets goalxforms constrainedxforms jointlimits": {
			"prefix": "solvefbik(xforms, parents, targets, targetxforms, iters, tolerance, pinroot, targetweights, targetpriorities, targetdepths, targettypes, targetoffsets, goalxforms, constrainedxforms, jointlimits)",
			"body": "solvefbik(${1:xforms}, ${2:parents}, ${3:targets}, ${4:targetxforms}, ${5:iters}, ${6:tolerance}, ${7:pinroot}, ${8:targetweights}, ${9:targetpriorities}, ${10:targetdepths}, ${11:targettypes}, ${12:targetoffsets}, ${13:goalxforms}, ${14:constrainedxforms}, ${15:jointlimits})",
			"scope": "source.vex",
			"description": "Applies a full-body inverse kinematics algorithm to a skeleton."
	},
	"pcunshaded: handle channel_name": {
			"prefix": "pcunshaded(handle, channel_name)",
			"body": "pcunshaded(${1:handle}, ${2:channel_name})",
			"scope": "source.vex",
			"description": "Iterate over all of the points of a read-write channel which haven\u2019t\nhad any data written to the channel yet."
	},
	"usd_blockattrib: stagehandle primpath name": {
			"prefix": "usd_blockattrib(stagehandle, primpath, name)",
			"body": "usd_blockattrib(${1:stagehandle}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Blocks the attribute."
	},
	"attribtype: geometry attribclass attribute_name": {
			"prefix": "attribtype(geometry, attribclass, attribute_name)",
			"body": "attribtype(${1:geometry}, ${2:attribclass}, ${3:attribute_name})",
			"scope": "source.vex",
			"description": "Returns the type of a geometry attribute."
	},
	"objectstate: query value": {
			"prefix": "objectstate(query, value)",
			"body": "objectstate(${1:query}, ${2:value})",
			"scope": "source.vex",
			"description": "Queries the renderer for a named property."
	},
	"neighbours: geometry ptnum": {
			"prefix": "neighbours(geometry, ptnum)",
			"body": "neighbours(${1:geometry}, ${2:ptnum})",
			"scope": "source.vex",
			"description": "Returns an array of the point numbers of the neighbours of a point."
	},
	"pcexport: handle channel_name value ...": {
			"prefix": "pcexport(handle, channel_name, value, ...)",
			"body": "pcexport(${1:handle}, ${2:channel_name}, ${3:value}, ${4:...})",
			"scope": "source.vex",
			"description": "Writes data to a point cloud inside a pciterate or a pcunshaded loop."
	},
	"pcexport: handle channel_name value radius ...": {
			"prefix": "pcexport(handle, channel_name, value, radius, ...)",
			"body": "pcexport(${1:handle}, ${2:channel_name}, ${3:value}, ${4:radius}, ${5:...})",
			"scope": "source.vex",
			"description": "Writes data to a point cloud inside a pciterate or a pcunshaded loop."
	},
	"sample_circle_slice: center maxangle u": {
			"prefix": "sample_circle_slice(center, maxangle, u)",
			"body": "sample_circle_slice(${1:center}, ${2:maxangle}, ${3:u})",
			"scope": "source.vex",
			"description": "Generates a uniform vector2 with length < 1, within maxangle of center, given a vector2 of uniform numbers between 0 and 1."
	},
	"prim: geometry attribute_name primnumber": {
			"prefix": "prim(geometry, attribute_name, primnumber)",
			"body": "prim(${1:geometry}, ${2:attribute_name}, ${3:primnumber})",
			"scope": "source.vex",
			"description": "Reads a primitive attribute value from a geometry."
	},
	"setvertexattrib: geohandle name prim_num vertex_num value mode": {
			"prefix": "setvertexattrib(geohandle, name, prim_num, vertex_num, value, mode)",
			"body": "setvertexattrib(${1:geohandle}, ${2:name}, ${3:prim_num}, ${4:vertex_num}, ${5:value}, ${6:mode})",
			"scope": "source.vex",
			"description": "Sets a vertex attribute in a geometry."
	},
	"vertexhedge: geometry vertex": {
			"prefix": "vertexhedge(geometry, vertex)",
			"body": "vertexhedge(${1:geometry}, ${2:vertex})",
			"scope": "source.vex",
			"description": "Returns the half-edge which has a vertex as source."
	},
	"setdetailintrinsic: geohandle name value mode": {
			"prefix": "setdetailintrinsic(geohandle, name, value, mode)",
			"body": "setdetailintrinsic(${1:geohandle}, ${2:name}, ${3:value}, ${4:mode})",
			"scope": "source.vex",
			"description": "Sets the value of a writeable detail intrinsic attribute."
	},
	"usd_findtransformname: stage primpath suffix": {
			"prefix": "usd_findtransformname(stage, primpath, suffix)",
			"body": "usd_findtransformname(${1:stage}, ${2:primpath}, ${3:suffix})",
			"scope": "source.vex",
			"description": "Retrurns primitive\u2019s transform operation full name for given the transform operation suffix"
	},
	"hair: N tip lobe_shift lobe_width_lon ...": {
			"prefix": "hair(N, tip, lobe_shift, lobe_width_lon, ...)",
			"body": "hair(${1:N}, ${2:tip}, ${3:lobe_shift}, ${4:lobe_width_lon}, ${5:...})",
			"scope": "source.vex",
			"description": "Returns a BSDF for shading hair."
	},
	"hair: N tip lobe_shift lobe_width_lon lobe_with_azi ...": {
			"prefix": "hair(N, tip, lobe_shift, lobe_width_lon, lobe_with_azi, ...)",
			"body": "hair(${1:N}, ${2:tip}, ${3:lobe_shift}, ${4:lobe_width_lon}, ${5:lobe_with_azi}, ${6:...})",
			"scope": "source.vex",
			"description": "Returns a BSDF for shading hair."
	},
	"hair: N tip lobe_shift lobe_width_lon lobe_with_azi glint_shift glint_intensity ...": {
			"prefix": "hair(N, tip, lobe_shift, lobe_width_lon, lobe_with_azi, glint_shift, glint_intensity, ...)",
			"body": "hair(${1:N}, ${2:tip}, ${3:lobe_shift}, ${4:lobe_width_lon}, ${5:lobe_with_azi}, ${6:glint_shift}, ${7:glint_intensity}, ${8:...})",
			"scope": "source.vex",
			"description": "Returns a BSDF for shading hair."
	},
	"rstrip: value": {
			"prefix": "rstrip(value)",
			"body": "rstrip(${1:value})",
			"scope": "source.vex",
			"description": "Strips trailing whitespace from a string."
	},
	"rstrip: value whitespace": {
			"prefix": "rstrip(value, whitespace)",
			"body": "rstrip(${1:value}, ${2:whitespace})",
			"scope": "source.vex",
			"description": "Strips trailing whitespace from a string."
	},
	"usd_collectionexpansionrule: stage collectionpath": {
			"prefix": "usd_collectionexpansionrule(stage, collectionpath)",
			"body": "usd_collectionexpansionrule(${1:stage}, ${2:collectionpath})",
			"scope": "source.vex",
			"description": "Obtains the collection\u2019s expansion rule"
	},
	"ocean_sample: geometry phase frequency amplitude hscale time mode downsample pos": {
			"prefix": "ocean_sample(geometry, phase, frequency, amplitude, hscale, time, mode, downsample, pos)",
			"body": "ocean_sample(${1:geometry}, ${2:phase}, ${3:frequency}, ${4:amplitude}, ${5:hscale}, ${6:time}, ${7:mode}, ${8:downsample}, ${9:pos})",
			"scope": "source.vex",
			"description": "Evaluates an ocean spectrum and samples the result at a given time and location."
	},
	"ord: value": {
			"prefix": "ord(value)",
			"body": "ord(${1:value})",
			"scope": "source.vex",
			"description": "Converts an UTF8 string into a codepoint."
	},
	"chp: channel": {
			"prefix": "chp(channel)",
			"body": "chp(${1:channel})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"chp: channel time": {
			"prefix": "chp(channel, time)",
			"body": "chp(${1:channel}, ${2:time})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"ichname: inputnum plane_index component_index": {
			"prefix": "ichname(inputnum, plane_index, component_index)",
			"body": "ichname(${1:inputnum}, ${2:plane_index}, ${3:component_index})",
			"scope": "source.vex",
			"description": "Returns the channel name of the indexed plane of the given input."
	},
	"pointattribtypeinfo: geometry attribute_name": {
			"prefix": "pointattribtypeinfo(geometry, attribute_name)",
			"body": "pointattribtypeinfo(${1:geometry}, ${2:attribute_name})",
			"scope": "source.vex",
			"description": "Returns the type info of a geometry attribute."
	},
	"create_cdf: pdf": {
			"prefix": "create_cdf(pdf)",
			"body": "create_cdf(${1:pdf})",
			"scope": "source.vex",
			"description": "Creates a CDF from an array of input PDF values."
	},
	"solvepoly: coef roots maxiter": {
			"prefix": "solvepoly(coef, roots, maxiter)",
			"body": "solvepoly(${1:coef}, ${2:roots}, ${3:maxiter})",
			"scope": "source.vex",
			"description": "Finds the real roots of a polynomial."
	},
	"chf: channel": {
			"prefix": "chf(channel)",
			"body": "chf(${1:channel})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"chf: channel time_in_sec": {
			"prefix": "chf(channel, time_in_sec)",
			"body": "chf(${1:channel}, ${2:time_in_sec})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"chf: op_id parm_index vector_index": {
			"prefix": "chf(op_id, parm_index, vector_index)",
			"body": "chf(${1:op_id}, ${2:parm_index}, ${3:vector_index})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"chf: op_id parm_index vector_index time_in_sec": {
			"prefix": "chf(op_id, parm_index, vector_index, time_in_sec)",
			"body": "chf(${1:op_id}, ${2:parm_index}, ${3:vector_index}, ${4:time_in_sec})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"agentclipsample: geometry prim clipname time channel_index": {
			"prefix": "agentclipsample(geometry, prim, clipname, time, channel_index)",
			"body": "agentclipsample(${1:geometry}, ${2:prim}, ${3:clipname}, ${4:time}, ${5:channel_index})",
			"scope": "source.vex",
			"description": "Samples a channel of an agent\u2019s clip at a specific time."
	},
	"agentclipsample: geometry prim clipname time channel": {
			"prefix": "agentclipsample(geometry, prim, clipname, time, channel)",
			"body": "agentclipsample(${1:geometry}, ${2:prim}, ${3:clipname}, ${4:time}, ${5:channel})",
			"scope": "source.vex",
			"description": "Samples a channel of an agent\u2019s clip at a specific time."
	},
	"instance: P N": {
			"prefix": "instance(P, N)",
			"body": "instance(${1:P}, ${2:N})",
			"scope": "source.vex",
			"description": "Creates an instance transform matrix."
	},
	"instance: P N scale": {
			"prefix": "instance(P, N, scale)",
			"body": "instance(${1:P}, ${2:N}, ${3:scale})",
			"scope": "source.vex",
			"description": "Creates an instance transform matrix."
	},
	"instance: P N scale pivot": {
			"prefix": "instance(P, N, scale, pivot)",
			"body": "instance(${1:P}, ${2:N}, ${3:scale}, ${4:pivot})",
			"scope": "source.vex",
			"description": "Creates an instance transform matrix."
	},
	"instance: P N scale rotate up": {
			"prefix": "instance(P, N, scale, rotate, up)",
			"body": "instance(${1:P}, ${2:N}, ${3:scale}, ${4:rotate}, ${5:up})",
			"scope": "source.vex",
			"description": "Creates an instance transform matrix."
	},
	"instance: P N scale rotate up pivot": {
			"prefix": "instance(P, N, scale, rotate, up, pivot)",
			"body": "instance(${1:P}, ${2:N}, ${3:scale}, ${4:rotate}, ${5:up}, ${6:pivot})",
			"scope": "source.vex",
			"description": "Creates an instance transform matrix."
	},
	"instance: P N scale rotate orient": {
			"prefix": "instance(P, N, scale, rotate, orient)",
			"body": "instance(${1:P}, ${2:N}, ${3:scale}, ${4:rotate}, ${5:orient})",
			"scope": "source.vex",
			"description": "Creates an instance transform matrix."
	},
	"instance: P N scale rotate orient pivot": {
			"prefix": "instance(P, N, scale, rotate, orient, pivot)",
			"body": "instance(${1:P}, ${2:N}, ${3:scale}, ${4:rotate}, ${5:orient}, ${6:pivot})",
			"scope": "source.vex",
			"description": "Creates an instance transform matrix."
	},
	"agentcliptransformgroups: geometry prim": {
			"prefix": "agentcliptransformgroups(geometry, prim)",
			"body": "agentcliptransformgroups(${1:geometry}, ${2:prim})",
			"scope": "source.vex",
			"description": "Returns the transform groups for an agent primitive\u2019s current animation clips."
	},
	"chexprf: channel new_expr_function frame": {
			"prefix": "chexprf(channel, new_expr_function, frame)",
			"body": "chexprf(${1:channel}, ${2:new_expr_function}, ${3:frame})",
			"scope": "source.vex",
			"description": "Evaluates a channel with a new segment expression at a given frame."
	},
	"metaimport: handle attrib P value": {
			"prefix": "metaimport(handle, attrib, P, value)",
			"body": "metaimport(${1:handle}, ${2:attrib}, ${3:P}, ${4:value})",
			"scope": "source.vex",
			"description": "Once you get a handle to a metaball using metastart and metanext, you\ncan query attributes of the metaball with metaimport."
	},
	"metaimport: file attribute P": {
			"prefix": "metaimport(file, attribute, P)",
			"body": "metaimport(${1:file}, ${2:attribute}, ${3:P})",
			"scope": "source.vex",
			"description": "Once you get a handle to a metaball using metastart and metanext, you\ncan query attributes of the metaball with metaimport."
	},
	"metastart: filename p": {
			"prefix": "metastart(filename, p)",
			"body": "metastart(${1:filename}, ${2:p})",
			"scope": "source.vex",
			"description": "Open a geometry file and return a \"handle\" for the metaballs of\ninterest, at the position p."
	},
	"encode: str": {
			"prefix": "encode(str)",
			"body": "encode(${1:str})",
			"scope": "source.vex",
			"description": "Encodes any string into a valid variable name."
	},
	"luminance: rgb": {
			"prefix": "luminance(rgb)",
			"body": "luminance(${1:rgb})",
			"scope": "source.vex",
			"description": "Compute the luminance of the RGB color specified by the parameters."
	},
	"luminance: r g b": {
			"prefix": "luminance(r, g, b)",
			"body": "luminance(${1:r}, ${2:g}, ${3:b})",
			"scope": "source.vex",
			"description": "Compute the luminance of the RGB color specified by the parameters."
	},
	"mwnoise: position seed f1 f2": {
			"prefix": "mwnoise(position, seed, f1, f2)",
			"body": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Manhattan distance metric."
	},
	"mwnoise: position seed f1 f2 f3 f4": {
			"prefix": "mwnoise(position, seed, f1, f2, f3, f4)",
			"body": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Manhattan distance metric."
	},
	"mwnoise: position seed f1 f2 peiod": {
			"prefix": "mwnoise(position, seed, f1, f2, peiod)",
			"body": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:peiod})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Manhattan distance metric."
	},
	"mwnoise: position seed f1 f2 f4 f4 period": {
			"prefix": "mwnoise(position, seed, f1, f2, f4, f4, period)",
			"body": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f4}, ${6:f4}, ${7:period})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Manhattan distance metric."
	},
	"mwnoise: posx posy seed f1 f2": {
			"prefix": "mwnoise(posx, posy, seed, f1, f2)",
			"body": "mwnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Manhattan distance metric."
	},
	"mwnoise: posx posy seed f1 f2 f3 f4": {
			"prefix": "mwnoise(posx, posy, seed, f1, f2, f3, f4)",
			"body": "mwnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:f3}, ${7:f4})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Manhattan distance metric."
	},
	"mwnoise: posx posy seed f1 f2 periodx periody": {
			"prefix": "mwnoise(posx, posy, seed, f1, f2, periodx, periody)",
			"body": "mwnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:periodx}, ${7:periody})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Manhattan distance metric."
	},
	"mwnoise: posx posy seed f1 f2 f3 f4 periodx periody": {
			"prefix": "mwnoise(posx, posy, seed, f1, f2, f3, f4, periodx, periody)",
			"body": "mwnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:f3}, ${7:f4}, ${8:periodx}, ${9:periody})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Manhattan distance metric."
	},
	"mwnoise: position seed f1 f2 periodx periody": {
			"prefix": "mwnoise(position, seed, f1, f2, periodx, periody)",
			"body": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:periodx}, ${6:periody})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Manhattan distance metric."
	},
	"mwnoise: position seed f1 f2 f3 f4 periodx periody": {
			"prefix": "mwnoise(position, seed, f1, f2, f3, f4, periodx, periody)",
			"body": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4}, ${7:periodx}, ${8:periody})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Manhattan distance metric."
	},
	"mwnoise: position seed f1 f2 periodx periody periodx": {
			"prefix": "mwnoise(position, seed, f1, f2, periodx, periody, periodx)",
			"body": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:periodx}, ${6:periody}, ${7:periodx})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Manhattan distance metric."
	},
	"mwnoise: position seed f1 f2 f3 f4 periodx periody periodz": {
			"prefix": "mwnoise(position, seed, f1, f2, f3, f4, periodx, periody, periodz)",
			"body": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4}, ${7:periodx}, ${8:periody}, ${9:periodz})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Manhattan distance metric."
	},
	"mwnoise: position seed f1 f2 periodx periody periodz periodw": {
			"prefix": "mwnoise(position, seed, f1, f2, periodx, periody, periodz, periodw)",
			"body": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:periodx}, ${6:periody}, ${7:periodz}, ${8:periodw})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Manhattan distance metric."
	},
	"mwnoise: position seed f1 f2 f3 f4 periodx periody periodz periodw": {
			"prefix": "mwnoise(position, seed, f1, f2, f3, f4, periodx, periody, periodz, periodw)",
			"body": "mwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4}, ${7:periodx}, ${8:periody}, ${9:periodz}, ${10:periodw})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Manhattan distance metric."
	},
	"usd_getbounds: stage primpath purpose min max": {
			"prefix": "usd_getbounds(stage, primpath, purpose, min, max)",
			"body": "usd_getbounds(${1:stage}, ${2:primpath}, ${3:purpose}, ${4:min}, ${5:max})",
			"scope": "source.vex",
			"description": "Obtains the primitive\u2019s bounds"
	},
	"usd_getbounds: stage primpath purpose timecode min max": {
			"prefix": "usd_getbounds(stage, primpath, purpose, timecode, min, max)",
			"body": "usd_getbounds(${1:stage}, ${2:primpath}, ${3:purpose}, ${4:timecode}, ${5:min}, ${6:max})",
			"scope": "source.vex",
			"description": "Obtains the primitive\u2019s bounds"
	},
	"usd_getpointinstancebounds: stage primpath instance_index purpose min max": {
			"prefix": "usd_getpointinstancebounds(stage, primpath, instance_index, purpose, min, max)",
			"body": "usd_getpointinstancebounds(${1:stage}, ${2:primpath}, ${3:instance_index}, ${4:purpose}, ${5:min}, ${6:max})",
			"scope": "source.vex",
			"description": "Obtains the primitive\u2019s bounds"
	},
	"usd_getpointinstancebounds: stage primpath instance_index purpose timecode min max": {
			"prefix": "usd_getpointinstancebounds(stage, primpath, instance_index, purpose, timecode, min, max)",
			"body": "usd_getpointinstancebounds(${1:stage}, ${2:primpath}, ${3:instance_index}, ${4:purpose}, ${5:timecode}, ${6:min}, ${7:max})",
			"scope": "source.vex",
			"description": "Obtains the primitive\u2019s bounds"
	},
	"__uniform_premul: a b": {
			"prefix": "__uniform_premul(a, b)",
			"body": "__uniform_premul(${1:a}, ${2:b})",
			"scope": "source.vex",
			"description": "Pre multiply matrices."
	},
	"__uniform_premul: m a b": {
			"prefix": "__uniform_premul(m, a, b)",
			"body": "__uniform_premul(${1:m}, ${2:a}, ${3:b})",
			"scope": "source.vex",
			"description": "Pre multiply matrices."
	},
	"usd_primvartimesamples: stage primpath name": {
			"prefix": "usd_primvartimesamples(stage, primpath, name)",
			"body": "usd_primvartimesamples(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Returns the time codes at which the primvar values are authored."
	},
	"chname: plane_index chindex": {
			"prefix": "chname(plane_index, chindex)",
			"body": "chname(${1:plane_index}, ${2:chindex})",
			"scope": "source.vex",
			"description": "Returns the name of a numbered channel."
	},
	"chname: channel_index": {
			"prefix": "chname(channel_index)",
			"body": "chname(${1:channel_index})",
			"scope": "source.vex",
			"description": "Returns the name of a numbered channel."
	},
	"chname: opinput channel_index": {
			"prefix": "chname(opinput, channel_index)",
			"body": "chname(${1:opinput}, ${2:channel_index})",
			"scope": "source.vex",
			"description": "Returns the name of a numbered channel."
	},
	"ocio_activedisplays: ": {
			"prefix": "ocio_activedisplays()",
			"body": "ocio_activedisplays()",
			"scope": "source.vex",
			"description": "Returns the names of active displays supported in Open Color IO"
	},
	"getscope: mat raystyle scope categories": {
			"prefix": "getscope(mat, raystyle, scope, categories)",
			"body": "getscope(${1:mat}, ${2:raystyle}, ${3:scope}, ${4:categories})",
			"scope": "source.vex",
			"description": "Returns a selection of objects visible to rays for a given material."
	},
	"pcsampleleaf: handle sample": {
			"prefix": "pcsampleleaf(handle, sample)",
			"body": "pcsampleleaf(${1:handle}, ${2:sample})",
			"scope": "source.vex",
			"description": "Changes the current iteration point to a leaf descendant of the current aggregate point."
	},
	"join: s spacer": {
			"prefix": "join(s, spacer)",
			"body": "join(${1:s}, ${2:spacer})",
			"scope": "source.vex",
			"description": "Concatenate all the strings of an array inserting a common spacer."
	},
	"usd_setattrib: stagehandle primpath name value": {
			"prefix": "usd_setattrib(stagehandle, primpath, name, value)",
			"body": "usd_setattrib(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:value})",
			"scope": "source.vex",
			"description": "Sets the value of an attribute."
	},
	"usd_variantsets: stage primpath": {
			"prefix": "usd_variantsets(stage, primpath)",
			"body": "usd_variantsets(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Returns the variant sets available on a primitive."
	},
	"filamentsample: geometry position": {
			"prefix": "filamentsample(geometry, position)",
			"body": "filamentsample(${1:geometry}, ${2:position})",
			"scope": "source.vex",
			"description": "Samples the velocity field defined by a set of vortex filaments."
	},
	"usd_iscollectionpath: stage collectionpath": {
			"prefix": "usd_iscollectionpath(stage, collectionpath)",
			"body": "usd_iscollectionpath(${1:stage}, ${2:collectionpath})",
			"scope": "source.vex",
			"description": "Checks if the path is a valid collection path."
	},
	"usd_setactive: stagehandle primpath flag": {
			"prefix": "usd_setactive(stagehandle, primpath, flag)",
			"body": "usd_setactive(${1:stagehandle}, ${2:primpath}, ${3:flag})",
			"scope": "source.vex",
			"description": "Sets the primitive active state."
	},
	"islpeactive: ": {
			"prefix": "islpeactive()",
			"body": "islpeactive()",
			"scope": "source.vex",
			"description": "Returns 1 if Light Path Expressions are enabled. 0 Otherwise."
	},
	"ptransform: vec transform": {
			"prefix": "ptransform(vec, transform)",
			"body": "ptransform(${1:vec}, ${2:transform})",
			"scope": "source.vex",
			"description": "Transforms a vector from one space to another."
	},
	"ptransform: tospace vec": {
			"prefix": "ptransform(tospace, vec)",
			"body": "ptransform(${1:tospace}, ${2:vec})",
			"scope": "source.vex",
			"description": "Transforms a vector from one space to another."
	},
	"ptransform: fromspace tospace vec": {
			"prefix": "ptransform(fromspace, tospace, vec)",
			"body": "ptransform(${1:fromspace}, ${2:tospace}, ${3:vec})",
			"scope": "source.vex",
			"description": "Transforms a vector from one space to another."
	},
	"volumeindextopos: geometry primnum voxel": {
			"prefix": "volumeindextopos(geometry, primnum, voxel)",
			"body": "volumeindextopos(${1:geometry}, ${2:primnum}, ${3:voxel})",
			"scope": "source.vex",
			"description": "Converts a volume voxel index into a position."
	},
	"volumeindextopos: geometry volumename voxel": {
			"prefix": "volumeindextopos(geometry, volumename, voxel)",
			"body": "volumeindextopos(${1:geometry}, ${2:volumename}, ${3:voxel})",
			"scope": "source.vex",
			"description": "Converts a volume voxel index into a position."
	},
	"tw_nspace: v": {
			"prefix": "tw_nspace(v)",
			"body": "tw_nspace(${1:v})",
			"scope": "source.vex",
			"description": "Transforms a normal vector from Texture to World space."
	},
	"attribsize: geometry attribclass attribute_name": {
			"prefix": "attribsize(geometry, attribclass, attribute_name)",
			"body": "attribsize(${1:geometry}, ${2:attribclass}, ${3:attribute_name})",
			"scope": "source.vex",
			"description": "Returns the size of a geometry attribute."
	},
	"makebasis: xaxis yaxis zaxis": {
			"prefix": "makebasis(xaxis, yaxis, zaxis)",
			"body": "makebasis(${1:xaxis}, ${2:yaxis}, ${3:zaxis})",
			"scope": "source.vex",
			"description": "Creates an orthonormal basis given a z-axis vector."
	},
	"makebasis: xaxis yaxis zaxis u": {
			"prefix": "makebasis(xaxis, yaxis, zaxis, u)",
			"body": "makebasis(${1:xaxis}, ${2:yaxis}, ${3:zaxis}, ${4:u})",
			"scope": "source.vex",
			"description": "Creates an orthonormal basis given a z-axis vector."
	},
	"pointhedgenext: geometry hedge": {
			"prefix": "pointhedgenext(geometry, hedge)",
			"body": "pointhedgenext(${1:geometry}, ${2:hedge})",
			"scope": "source.vex",
			"description": "Returns the next half-edge with the same source as a given half-edge."
	},
	"setpointgroup: geohandle name point_num value mode": {
			"prefix": "setpointgroup(geohandle, name, point_num, value, mode)",
			"body": "setpointgroup(${1:geohandle}, ${2:name}, ${3:point_num}, ${4:value}, ${5:mode})",
			"scope": "source.vex",
			"description": "Adds or removes a point to/from a group in a geometry."
	},
	"packedtransform: input primnum transform": {
			"prefix": "packedtransform(input, primnum, transform)",
			"body": "packedtransform(${1:input}, ${2:primnum}, ${3:transform})",
			"scope": "source.vex",
			"description": "Transforms a packed primitive."
	},
	"prim_attribute: geometry value attribute_name prim_number u v": {
			"prefix": "prim_attribute(geometry, value, attribute_name, prim_number, u, v)",
			"body": "prim_attribute(${1:geometry}, ${2:value}, ${3:attribute_name}, ${4:prim_number}, ${5:u}, ${6:v})",
			"scope": "source.vex",
			"description": "Interpolates the value of an attribute at a certain parametric (u, v) position and copies it into a variable."
	},
	"prim_attribute: geometry value attribute_name prim_number uvw": {
			"prefix": "prim_attribute(geometry, value, attribute_name, prim_number, uvw)",
			"body": "prim_attribute(${1:geometry}, ${2:value}, ${3:attribute_name}, ${4:prim_number}, ${5:uvw})",
			"scope": "source.vex",
			"description": "Interpolates the value of an attribute at a certain parametric (u, v) position and copies it into a variable."
	},
	"usd_setprimvarinterpolation: stagehandle primpath name interpolation": {
			"prefix": "usd_setprimvarinterpolation(stagehandle, primpath, name, interpolation)",
			"body": "usd_setprimvarinterpolation(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:interpolation})",
			"scope": "source.vex",
			"description": "Sets the interpolation of a primvar."
	},
	"cosh: n": {
			"prefix": "cosh(n)",
			"body": "cosh(${1:n})",
			"scope": "source.vex",
			"description": "Returns the hyperbolic cosine of the argument."
	},
	"cosh: v": {
			"prefix": "cosh(v)",
			"body": "cosh(${1:v})",
			"scope": "source.vex",
			"description": "Returns the hyperbolic cosine of the argument."
	},
	"predicate_insphere: a b c d e": {
			"prefix": "predicate_insphere(a, b, c, d, e)",
			"body": "predicate_insphere(${1:a}, ${2:b}, ${3:c}, ${4:d}, ${5:e})",
			"scope": "source.vex",
			"description": "Determines if a point is inside or outside a tetrahedron circumsphere."
	},
	"noised: x v dvdx": {
			"prefix": "noised(x, v, dvdx)",
			"body": "noised(${1:x}, ${2:v}, ${3:dvdx})",
			"scope": "source.vex",
			"description": "Derivatives of Perlin Noise."
	},
	"noised: x y v dvdx dvdy": {
			"prefix": "noised(x, y, v, dvdx, dvdy)",
			"body": "noised(${1:x}, ${2:y}, ${3:v}, ${4:dvdx}, ${5:dvdy})",
			"scope": "source.vex",
			"description": "Derivatives of Perlin Noise."
	},
	"noised: xyz v dvdx dvdy dvdz": {
			"prefix": "noised(xyz, v, dvdx, dvdy, dvdz)",
			"body": "noised(${1:xyz}, ${2:v}, ${3:dvdx}, ${4:dvdy}, ${5:dvdz})",
			"scope": "source.vex",
			"description": "Derivatives of Perlin Noise."
	},
	"noised: xyzw v dvdx dvdy dvdz dvdw": {
			"prefix": "noised(xyzw, v, dvdx, dvdy, dvdz, dvdw)",
			"body": "noised(${1:xyzw}, ${2:v}, ${3:dvdx}, ${4:dvdy}, ${5:dvdz}, ${6:dvdw})",
			"scope": "source.vex",
			"description": "Derivatives of Perlin Noise."
	},
	"finput: u v ...": {
			"prefix": "finput(u, v, ...)",
			"body": "finput(${1:u}, ${2:v}, ${3:...})",
			"scope": "source.vex",
			"description": "Returns fully filtered pixel input."
	},
	"finput: component u v ...": {
			"prefix": "finput(component, u, v, ...)",
			"body": "finput(${1:component}, ${2:u}, ${3:v}, ${4:...})",
			"scope": "source.vex",
			"description": "Returns fully filtered pixel input."
	},
	"finput: opinput planeindex u v ...": {
			"prefix": "finput(opinput, planeindex, u, v, ...)",
			"body": "finput(${1:opinput}, ${2:planeindex}, ${3:u}, ${4:v}, ${5:...})",
			"scope": "source.vex",
			"description": "Returns fully filtered pixel input."
	},
	"finput: opinput planeindex component u v ...": {
			"prefix": "finput(opinput, planeindex, component, u, v, ...)",
			"body": "finput(${1:opinput}, ${2:planeindex}, ${3:component}, ${4:u}, ${5:v}, ${6:...})",
			"scope": "source.vex",
			"description": "Returns fully filtered pixel input."
	},
	"finput: opinput planeindex arrayindex u v frame ...": {
			"prefix": "finput(opinput, planeindex, arrayindex, u, v, frame, ...)",
			"body": "finput(${1:opinput}, ${2:planeindex}, ${3:arrayindex}, ${4:u}, ${5:v}, ${6:frame}, ${7:...})",
			"scope": "source.vex",
			"description": "Returns fully filtered pixel input."
	},
	"finput: opinput planeindex arrayindex component u v frame ...": {
			"prefix": "finput(opinput, planeindex, arrayindex, component, u, v, frame, ...)",
			"body": "finput(${1:opinput}, ${2:planeindex}, ${3:arrayindex}, ${4:component}, ${5:u}, ${6:v}, ${7:frame}, ${8:...})",
			"scope": "source.vex",
			"description": "Returns fully filtered pixel input."
	},
	"pxnoise: x xp": {
			"prefix": "pxnoise(x, xp)",
			"body": "pxnoise(${1:x}, ${2:xp})",
			"scope": "source.vex",
			"description": "Simplex noise is very close to Perlin noise, except with the samples on a simplex mesh rather than a grid.  This results in less grid artifacts.  It also uses a higher order bspline to provide better derivatives. This is the periodic simplex noise"
	},
	"pxnoise: x y xp yp": {
			"prefix": "pxnoise(x, y, xp, yp)",
			"body": "pxnoise(${1:x}, ${2:y}, ${3:xp}, ${4:yp})",
			"scope": "source.vex",
			"description": "Simplex noise is very close to Perlin noise, except with the samples on a simplex mesh rather than a grid.  This results in less grid artifacts.  It also uses a higher order bspline to provide better derivatives. This is the periodic simplex noise"
	},
	"pxnoise: xyz xp yp zp": {
			"prefix": "pxnoise(xyz, xp, yp, zp)",
			"body": "pxnoise(${1:xyz}, ${2:xp}, ${3:yp}, ${4:zp})",
			"scope": "source.vex",
			"description": "Simplex noise is very close to Perlin noise, except with the samples on a simplex mesh rather than a grid.  This results in less grid artifacts.  It also uses a higher order bspline to provide better derivatives. This is the periodic simplex noise"
	},
	"pxnoise: xyzt xp yp zp wp": {
			"prefix": "pxnoise(xyzt, xp, yp, zp, wp)",
			"body": "pxnoise(${1:xyzt}, ${2:xp}, ${3:yp}, ${4:zp}, ${5:wp})",
			"scope": "source.vex",
			"description": "Simplex noise is very close to Perlin noise, except with the samples on a simplex mesh rather than a grid.  This results in less grid artifacts.  It also uses a higher order bspline to provide better derivatives. This is the periodic simplex noise"
	},
	"pointvertex: geometry point_num": {
			"prefix": "pointvertex(geometry, point_num)",
			"body": "pointvertex(${1:geometry}, ${2:point_num})",
			"scope": "source.vex",
			"description": "Returns a linear vertex number of a point in a geometry."
	},
	"oprawparmtransform: path": {
			"prefix": "oprawparmtransform(path)",
			"body": "oprawparmtransform(${1:path})",
			"scope": "source.vex",
			"description": "Returns the raw parm transform associated with an OP."
	},
	"oprawparmtransform: path time": {
			"prefix": "oprawparmtransform(path, time)",
			"body": "oprawparmtransform(${1:path}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the raw parm transform associated with an OP."
	},
	"oprawparmtransform: opid": {
			"prefix": "oprawparmtransform(opid)",
			"body": "oprawparmtransform(${1:opid})",
			"scope": "source.vex",
			"description": "Returns the raw parm transform associated with an OP."
	},
	"oprawparmtransform: opid time": {
			"prefix": "oprawparmtransform(opid, time)",
			"body": "oprawparmtransform(${1:opid}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the raw parm transform associated with an OP."
	},
	"oprawparmtransform: opid trsorder xyzorder mask": {
			"prefix": "oprawparmtransform(opid, trsorder, xyzorder, mask)",
			"body": "oprawparmtransform(${1:opid}, ${2:trsorder}, ${3:xyzorder}, ${4:mask})",
			"scope": "source.vex",
			"description": "Returns the raw parm transform associated with an OP."
	},
	"opparmtransform: path": {
			"prefix": "opparmtransform(path)",
			"body": "opparmtransform(${1:path})",
			"scope": "source.vex",
			"description": "Returns the parm transform associated with an OP."
	},
	"opparmtransform: path time": {
			"prefix": "opparmtransform(path, time)",
			"body": "opparmtransform(${1:path}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the parm transform associated with an OP."
	},
	"opparmtransform: opid": {
			"prefix": "opparmtransform(opid)",
			"body": "opparmtransform(${1:opid})",
			"scope": "source.vex",
			"description": "Returns the parm transform associated with an OP."
	},
	"opparmtransform: opid time": {
			"prefix": "opparmtransform(opid, time)",
			"body": "opparmtransform(${1:opid}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the parm transform associated with an OP."
	},
	"ntransform: v transform": {
			"prefix": "ntransform(v, transform)",
			"body": "ntransform(${1:v}, ${2:transform})",
			"scope": "source.vex",
			"description": "Transforms a normal vector."
	},
	"ntransform: tospace v": {
			"prefix": "ntransform(tospace, v)",
			"body": "ntransform(${1:tospace}, ${2:v})",
			"scope": "source.vex",
			"description": "Transforms a normal vector."
	},
	"ntransform: fromspace tospace v": {
			"prefix": "ntransform(fromspace, tospace, v)",
			"body": "ntransform(${1:fromspace}, ${2:tospace}, ${3:v})",
			"scope": "source.vex",
			"description": "Transforms a normal vector."
	},
	"usd_addcollectionexclude: stagehandle collectionpath path": {
			"prefix": "usd_addcollectionexclude(stagehandle, collectionpath, path)",
			"body": "usd_addcollectionexclude(${1:stagehandle}, ${2:collectionpath}, ${3:path})",
			"scope": "source.vex",
			"description": "Excludes an object from the collection"
	},
	"occlusion: P N ...": {
			"prefix": "occlusion(P, N, ...)",
			"body": "occlusion(${1:P}, ${2:N}, ${3:...})",
			"scope": "source.vex",
			"description": "Computes ambient occlusion."
	},
	"occlusion: coverage missed_direction P N ...": {
			"prefix": "occlusion(coverage, missed_direction, P, N, ...)",
			"body": "occlusion(${1:coverage}, ${2:missed_direction}, ${3:P}, ${4:N}, ${5:...})",
			"scope": "source.vex",
			"description": "Computes ambient occlusion."
	},
	"ndcdepth: z": {
			"prefix": "ndcdepth(z)",
			"body": "ndcdepth(${1:z})",
			"scope": "source.vex",
			"description": "Returns the camera space z-depth of the NDC z-depth value."
	},
	"decodeattrib: str": {
			"prefix": "decodeattrib(str)",
			"body": "decodeattrib(${1:str})",
			"scope": "source.vex",
			"description": "Decodes a geometry attribute name that was previously encoded."
	},
	"adddetailattrib: geohandle name defvalue": {
			"prefix": "adddetailattrib(geohandle, name, defvalue)",
			"body": "adddetailattrib(${1:geohandle}, ${2:name}, ${3:defvalue})",
			"scope": "source.vex",
			"description": "Adds a detail attribute to a geometry."
	},
	"adddetailattrib: geohandle name defvalue typeinfo": {
			"prefix": "adddetailattrib(geohandle, name, defvalue, typeinfo)",
			"body": "adddetailattrib(${1:geohandle}, ${2:name}, ${3:defvalue}, ${4:typeinfo})",
			"scope": "source.vex",
			"description": "Adds a detail attribute to a geometry."
	},
	"agenttransformcount: geometry prim": {
			"prefix": "agenttransformcount(geometry, prim)",
			"body": "agenttransformcount(${1:geometry}, ${2:prim})",
			"scope": "source.vex",
			"description": "Returns the number of transforms in an agent primitive\u2019s rig."
	},
	"sample_discrete: nvalues u": {
			"prefix": "sample_discrete(nvalues, u)",
			"body": "sample_discrete(${1:nvalues}, ${2:u})",
			"scope": "source.vex",
			"description": "Returns an integer, either uniform or weighted, given a uniform number between 0 and 1."
	},
	"sample_discrete: weights u": {
			"prefix": "sample_discrete(weights, u)",
			"body": "sample_discrete(${1:weights}, ${2:u})",
			"scope": "source.vex",
			"description": "Returns an integer, either uniform or weighted, given a uniform number between 0 and 1."
	},
	"getderiv: attr attrName isVertexAttr s t du dv ...": {
			"prefix": "getderiv(attr, attrName, isVertexAttr, s, t, du, dv, ...)",
			"body": "getderiv(${1:attr}, ${2:attrName}, ${3:isVertexAttr}, ${4:s}, ${5:t}, ${6:du}, ${7:dv}, ${8:...})",
			"scope": "source.vex",
			"description": "Evaluates surface derivatives of an attribute."
	},
	"pcline: geometry PChannel P dir max_distance maxpoints": {
			"prefix": "pcline(geometry, PChannel, P, dir, max_distance, maxpoints)",
			"body": "pcline(${1:geometry}, ${2:PChannel}, ${3:P}, ${4:dir}, ${5:max_distance}, ${6:maxpoints})",
			"scope": "source.vex",
			"description": "Returns a list of closest points to an infinite line from a specified file"
	},
	"pcline: geometry ptgroup PChannel P dir max_distance maxpoints": {
			"prefix": "pcline(geometry, ptgroup, PChannel, P, dir, max_distance, maxpoints)",
			"body": "pcline(${1:geometry}, ${2:ptgroup}, ${3:PChannel}, ${4:P}, ${5:dir}, ${6:max_distance}, ${7:maxpoints})",
			"scope": "source.vex",
			"description": "Returns a list of closest points to an infinite line from a specified file"
	},
	"primattrib: geometry attribute_name prim success": {
			"prefix": "primattrib(geometry, attribute_name, prim, success)",
			"body": "primattrib(${1:geometry}, ${2:attribute_name}, ${3:prim}, ${4:success})",
			"scope": "source.vex",
			"description": "Reads a primitive attribute value from a geometry, outputting a success flag."
	},
	"pointprims: geometry ptnum": {
			"prefix": "pointprims(geometry, ptnum)",
			"body": "pointprims(${1:geometry}, ${2:ptnum})",
			"scope": "source.vex",
			"description": "Returns the list of primitives containing a point."
	},
	"chu: channel": {
			"prefix": "chu(channel)",
			"body": "chu(${1:channel})",
			"scope": "source.vex",
			"description": "Evaluates a channel or parameter, and return its value."
	},
	"chu: channel time": {
			"prefix": "chu(channel, time)",
			"body": "chu(${1:channel}, ${2:time})",
			"scope": "source.vex",
			"description": "Evaluates a channel or parameter, and return its value."
	},
	"ch4: channel": {
			"prefix": "ch4(channel)",
			"body": "ch4(${1:channel})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"ch4: channel time": {
			"prefix": "ch4(channel, time)",
			"body": "ch4(${1:channel}, ${2:time})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"getbounds: filename min max": {
			"prefix": "getbounds(filename, min, max)",
			"body": "getbounds(${1:filename}, ${2:min}, ${3:max})",
			"scope": "source.vex",
			"description": "Returns the bounding box of the geometry specified by the filename."
	},
	"getbounds: filename group min max": {
			"prefix": "getbounds(filename, group, min, max)",
			"body": "getbounds(${1:filename}, ${2:group}, ${3:min}, ${4:max})",
			"scope": "source.vex",
			"description": "Returns the bounding box of the geometry specified by the filename."
	},
	"usd_isrelationship: stage primpath name": {
			"prefix": "usd_isrelationship(stage, primpath, name)",
			"body": "usd_isrelationship(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Checks if the primitive has a relationship by the given name."
	},
	"usd_isinstance: stage primpath": {
			"prefix": "usd_isinstance(stage, primpath)",
			"body": "usd_isinstance(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Checks if the primitive is an instance."
	},
	"log10: n": {
			"prefix": "log10(n)",
			"body": "log10(${1:n})",
			"scope": "source.vex",
			"description": "Returns the logarithm (base 10) of the argument."
	},
	"sample_lognormal: mu sigma u": {
			"prefix": "sample_lognormal(mu, sigma, u)",
			"body": "sample_lognormal(${1:mu}, ${2:sigma}, ${3:u})",
			"scope": "source.vex",
			"description": "Samples the log-normal distribution based on parameters of the underlying normal distribution."
	},
	"sample_lognormal: mu sigma minvalue maxvalue u": {
			"prefix": "sample_lognormal(mu, sigma, minvalue, maxvalue, u)",
			"body": "sample_lognormal(${1:mu}, ${2:sigma}, ${3:minvalue}, ${4:maxvalue}, ${5:u})",
			"scope": "source.vex",
			"description": "Samples the log-normal distribution based on parameters of the underlying normal distribution."
	},
	"ceil: n": {
			"prefix": "ceil(n)",
			"body": "ceil(${1:n})",
			"scope": "source.vex",
			"description": "Returns the smallest integer greater than or equal to the argument."
	},
	"ceil: v": {
			"prefix": "ceil(v)",
			"body": "ceil(${1:v})",
			"scope": "source.vex",
			"description": "Returns the smallest integer greater than or equal to the argument."
	},
	"chexprt: channel new_expr_function time_in_seconds": {
			"prefix": "chexprt(channel, new_expr_function, time_in_seconds)",
			"body": "chexprt(${1:channel}, ${2:new_expr_function}, ${3:time_in_seconds})",
			"scope": "source.vex",
			"description": "Evaluates a channel with a new segment expression at a given time."
	},
	"sensor_panorama_getdepth: handle dir": {
			"prefix": "sensor_panorama_getdepth(handle, dir)",
			"body": "sensor_panorama_getdepth(${1:handle}, ${2:dir})",
			"scope": "source.vex",
			"description": "Sensor function query a rendered GL scene."
	},
	"agentclipcatalog: geometry prim": {
			"prefix": "agentclipcatalog(geometry, prim)",
			"body": "agentclipcatalog(${1:geometry}, ${2:prim})",
			"scope": "source.vex",
			"description": "Returns all of the animation clips that have been loaded for an agent primitive."
	},
	"anoise: pos": {
			"prefix": "anoise(pos)",
			"body": "anoise(${1:pos})",
			"scope": "source.vex",
			"description": "Generates \"alligator\" noise."
	},
	"anoise: pos turbulence rough atten": {
			"prefix": "anoise(pos, turbulence, rough, atten)",
			"body": "anoise(${1:pos}, ${2:turbulence}, ${3:rough}, ${4:atten})",
			"scope": "source.vex",
			"description": "Generates \"alligator\" noise."
	},
	"anoise: pos periodX periodY periodZ": {
			"prefix": "anoise(pos, periodX, periodY, periodZ)",
			"body": "anoise(${1:pos}, ${2:periodX}, ${3:periodY}, ${4:periodZ})",
			"scope": "source.vex",
			"description": "Generates \"alligator\" noise."
	},
	"anoise: pos periodX periodY periodZ turbulence rough atten": {
			"prefix": "anoise(pos, periodX, periodY, periodZ, turbulence, rough, atten)",
			"body": "anoise(${1:pos}, ${2:periodX}, ${3:periodY}, ${4:periodZ}, ${5:turbulence}, ${6:rough}, ${7:atten})",
			"scope": "source.vex",
			"description": "Generates \"alligator\" noise."
	},
	"wireblinn: tangent exponent ...": {
			"prefix": "wireblinn(tangent, exponent, ...)",
			"body": "wireblinn(${1:tangent}, ${2:exponent}, ${3:...})",
			"scope": "source.vex",
			"description": ""
	},
	"frontface: N I": {
			"prefix": "frontface(N, I)",
			"body": "frontface(${1:N}, ${2:I})",
			"scope": "source.vex",
			"description": "If dot(I, Nref) is less than zero, N will be negated."
	},
	"frontface: N I Nref": {
			"prefix": "frontface(N, I, Nref)",
			"body": "frontface(${1:N}, ${2:I}, ${3:Nref})",
			"scope": "source.vex",
			"description": "If dot(I, Nref) is less than zero, N will be negated."
	},
	"usd_attribelement: stage primpath name index": {
			"prefix": "usd_attribelement(stage, primpath, name, index)",
			"body": "usd_attribelement(${1:stage}, ${2:primpath}, ${3:name}, ${4:index})",
			"scope": "source.vex",
			"description": "Reads the value of an element from an array attribute."
	},
	"usd_attribelement: stage primpath name index timecode": {
			"prefix": "usd_attribelement(stage, primpath, name, index, timecode)",
			"body": "usd_attribelement(${1:stage}, ${2:primpath}, ${3:name}, ${4:index}, ${5:timecode})",
			"scope": "source.vex",
			"description": "Reads the value of an element from an array attribute."
	},
	"hedge_equivcount: geometry hedge": {
			"prefix": "hedge_equivcount(geometry, hedge)",
			"body": "hedge_equivcount(${1:geometry}, ${2:hedge})",
			"scope": "source.vex",
			"description": "Returns the number of half-edges equivalent to a given half-edge."
	},
	"usd_boundmaterialpath: stage primpath": {
			"prefix": "usd_boundmaterialpath(stage, primpath)",
			"body": "usd_boundmaterialpath(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Returns the material path bound to a given primitive."
	},
	"colorname: ": {
			"prefix": "colorname()",
			"body": "colorname()",
			"scope": "source.vex",
			"description": "Returns the default name of the color plane (as it appears in the\ncompositor preferences)."
	},
	"ch: channel": {
			"prefix": "ch(channel)",
			"body": "ch(${1:channel})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"ch: channel time_in_sec": {
			"prefix": "ch(channel, time_in_sec)",
			"body": "ch(${1:channel}, ${2:time_in_sec})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"ch: op_id parm_index vector_index": {
			"prefix": "ch(op_id, parm_index, vector_index)",
			"body": "ch(${1:op_id}, ${2:parm_index}, ${3:vector_index})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"ch: op_id parm_index vector_index time_in_sec": {
			"prefix": "ch(op_id, parm_index, vector_index, time_in_sec)",
			"body": "ch(${1:op_id}, ${2:parm_index}, ${3:vector_index}, ${4:time_in_sec})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"osd_firstpatch: geometry face_id": {
			"prefix": "osd_firstpatch(geometry, face_id)",
			"body": "osd_firstpatch(${1:geometry}, ${2:face_id})",
			"scope": "source.vex",
			"description": ""
	},
	"nbouncetypes: ": {
			"prefix": "nbouncetypes()",
			"body": "nbouncetypes()",
			"scope": "source.vex",
			"description": ""
	},
	"volume: pos ...": {
			"prefix": "volume(pos, ...)",
			"body": "volume(${1:pos}, ${2:...})",
			"scope": "source.vex",
			"description": "Returns the volume of the microvoxel containing a variable such as P."
	},
	"unserialize: values": {
			"prefix": "unserialize(values)",
			"body": "unserialize(${1:values})",
			"scope": "source.vex",
			"description": "Turns a flat array of floats into an array of vectors or matrices."
	},
	"ocio_activeviews: ": {
			"prefix": "ocio_activeviews()",
			"body": "ocio_activeviews()",
			"scope": "source.vex",
			"description": "Returns the names of active views supported in Open Color IO"
	},
	"texture3d: filename channel P ...": {
			"prefix": "texture3d(filename, channel, P, ...)",
			"body": "texture3d(${1:filename}, ${2:channel}, ${3:P}, ${4:...})",
			"scope": "source.vex",
			"description": "Returns the value of the 3d image at the position specified by P."
	},
	"agentclipsampleworld: geometry prim clipname time": {
			"prefix": "agentclipsampleworld(geometry, prim, clipname, time)",
			"body": "agentclipsampleworld(${1:geometry}, ${2:prim}, ${3:clipname}, ${4:time})",
			"scope": "source.vex",
			"description": "Samples an agent\u2019s animation clip at a specific time."
	},
	"agentclipsampleworld: geometry prim clipname time transform": {
			"prefix": "agentclipsampleworld(geometry, prim, clipname, time, transform)",
			"body": "agentclipsampleworld(${1:geometry}, ${2:prim}, ${3:clipname}, ${4:time}, ${5:transform})",
			"scope": "source.vex",
			"description": "Samples an agent\u2019s animation clip at a specific time."
	},
	"usd_collectioncomputedpaths: stage collectionpath": {
			"prefix": "usd_collectioncomputedpaths(stage, collectionpath)",
			"body": "usd_collectioncomputedpaths(${1:stage}, ${2:collectionpath})",
			"scope": "source.vex",
			"description": "Obtains the list of all objects that belong to the collection"
	},
	"hedge_prim: geometry hedge": {
			"prefix": "hedge_prim(geometry, hedge)",
			"body": "hedge_prim(${1:geometry}, ${2:hedge})",
			"scope": "source.vex",
			"description": "Returns the primitive that contains a half-edge."
	},
	"sensor_panorama_getcone: handle lookodir angle colormin colormax depthmin depthmax strength dir color depth": {
			"prefix": "sensor_panorama_getcone(handle, lookodir, angle, colormin, colormax, depthmin, depthmax, strength, dir, color, depth)",
			"body": "sensor_panorama_getcone(${1:handle}, ${2:lookodir}, ${3:angle}, ${4:colormin}, ${5:colormax}, ${6:depthmin}, ${7:depthmax}, ${8:strength}, ${9:dir}, ${10:color}, ${11:depth})",
			"scope": "source.vex",
			"description": "Sensor function to query average values from rendered GL scene."
	},
	"lstrip: value": {
			"prefix": "lstrip(value)",
			"body": "lstrip(${1:value})",
			"scope": "source.vex",
			"description": "Strips leading whitespace from a string."
	},
	"lstrip: value whitespace": {
			"prefix": "lstrip(value, whitespace)",
			"body": "lstrip(${1:value}, ${2:whitespace})",
			"scope": "source.vex",
			"description": "Strips leading whitespace from a string."
	},
	"resolvemissedray: dir time mask ...": {
			"prefix": "resolvemissedray(dir, time, mask, ...)",
			"body": "resolvemissedray(${1:dir}, ${2:time}, ${3:mask}, ${4:...})",
			"scope": "source.vex",
			"description": "Returns the background color for rays that exit the scene."
	},
	"setattrib: geohandle attribclass attribute_name element_num vertex_num value mode": {
			"prefix": "setattrib(geohandle, attribclass, attribute_name, element_num, vertex_num, value, mode)",
			"body": "setattrib(${1:geohandle}, ${2:attribclass}, ${3:attribute_name}, ${4:element_num}, ${5:vertex_num}, ${6:value}, ${7:mode})",
			"scope": "source.vex",
			"description": "Writes an attribute value to geometry."
	},
	"hedge_srcpoint: geometry hedge": {
			"prefix": "hedge_srcpoint(geometry, hedge)",
			"body": "hedge_srcpoint(${1:geometry}, ${2:hedge})",
			"scope": "source.vex",
			"description": "Returns the source point of a half-edge."
	},
	"opend: handle": {
			"prefix": "opend(handle)",
			"body": "opend(${1:handle})",
			"scope": "source.vex",
			"description": "Ends a long operation."
	},
	"agenttransformgroupmember: geometry prim transformgroup transform": {
			"prefix": "agenttransformgroupmember(geometry, prim, transformgroup, transform)",
			"body": "agenttransformgroupmember(${1:geometry}, ${2:prim}, ${3:transformgroup}, ${4:transform})",
			"scope": "source.vex",
			"description": "Returns whether a transform is a member of the specified transform group."
	},
	"agenttransformgroupmember: geometry prim transformgroupidx transform": {
			"prefix": "agenttransformgroupmember(geometry, prim, transformgroupidx, transform)",
			"body": "agenttransformgroupmember(${1:geometry}, ${2:prim}, ${3:transformgroupidx}, ${4:transform})",
			"scope": "source.vex",
			"description": "Returns whether a transform is a member of the specified transform group."
	},
	"premul: a b": {
			"prefix": "premul(a, b)",
			"body": "premul(${1:a}, ${2:b})",
			"scope": "source.vex",
			"description": "Pre multiply matrices."
	},
	"premul: m a b": {
			"prefix": "premul(m, a, b)",
			"body": "premul(${1:m}, ${2:a}, ${3:b})",
			"scope": "source.vex",
			"description": "Pre multiply matrices."
	},
	"sleep: milliseconds": {
			"prefix": "sleep(milliseconds)",
			"body": "sleep(${1:milliseconds})",
			"scope": "source.vex",
			"description": "Yields processing for a certain number of milliseconds."
	},
	"ninputs: ": {
			"prefix": "ninputs()",
			"body": "ninputs()",
			"scope": "source.vex",
			"description": "Returns the number of inputs."
	},
	"bumpname: ": {
			"prefix": "bumpname()",
			"body": "bumpname()",
			"scope": "source.vex",
			"description": "Returns the default name of the bump plane (as it appears in the\ncompositor preferences)."
	},
	"dimport: name out": {
			"prefix": "dimport(name, out)",
			"body": "dimport(${1:name}, ${2:out})",
			"scope": "source.vex",
			"description": "Reads a variable from the displacement shader for the surface."
	},
	"addvertex: geohandle prim_num point_num": {
			"prefix": "addvertex(geohandle, prim_num, point_num)",
			"body": "addvertex(${1:geohandle}, ${2:prim_num}, ${3:point_num})",
			"scope": "source.vex",
			"description": "Adds a vertex to a primitive in a geometry."
	},
	"solvequadratic: a b c t1 t2": {
			"prefix": "solvequadratic(a, b, c, t1, t2)",
			"body": "solvequadratic(${1:a}, ${2:b}, ${3:c}, ${4:t1}, ${5:t2})",
			"scope": "source.vex",
			"description": "Solves a quadratic function returning the number of real roots."
	},
	"lookat: from to": {
			"prefix": "lookat(from, to)",
			"body": "lookat(${1:from}, ${2:to})",
			"scope": "source.vex",
			"description": "Computes a rotation matrix or angles to orient the z-axis along the vector\n(to-from) under the transformation."
	},
	"lookat: from to roll": {
			"prefix": "lookat(from, to, roll)",
			"body": "lookat(${1:from}, ${2:to}, ${3:roll})",
			"scope": "source.vex",
			"description": "Computes a rotation matrix or angles to orient the z-axis along the vector\n(to-from) under the transformation."
	},
	"lookat: from to up": {
			"prefix": "lookat(from, to, up)",
			"body": "lookat(${1:from}, ${2:to}, ${3:up})",
			"scope": "source.vex",
			"description": "Computes a rotation matrix or angles to orient the z-axis along the vector\n(to-from) under the transformation."
	},
	"lookat: from to roll xyz": {
			"prefix": "lookat(from, to, roll, xyz)",
			"body": "lookat(${1:from}, ${2:to}, ${3:roll}, ${4:xyz})",
			"scope": "source.vex",
			"description": "Computes a rotation matrix or angles to orient the z-axis along the vector\n(to-from) under the transformation."
	},
	"lookat: from to up xyz": {
			"prefix": "lookat(from, to, up, xyz)",
			"body": "lookat(${1:from}, ${2:to}, ${3:up}, ${4:xyz})",
			"scope": "source.vex",
			"description": "Computes a rotation matrix or angles to orient the z-axis along the vector\n(to-from) under the transformation."
	},
	"diffuse: ...": {
			"prefix": "diffuse(...)",
			"body": "diffuse(${1:...})",
			"scope": "source.vex",
			"description": "Returns a diffuse BSDF or computes diffuse shading."
	},
	"diffuse: roughness ...": {
			"prefix": "diffuse(roughness, ...)",
			"body": "diffuse(${1:roughness}, ${2:...})",
			"scope": "source.vex",
			"description": "Returns a diffuse BSDF or computes diffuse shading."
	},
	"diffuse: nml ...": {
			"prefix": "diffuse(nml, ...)",
			"body": "diffuse(${1:nml}, ${2:...})",
			"scope": "source.vex",
			"description": "Returns a diffuse BSDF or computes diffuse shading."
	},
	"diffuse: nml roughness ...": {
			"prefix": "diffuse(nml, roughness, ...)",
			"body": "diffuse(${1:nml}, ${2:roughness}, ${3:...})",
			"scope": "source.vex",
			"description": "Returns a diffuse BSDF or computes diffuse shading."
	},
	"diffuse: nml geo_normal ...": {
			"prefix": "diffuse(nml, geo_normal, ...)",
			"body": "diffuse(${1:nml}, ${2:geo_normal}, ${3:...})",
			"scope": "source.vex",
			"description": "Returns a diffuse BSDF or computes diffuse shading."
	},
	"diffuse: nml geo_normal roughness ...": {
			"prefix": "diffuse(nml, geo_normal, roughness, ...)",
			"body": "diffuse(${1:nml}, ${2:geo_normal}, ${3:roughness}, ${4:...})",
			"scope": "source.vex",
			"description": "Returns a diffuse BSDF or computes diffuse shading."
	},
	"diffuse: nml V roughness ...": {
			"prefix": "diffuse(nml, V, roughness, ...)",
			"body": "diffuse(${1:nml}, ${2:V}, ${3:roughness}, ${4:...})",
			"scope": "source.vex",
			"description": "Returns a diffuse BSDF or computes diffuse shading."
	},
	"trunc: x": {
			"prefix": "trunc(x)",
			"body": "trunc(${1:x})",
			"scope": "source.vex",
			"description": "Removes the fractional part of a floating point number."
	},
	"usd_setcollectionexpansionrule: stagehandle collectionpath rule": {
			"prefix": "usd_setcollectionexpansionrule(stagehandle, collectionpath, rule)",
			"body": "usd_setcollectionexpansionrule(${1:stagehandle}, ${2:collectionpath}, ${3:rule})",
			"scope": "source.vex",
			"description": "Sets the expansion rule on the collection"
	},
	"usd_pointinstance_getbbox_max: stage primpath instance_index purpose": {
			"prefix": "usd_pointinstance_getbbox_max(stage, primpath, instance_index, purpose)",
			"body": "usd_pointinstance_getbbox_max(${1:stage}, ${2:primpath}, ${3:instance_index}, ${4:purpose})",
			"scope": "source.vex",
			"description": "Returns the maximum position of the bounding box for the instance inside a point instancer primitive."
	},
	"primattribtype: geometry attribute_name": {
			"prefix": "primattribtype(geometry, attribute_name)",
			"body": "primattribtype(${1:geometry}, ${2:attribute_name})",
			"scope": "source.vex",
			"description": "Returns the type of a geometry prim attribute."
	},
	"iplaneindex: opinput planename": {
			"prefix": "iplaneindex(opinput, planename)",
			"body": "iplaneindex(${1:opinput}, ${2:planename})",
			"scope": "source.vex",
			"description": "Returns the index of the plane named 'planename' in the specified input."
	},
	"solveconstraint: lengths targetpos tolerance relmat constraints": {
			"prefix": "solveconstraint(lengths, targetpos, tolerance, relmat, constraints)",
			"body": "solveconstraint(${1:lengths}, ${2:targetpos}, ${3:tolerance}, ${4:relmat}, ${5:constraints})",
			"scope": "source.vex",
			"description": "Applies an inverse kinematics algorithm to a skeleton."
	},
	"ocio_parsecolorspace: input": {
			"prefix": "ocio_parsecolorspace(input)",
			"body": "ocio_parsecolorspace(${1:input})",
			"scope": "source.vex",
			"description": "Parse the color space from a string"
	},
	"pcopen: filename channel shaded ...": {
			"prefix": "pcopen(filename, channel, shaded, ...)",
			"body": "pcopen(${1:filename}, ${2:channel}, ${3:shaded}, ${4:...})",
			"scope": "source.vex",
			"description": "Returns a handle to a point cloud file."
	},
	"pcopen: filename Pchannel P radius maxpoints ...": {
			"prefix": "pcopen(filename, Pchannel, P, radius, maxpoints, ...)",
			"body": "pcopen(${1:filename}, ${2:Pchannel}, ${3:P}, ${4:radius}, ${5:maxpoints}, ${6:...})",
			"scope": "source.vex",
			"description": "Returns a handle to a point cloud file."
	},
	"pcopen: filename Pchannel P Nchannel N radius maxpoints ...": {
			"prefix": "pcopen(filename, Pchannel, P, Nchannel, N, radius, maxpoints, ...)",
			"body": "pcopen(${1:filename}, ${2:Pchannel}, ${3:P}, ${4:Nchannel}, ${5:N}, ${6:radius}, ${7:maxpoints}, ${8:...})",
			"scope": "source.vex",
			"description": "Returns a handle to a point cloud file."
	},
	"pcopen: opinput Pchannel P radius maxpoints": {
			"prefix": "pcopen(opinput, Pchannel, P, radius, maxpoints)",
			"body": "pcopen(${1:opinput}, ${2:Pchannel}, ${3:P}, ${4:radius}, ${5:maxpoints})",
			"scope": "source.vex",
			"description": "Returns a handle to a point cloud file."
	},
	"agentclipweights: geometry prim": {
			"prefix": "agentclipweights(geometry, prim)",
			"body": "agentclipweights(${1:geometry}, ${2:prim})",
			"scope": "source.vex",
			"description": "Returns the blend weights for an agent primitive\u2019s animation clips."
	},
	"uvintersect: geometry uvname orig dir pos primuv": {
			"prefix": "uvintersect(geometry, uvname, orig, dir, pos, primuv)",
			"body": "uvintersect(${1:geometry}, ${2:uvname}, ${3:orig}, ${4:dir}, ${5:pos}, ${6:primuv})",
			"scope": "source.vex",
			"description": "This function computes the intersection of the specified ray with the geometry in uv space."
	},
	"uvintersect: geometry primgroup uvname orig dir pos primuv": {
			"prefix": "uvintersect(geometry, primgroup, uvname, orig, dir, pos, primuv)",
			"body": "uvintersect(${1:geometry}, ${2:primgroup}, ${3:uvname}, ${4:orig}, ${5:dir}, ${6:pos}, ${7:primuv})",
			"scope": "source.vex",
			"description": "This function computes the intersection of the specified ray with the geometry in uv space."
	},
	"vertex: geometry attribute_name linear_vertex_index": {
			"prefix": "vertex(geometry, attribute_name, linear_vertex_index)",
			"body": "vertex(${1:geometry}, ${2:attribute_name}, ${3:linear_vertex_index})",
			"scope": "source.vex",
			"description": "Reads a vertex attribute value from a geometry."
	},
	"vertex: geometry attribute_name prim_num vertex_num": {
			"prefix": "vertex(geometry, attribute_name, prim_num, vertex_num)",
			"body": "vertex(${1:geometry}, ${2:attribute_name}, ${3:prim_num}, ${4:vertex_num})",
			"scope": "source.vex",
			"description": "Reads a vertex attribute value from a geometry."
	},
	"hedge_isequiv: geometry hedge1 hedge2": {
			"prefix": "hedge_isequiv(geometry, hedge1, hedge2)",
			"body": "hedge_isequiv(${1:geometry}, ${2:hedge1}, ${3:hedge2})",
			"scope": "source.vex",
			"description": "Determines whether a two half-edges are equivalent (represent the same edge)."
	},
	"combinelocaltransform: local parent_world parent_local mode": {
			"prefix": "combinelocaltransform(local, parent_world, parent_local, mode)",
			"body": "combinelocaltransform(${1:local}, ${2:parent_world}, ${3:parent_local}, ${4:mode})",
			"scope": "source.vex",
			"description": "Combines Local and Parent Transforms with Scale Inheritance."
	},
	"vtransform: v transform": {
			"prefix": "vtransform(v, transform)",
			"body": "vtransform(${1:v}, ${2:transform})",
			"scope": "source.vex",
			"description": "Transforms a directional vector."
	},
	"vtransform: tospace v": {
			"prefix": "vtransform(tospace, v)",
			"body": "vtransform(${1:tospace}, ${2:v})",
			"scope": "source.vex",
			"description": "Transforms a directional vector."
	},
	"vtransform: fromspace tospace v": {
			"prefix": "vtransform(fromspace, tospace, v)",
			"body": "vtransform(${1:fromspace}, ${2:tospace}, ${3:v})",
			"scope": "source.vex",
			"description": "Transforms a directional vector."
	},
	"dot: a b": {
			"prefix": "dot(a, b)",
			"body": "dot(${1:a}, ${2:b})",
			"scope": "source.vex",
			"description": "Returns the dot product between the arguments."
	},
	"chv: channel": {
			"prefix": "chv(channel)",
			"body": "chv(${1:channel})",
			"scope": "source.vex",
			"description": "Evaluates a channel or parameter, and return its value."
	},
	"chv: channel time": {
			"prefix": "chv(channel, time)",
			"body": "chv(${1:channel}, ${2:time})",
			"scope": "source.vex",
			"description": "Evaluates a channel or parameter, and return its value."
	},
	"chv: opid pid": {
			"prefix": "chv(opid, pid)",
			"body": "chv(${1:opid}, ${2:pid})",
			"scope": "source.vex",
			"description": "Evaluates a channel or parameter, and return its value."
	},
	"chv: opid pid time": {
			"prefix": "chv(opid, pid, time)",
			"body": "chv(${1:opid}, ${2:pid}, ${3:time})",
			"scope": "source.vex",
			"description": "Evaluates a channel or parameter, and return its value."
	},
	"uvdist: geometry uvname uv prim primuv": {
			"prefix": "uvdist(geometry, uvname, uv, prim, primuv)",
			"body": "uvdist(${1:geometry}, ${2:uvname}, ${3:uv}, ${4:prim}, ${5:primuv})",
			"scope": "source.vex",
			"description": "Finds the distance of a uv coordinate to a geometry in uv space."
	},
	"uvdist: geometry uvname uv prim primuv maxdist": {
			"prefix": "uvdist(geometry, uvname, uv, prim, primuv, maxdist)",
			"body": "uvdist(${1:geometry}, ${2:uvname}, ${3:uv}, ${4:prim}, ${5:primuv}, ${6:maxdist})",
			"scope": "source.vex",
			"description": "Finds the distance of a uv coordinate to a geometry in uv space."
	},
	"uvdist: geometry primgroup uvname uv prim primuv": {
			"prefix": "uvdist(geometry, primgroup, uvname, uv, prim, primuv)",
			"body": "uvdist(${1:geometry}, ${2:primgroup}, ${3:uvname}, ${4:uv}, ${5:prim}, ${6:primuv})",
			"scope": "source.vex",
			"description": "Finds the distance of a uv coordinate to a geometry in uv space."
	},
	"uvdist: geometry primgroup uvname uv prim primuv maxdist": {
			"prefix": "uvdist(geometry, primgroup, uvname, uv, prim, primuv, maxdist)",
			"body": "uvdist(${1:geometry}, ${2:primgroup}, ${3:uvname}, ${4:uv}, ${5:prim}, ${6:primuv}, ${7:maxdist})",
			"scope": "source.vex",
			"description": "Finds the distance of a uv coordinate to a geometry in uv space."
	},
	"shrz: a bits": {
			"prefix": "shrz(a, bits)",
			"body": "shrz(${1:a}, ${2:bits})",
			"scope": "source.vex",
			"description": "Bit-shifts an integer right."
	},
	"rotate_x_to: direction v": {
			"prefix": "rotate_x_to(direction, v)",
			"body": "rotate_x_to(${1:direction}, ${2:v})",
			"scope": "source.vex",
			"description": "Rotates a vector by a rotation that would bring the x-axis to a given direction."
	},
	"re_split: regex input maxsplits": {
			"prefix": "re_split(regex, input, maxsplits)",
			"body": "re_split(${1:regex}, ${2:input}, ${3:maxsplits})",
			"scope": "source.vex",
			"description": "Splits the given string based on regex match."
	},
	"sample_cauchy: u": {
			"prefix": "sample_cauchy(u)",
			"body": "sample_cauchy(${1:u})",
			"scope": "source.vex",
			"description": "Samples the Cauchy (Lorentz) distribution."
	},
	"sample_cauchy: scale u": {
			"prefix": "sample_cauchy(scale, u)",
			"body": "sample_cauchy(${1:scale}, ${2:u})",
			"scope": "source.vex",
			"description": "Samples the Cauchy (Lorentz) distribution."
	},
	"sample_cauchy: origscale minvalue maxvalue u": {
			"prefix": "sample_cauchy(origscale, minvalue, maxvalue, u)",
			"body": "sample_cauchy(${1:origscale}, ${2:minvalue}, ${3:maxvalue}, ${4:u})",
			"scope": "source.vex",
			"description": "Samples the Cauchy (Lorentz) distribution."
	},
	"relbbox: geometry position": {
			"prefix": "relbbox(geometry, position)",
			"body": "relbbox(${1:geometry}, ${2:position})",
			"scope": "source.vex",
			"description": "Returns the relative position of the point given with respect to the bounding box of the geometry."
	},
	"relbbox: geometry primgroup position": {
			"prefix": "relbbox(geometry, primgroup, position)",
			"body": "relbbox(${1:geometry}, ${2:primgroup}, ${3:position})",
			"scope": "source.vex",
			"description": "Returns the relative position of the point given with respect to the bounding box of the geometry."
	},
	"relbbox: position": {
			"prefix": "relbbox(position)",
			"body": "relbbox(${1:position})",
			"scope": "source.vex",
			"description": "Returns the relative position of the point given with respect to the bounding box of the geometry."
	},
	"primattribsize: geometry attribute_name": {
			"prefix": "primattribsize(geometry, attribute_name)",
			"body": "primattribsize(${1:geometry}, ${2:attribute_name})",
			"scope": "source.vex",
			"description": "Returns the size of a geometry prim attribute."
	},
	"usd_setprimvarelement: stagehandle primpath name index value": {
			"prefix": "usd_setprimvarelement(stagehandle, primpath, name, index, value)",
			"body": "usd_setprimvarelement(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:index}, ${5:value})",
			"scope": "source.vex",
			"description": "Sets the value of an element in an array primvar."
	},
	"pack_inttosafefloat: i": {
			"prefix": "pack_inttosafefloat(i)",
			"body": "pack_inttosafefloat(${1:i})",
			"scope": "source.vex",
			"description": "Reversibly packs an integer into a finite, non-denormal float."
	},
	"sample_sphere_uniform: u": {
			"prefix": "sample_sphere_uniform(u)",
			"body": "sample_sphere_uniform(${1:u})",
			"scope": "source.vex",
			"description": "Generates a uniform vector with length < 1, given a vector of uniform numbers between 0 and 1."
	},
	"usd_setvisible: stagehandle primpath flag": {
			"prefix": "usd_setvisible(stagehandle, primpath, flag)",
			"body": "usd_setvisible(${1:stagehandle}, ${2:primpath}, ${3:flag})",
			"scope": "source.vex",
			"description": "Sets the primitive visibility."
	},
	"osd_lookupface: geometry patch_id patch_u patch_v face_id face_u face_v": {
			"prefix": "osd_lookupface(geometry, patch_id, patch_u, patch_v, face_id, face_u, face_v)",
			"body": "osd_lookupface(${1:geometry}, ${2:patch_id}, ${3:patch_u}, ${4:patch_v}, ${5:face_id}, ${6:face_u}, ${7:face_v})",
			"scope": "source.vex",
			"description": "Outputs the Houdini face and UV coordinates corresponding to the given coordinates on an OSD patch."
	},
	"osd_lookupface: geometry patch_id patch_u patch_v face_id face_u face_v attribute": {
			"prefix": "osd_lookupface(geometry, patch_id, patch_u, patch_v, face_id, face_u, face_v, attribute)",
			"body": "osd_lookupface(${1:geometry}, ${2:patch_id}, ${3:patch_u}, ${4:patch_v}, ${5:face_id}, ${6:face_u}, ${7:face_v}, ${8:attribute})",
			"scope": "source.vex",
			"description": "Outputs the Houdini face and UV coordinates corresponding to the given coordinates on an OSD patch."
	},
	"removepoint: geohandle point_number": {
			"prefix": "removepoint(geohandle, point_number)",
			"body": "removepoint(${1:geohandle}, ${2:point_number})",
			"scope": "source.vex",
			"description": "Removes a point from the geometry."
	},
	"removepoint: geohandle point_number and_prims": {
			"prefix": "removepoint(geohandle, point_number, and_prims)",
			"body": "removepoint(${1:geohandle}, ${2:point_number}, ${3:and_prims})",
			"scope": "source.vex",
			"description": "Removes a point from the geometry."
	},
	"planepointdistance: plane_pos plane_normal point_pos intersect_pos": {
			"prefix": "planepointdistance(plane_pos, plane_normal, point_pos, intersect_pos)",
			"body": "planepointdistance(${1:plane_pos}, ${2:plane_normal}, ${3:point_pos}, ${4:intersect_pos})",
			"scope": "source.vex",
			"description": "Computes the distance and closest point of a point to an infinite plane."
	},
	"removevalue: array value": {
			"prefix": "removevalue(array, value)",
			"body": "removevalue(${1:array}, ${2:value})",
			"scope": "source.vex",
			"description": "Removes an item from an array."
	},
	"albedo: b ...": {
			"prefix": "albedo(b, ...)",
			"body": "albedo(${1:b}, ${2:...})",
			"scope": "source.vex",
			"description": "Returns the albedo (percentage of reflected light) for a bsdf given the outgoing light direction."
	},
	"albedo: b mask ...": {
			"prefix": "albedo(b, mask, ...)",
			"body": "albedo(${1:b}, ${2:mask}, ${3:...})",
			"scope": "source.vex",
			"description": "Returns the albedo (percentage of reflected light) for a bsdf given the outgoing light direction."
	},
	"albedo: b viewer ...": {
			"prefix": "albedo(b, viewer, ...)",
			"body": "albedo(${1:b}, ${2:viewer}, ${3:...})",
			"scope": "source.vex",
			"description": "Returns the albedo (percentage of reflected light) for a bsdf given the outgoing light direction."
	},
	"albedo: b viewer mask ...": {
			"prefix": "albedo(b, viewer, mask, ...)",
			"body": "albedo(${1:b}, ${2:viewer}, ${3:mask}, ${4:...})",
			"scope": "source.vex",
			"description": "Returns the albedo (percentage of reflected light) for a bsdf given the outgoing light direction."
	},
	"primattribtypeinfo: geometry attribute_name": {
			"prefix": "primattribtypeinfo(geometry, attribute_name)",
			"body": "primattribtypeinfo(${1:geometry}, ${2:attribute_name})",
			"scope": "source.vex",
			"description": "Returns the type info of a geometry attribute."
	},
	"spline: basis sample_pos value1 ...": {
			"prefix": "spline(basis, sample_pos, value1, ...)",
			"body": "spline(${1:basis}, ${2:sample_pos}, ${3:value1}, ${4:...})",
			"scope": "source.vex",
			"description": "Samples a value along a polyline or spline curve."
	},
	"spline: basis sample_pos values ...": {
			"prefix": "spline(basis, sample_pos, values, ...)",
			"body": "spline(${1:basis}, ${2:sample_pos}, ${3:values}, ${4:...})",
			"scope": "source.vex",
			"description": "Samples a value along a polyline or spline curve."
	},
	"spline: bases sample_pos values ...": {
			"prefix": "spline(bases, sample_pos, values, ...)",
			"body": "spline(${1:bases}, ${2:sample_pos}, ${3:values}, ${4:...})",
			"scope": "source.vex",
			"description": "Samples a value along a polyline or spline curve."
	},
	"spline: bases sample_pos values positions ...": {
			"prefix": "spline(bases, sample_pos, values, positions, ...)",
			"body": "spline(${1:bases}, ${2:sample_pos}, ${3:values}, ${4:positions}, ${5:...})",
			"scope": "source.vex",
			"description": "Samples a value along a polyline or spline curve."
	},
	"usd_setattribelement: stagehandle primpath name index value": {
			"prefix": "usd_setattribelement(stagehandle, primpath, name, index, value)",
			"body": "usd_setattribelement(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:index}, ${5:value})",
			"scope": "source.vex",
			"description": "Sets the value of an element in an array attribute."
	},
	"product: n": {
			"prefix": "product(n)",
			"body": "product(${1:n})",
			"scope": "source.vex",
			"description": "Returns the product of a list of numbers."
	},
	"product: v": {
			"prefix": "product(v)",
			"body": "product(${1:v})",
			"scope": "source.vex",
			"description": "Returns the product of a list of numbers."
	},
	"product: arr": {
			"prefix": "product(arr)",
			"body": "product(${1:arr})",
			"scope": "source.vex",
			"description": "Returns the product of a list of numbers."
	},
	"getbbox_max: geometry": {
			"prefix": "getbbox_max(geometry)",
			"body": "getbbox_max(${1:geometry})",
			"scope": "source.vex",
			"description": "Returns the maximum of the bounding box for the geometry."
	},
	"getbbox_max: geometry primgroup": {
			"prefix": "getbbox_max(geometry, primgroup)",
			"body": "getbbox_max(${1:geometry}, ${2:primgroup})",
			"scope": "source.vex",
			"description": "Returns the maximum of the bounding box for the geometry."
	},
	"isseconds: ": {
			"prefix": "isseconds()",
			"body": "isseconds()",
			"scope": "source.vex",
			"description": "Returns 1 if the Vex CHOP\u2019s Unit Menu is currently set to 'seconds',\n0 otherwise."
	},
	"nverticesgroup: geometry groupname": {
			"prefix": "nverticesgroup(geometry, groupname)",
			"body": "nverticesgroup(${1:geometry}, ${2:groupname})",
			"scope": "source.vex",
			"description": "Returns the number of vertices in the group."
	},
	"uniqueval: geometry attribclass attribute_name which": {
			"prefix": "uniqueval(geometry, attribclass, attribute_name, which)",
			"body": "uniqueval(${1:geometry}, ${2:attribclass}, ${3:attribute_name}, ${4:which})",
			"scope": "source.vex",
			"description": "Returns one of the set of unique values across all values for an int or string attribute."
	},
	"usd_collectioncontains: stage collectionpath path": {
			"prefix": "usd_collectioncontains(stage, collectionpath, path)",
			"body": "usd_collectioncontains(${1:stage}, ${2:collectionpath}, ${3:path})",
			"scope": "source.vex",
			"description": "Checks if an object path belongs to the collection"
	},
	"ow_vspace: v": {
			"prefix": "ow_vspace(v)",
			"body": "ow_vspace(${1:v})",
			"scope": "source.vex",
			"description": "Transforms a direction vector from Object to World space."
	},
	"usd_istransformreset: stage primpath": {
			"prefix": "usd_istransformreset(stage, primpath)",
			"body": "usd_istransformreset(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Checks if the primitive transform is reset"
	},
	"unpack_intfromsafefloat: f": {
			"prefix": "unpack_intfromsafefloat(f)",
			"body": "unpack_intfromsafefloat(${1:f})",
			"scope": "source.vex",
			"description": "Reverses the packing of pack_inttosafefloat to get back the original integer."
	},
	"fuzzy_not: n": {
			"prefix": "fuzzy_not(n)",
			"body": "fuzzy_not(${1:n})",
			"scope": "source.vex",
			"description": ""
	},
	"setvertexgroup: geohandle name prim_num vertex_num value mode": {
			"prefix": "setvertexgroup(geohandle, name, prim_num, vertex_num, value, mode)",
			"body": "setvertexgroup(${1:geohandle}, ${2:name}, ${3:prim_num}, ${4:vertex_num}, ${5:value}, ${6:mode})",
			"scope": "source.vex",
			"description": "Adds or removes a vertex to/from a group in a geometry."
	},
	"lkspline: sample_pos value1 key_pos1 ...": {
			"prefix": "lkspline(sample_pos, value1, key_pos1, ...)",
			"body": "lkspline(${1:sample_pos}, ${2:value1}, ${3:key_pos1}, ${4:...})",
			"scope": "source.vex",
			"description": "Samples a polyline between the key points."
	},
	"detail: geometry attribute_name ignored": {
			"prefix": "detail(geometry, attribute_name, ignored)",
			"body": "detail(${1:geometry}, ${2:attribute_name}, ${3:ignored})",
			"scope": "source.vex",
			"description": "Reads the value of a detail attribute value from a geometry."
	},
	"shadow_light: lightid pos dir time ...": {
			"prefix": "shadow_light(lightid, pos, dir, time, ...)",
			"body": "shadow_light(${1:lightid}, ${2:pos}, ${3:dir}, ${4:time}, ${5:...})",
			"scope": "source.vex",
			"description": "Executes the shadow shader for a given light and returns the amount of shadowing as a multiplier of the shaded color."
	},
	"outerproduct: v v": {
			"prefix": "outerproduct(v, v)",
			"body": "outerproduct(${1:v}, ${2:v})",
			"scope": "source.vex",
			"description": "Returns the outer product between the arguments."
	},
	"getlightid: lightname": {
			"prefix": "getlightid(lightname)",
			"body": "getlightid(${1:lightname})",
			"scope": "source.vex",
			"description": "Returns the light id for a named light (or -1 for an invalid name)."
	},
	"usd_addattrib: stagehandle primpath name typename": {
			"prefix": "usd_addattrib(stagehandle, primpath, name, typename)",
			"body": "usd_addattrib(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:typename})",
			"scope": "source.vex",
			"description": "Creates an attribute of a given type on a primitive."
	},
	"length: f": {
			"prefix": "length(f)",
			"body": "length(${1:f})",
			"scope": "source.vex",
			"description": "Returns the magnitude of a vector."
	},
	"length: v": {
			"prefix": "length(v)",
			"body": "length(${1:v})",
			"scope": "source.vex",
			"description": "Returns the magnitude of a vector."
	},
	"limport: name value": {
			"prefix": "limport(name, value)",
			"body": "limport(${1:name}, ${2:value})",
			"scope": "source.vex",
			"description": "Imports a variable from the light shader for the surface."
	},
	"sample_exponential: u": {
			"prefix": "sample_exponential(u)",
			"body": "sample_exponential(${1:u})",
			"scope": "source.vex",
			"description": "Samples the exponential distribution."
	},
	"sample_exponential: mean u": {
			"prefix": "sample_exponential(mean, u)",
			"body": "sample_exponential(${1:mean}, ${2:u})",
			"scope": "source.vex",
			"description": "Samples the exponential distribution."
	},
	"sample_exponential: origmean maxvalue u": {
			"prefix": "sample_exponential(origmean, maxvalue, u)",
			"body": "sample_exponential(${1:origmean}, ${2:maxvalue}, ${3:u})",
			"scope": "source.vex",
			"description": "Samples the exponential distribution."
	},
	"fit01: value nmin nmax": {
			"prefix": "fit01(value, nmin, nmax)",
			"body": "fit01(${1:value}, ${2:nmin}, ${3:nmax})",
			"scope": "source.vex",
			"description": "Takes the value in the range (0, 1) and shifts it to the corresponding value in a new range."
	},
	"getlight: lid": {
			"prefix": "getlight(lid)",
			"body": "getlight(${1:lid})",
			"scope": "source.vex",
			"description": "Returns a light struct for the specified light identifier."
	},
	"inpointgroup: geometry groupname pointnum": {
			"prefix": "inpointgroup(geometry, groupname, pointnum)",
			"body": "inpointgroup(${1:geometry}, ${2:groupname}, ${3:pointnum})",
			"scope": "source.vex",
			"description": "Returns 1 if the point specified by the point number is in the group specified by the string."
	},
	"cwnoise: position seed f1 f2": {
			"prefix": "cwnoise(position, seed, f1, f2)",
			"body": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Chebyshev distance metric."
	},
	"cwnoise: position seed f1 f2 f3 f4": {
			"prefix": "cwnoise(position, seed, f1, f2, f3, f4)",
			"body": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Chebyshev distance metric."
	},
	"cwnoise: position seed f1 f2 peiod": {
			"prefix": "cwnoise(position, seed, f1, f2, peiod)",
			"body": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:peiod})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Chebyshev distance metric."
	},
	"cwnoise: position seed f1 f2 f4 f4 period": {
			"prefix": "cwnoise(position, seed, f1, f2, f4, f4, period)",
			"body": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f4}, ${6:f4}, ${7:period})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Chebyshev distance metric."
	},
	"cwnoise: posx posy seed f1 f2": {
			"prefix": "cwnoise(posx, posy, seed, f1, f2)",
			"body": "cwnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Chebyshev distance metric."
	},
	"cwnoise: posx posy seed f1 f2 f3 f4": {
			"prefix": "cwnoise(posx, posy, seed, f1, f2, f3, f4)",
			"body": "cwnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:f3}, ${7:f4})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Chebyshev distance metric."
	},
	"cwnoise: posx posy seed f1 f2 periodx periody": {
			"prefix": "cwnoise(posx, posy, seed, f1, f2, periodx, periody)",
			"body": "cwnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:periodx}, ${7:periody})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Chebyshev distance metric."
	},
	"cwnoise: posx posy seed f1 f2 f3 f4 periodx periody": {
			"prefix": "cwnoise(posx, posy, seed, f1, f2, f3, f4, periodx, periody)",
			"body": "cwnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:f3}, ${7:f4}, ${8:periodx}, ${9:periody})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Chebyshev distance metric."
	},
	"cwnoise: position seed f1 f2 periodx periody": {
			"prefix": "cwnoise(position, seed, f1, f2, periodx, periody)",
			"body": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:periodx}, ${6:periody})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Chebyshev distance metric."
	},
	"cwnoise: position seed f1 f2 f3 f4 periodx periody": {
			"prefix": "cwnoise(position, seed, f1, f2, f3, f4, periodx, periody)",
			"body": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4}, ${7:periodx}, ${8:periody})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Chebyshev distance metric."
	},
	"cwnoise: position seed f1 f2 periodx periody periodx": {
			"prefix": "cwnoise(position, seed, f1, f2, periodx, periody, periodx)",
			"body": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:periodx}, ${6:periody}, ${7:periodx})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Chebyshev distance metric."
	},
	"cwnoise: position seed f1 f2 f3 f4 periodx periody periodz": {
			"prefix": "cwnoise(position, seed, f1, f2, f3, f4, periodx, periody, periodz)",
			"body": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4}, ${7:periodx}, ${8:periody}, ${9:periodz})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Chebyshev distance metric."
	},
	"cwnoise: position seed f1 f2 periodx periody periodz periodw": {
			"prefix": "cwnoise(position, seed, f1, f2, periodx, periody, periodz, periodw)",
			"body": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:periodx}, ${6:periody}, ${7:periodz}, ${8:periodw})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Chebyshev distance metric."
	},
	"cwnoise: position seed f1 f2 f3 f4 periodx periody periodz periodw": {
			"prefix": "cwnoise(position, seed, f1, f2, f3, f4, periodx, periody, periodz, periodw)",
			"body": "cwnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4}, ${7:periodx}, ${8:periody}, ${9:periodz}, ${10:periodw})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise using a Chebyshev distance metric."
	},
	"scatter: ipoint inormal idirection idistribution time maxdist opoint onormal odirection": {
			"prefix": "scatter(ipoint, inormal, idirection, idistribution, time, maxdist, opoint, onormal, odirection)",
			"body": "scatter(${1:ipoint}, ${2:inormal}, ${3:idirection}, ${4:idistribution}, ${5:time}, ${6:maxdist}, ${7:opoint}, ${8:onormal}, ${9:odirection})",
			"scope": "source.vex",
			"description": "Evaluates a scattering event through the domain of a geometric object."
	},
	"resize: array size": {
			"prefix": "resize(array, size)",
			"body": "resize(${1:array}, ${2:size})",
			"scope": "source.vex",
			"description": "Sets the length of an array."
	},
	"usd_isarrayprimvar: stage primpath name": {
			"prefix": "usd_isarrayprimvar(stage, primpath, name)",
			"body": "usd_isarrayprimvar(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Checks if the primvar is an array."
	},
	"findattribvalcount: geometry attribclass attribute_name value": {
			"prefix": "findattribvalcount(geometry, attribclass, attribute_name, value)",
			"body": "findattribvalcount(${1:geometry}, ${2:attribclass}, ${3:attribute_name}, ${4:value})",
			"scope": "source.vex",
			"description": "Returns number of elements where an integer or string attribute has a certain value."
	},
	"sqrt: value": {
			"prefix": "sqrt(value)",
			"body": "sqrt(${1:value})",
			"scope": "source.vex",
			"description": "Returns the square root of the argument."
	},
	"chstartt: ": {
			"prefix": "chstartt()",
			"body": "chstartt()",
			"scope": "source.vex",
			"description": "Returns the time corresponding to the first sample of the input\nspecified."
	},
	"chstartt: opinput": {
			"prefix": "chstartt(opinput)",
			"body": "chstartt(${1:opinput})",
			"scope": "source.vex",
			"description": "Returns the time corresponding to the first sample of the input\nspecified."
	},
	"primuv: geometry attribute_name prim_num uvw": {
			"prefix": "primuv(geometry, attribute_name, prim_num, uvw)",
			"body": "primuv(${1:geometry}, ${2:attribute_name}, ${3:prim_num}, ${4:uvw})",
			"scope": "source.vex",
			"description": "Interpolates the value of an attribute at a certain parametric (uvw) position."
	},
	"sample_photon: lp pos dir scale time": {
			"prefix": "sample_photon(lp, pos, dir, scale, time)",
			"body": "sample_photon(${1:lp}, ${2:pos}, ${3:dir}, ${4:scale}, ${5:time})",
			"scope": "source.vex",
			"description": "Samples a 3D position on a light source and runs the light shader at that point."
	},
	"select: conditional a b": {
			"prefix": "select(conditional, a, b)",
			"body": "select(${1:conditional}, ${2:a}, ${3:b})",
			"scope": "source.vex",
			"description": "Returns one of two parameters based on a conditional."
	},
	"sum: n": {
			"prefix": "sum(n)",
			"body": "sum(${1:n})",
			"scope": "source.vex",
			"description": "Returns the sum of a list of numbers."
	},
	"sum: v": {
			"prefix": "sum(v)",
			"body": "sum(${1:v})",
			"scope": "source.vex",
			"description": "Returns the sum of a list of numbers."
	},
	"sum: nums": {
			"prefix": "sum(nums)",
			"body": "sum(${1:nums})",
			"scope": "source.vex",
			"description": "Returns the sum of a list of numbers."
	},
	"sum: arr": {
			"prefix": "sum(arr)",
			"body": "sum(${1:arr})",
			"scope": "source.vex",
			"description": "Returns the sum of a list of numbers."
	},
	"pccone_radius: geometry PChannel RadChannel radscale P dir angle max_distance maxpoints": {
			"prefix": "pccone_radius(geometry, PChannel, RadChannel, radscale, P, dir, angle, max_distance, maxpoints)",
			"body": "pccone_radius(${1:geometry}, ${2:PChannel}, ${3:RadChannel}, ${4:radscale}, ${5:P}, ${6:dir}, ${7:angle}, ${8:max_distance}, ${9:maxpoints})",
			"scope": "source.vex",
			"description": "Returns a list of closest points from a file in a cone, taking into account their radii"
	},
	"pccone_radius: geometry ptgroup PChannel RadChannel radscale P dir angle max_distance maxpoints": {
			"prefix": "pccone_radius(geometry, ptgroup, PChannel, RadChannel, radscale, P, dir, angle, max_distance, maxpoints)",
			"body": "pccone_radius(${1:geometry}, ${2:ptgroup}, ${3:PChannel}, ${4:RadChannel}, ${5:radscale}, ${6:P}, ${7:dir}, ${8:angle}, ${9:max_distance}, ${10:maxpoints})",
			"scope": "source.vex",
			"description": "Returns a list of closest points from a file in a cone, taking into account their radii"
	},
	"chremove: channel_index": {
			"prefix": "chremove(channel_index)",
			"body": "chremove(${1:channel_index})",
			"scope": "source.vex",
			"description": "Removes channels from a CHOP node."
	},
	"chremove: channel_indices": {
			"prefix": "chremove(channel_indices)",
			"body": "chremove(${1:channel_indices})",
			"scope": "source.vex",
			"description": "Removes channels from a CHOP node."
	},
	"chremove: channel_name": {
			"prefix": "chremove(channel_name)",
			"body": "chremove(${1:channel_name})",
			"scope": "source.vex",
			"description": "Removes channels from a CHOP node."
	},
	"chremove: channel_names": {
			"prefix": "chremove(channel_names)",
			"body": "chremove(${1:channel_names})",
			"scope": "source.vex",
			"description": "Removes channels from a CHOP node."
	},
	"agenttransformgroupweight: geometry prim transformgroup transform": {
			"prefix": "agenttransformgroupweight(geometry, prim, transformgroup, transform)",
			"body": "agenttransformgroupweight(${1:geometry}, ${2:prim}, ${3:transformgroup}, ${4:transform})",
			"scope": "source.vex",
			"description": "Returns the weight of a member of the specified transform group."
	},
	"uvsample: geometry attr_name uv_attr_name uvw": {
			"prefix": "uvsample(geometry, attr_name, uv_attr_name, uvw)",
			"body": "uvsample(${1:geometry}, ${2:attr_name}, ${3:uv_attr_name}, ${4:uvw})",
			"scope": "source.vex",
			"description": "Interpolates the value of an attribute at certain UV coordinates using a UV attribute."
	},
	"uvsample: geometry primgroup attr_name uv_attr_name uvw": {
			"prefix": "uvsample(geometry, primgroup, attr_name, uv_attr_name, uvw)",
			"body": "uvsample(${1:geometry}, ${2:primgroup}, ${3:attr_name}, ${4:uv_attr_name}, ${5:uvw})",
			"scope": "source.vex",
			"description": "Interpolates the value of an attribute at certain UV coordinates using a UV attribute."
	},
	"chendf: opinput": {
			"prefix": "chendf(opinput)",
			"body": "chendf(${1:opinput})",
			"scope": "source.vex",
			"description": "Returns the frame corresponding to the last sample of the input specified."
	},
	"npoints: geometry": {
			"prefix": "npoints(geometry)",
			"body": "npoints(${1:geometry})",
			"scope": "source.vex",
			"description": "Returns the number of points in the input or geometry file."
	},
	"hedge_prev: geometry hedge": {
			"prefix": "hedge_prev(geometry, hedge)",
			"body": "hedge_prev(${1:geometry}, ${2:hedge})",
			"scope": "source.vex",
			"description": "Returns the half-edge that precedes a given half-edge in its polygon."
	},
	"renderstate: query value": {
			"prefix": "renderstate(query, value)",
			"body": "renderstate(${1:query}, ${2:value})",
			"scope": "source.vex",
			"description": "Queries the renderer for a named property."
	},
	"renderstate: mat query value": {
			"prefix": "renderstate(mat, query, value)",
			"body": "renderstate(${1:mat}, ${2:query}, ${3:value})",
			"scope": "source.vex",
			"description": "Queries the renderer for a named property."
	},
	"computenormal: P ...": {
			"prefix": "computenormal(P, ...)",
			"body": "computenormal(${1:P}, ${2:...})",
			"scope": "source.vex",
			"description": "In shading contexts, computes a normal. In the SOP contexts, sets how/whether to recompute normals."
	},
	"computenormal: P N Ng ...": {
			"prefix": "computenormal(P, N, Ng, ...)",
			"body": "computenormal(${1:P}, ${2:N}, ${3:Ng}, ${4:...})",
			"scope": "source.vex",
			"description": "In shading contexts, computes a normal. In the SOP contexts, sets how/whether to recompute normals."
	},
	"computenormal: i": {
			"prefix": "computenormal(i)",
			"body": "computenormal(${1:i})",
			"scope": "source.vex",
			"description": "In shading contexts, computes a normal. In the SOP contexts, sets how/whether to recompute normals."
	},
	"usd_isprimvar: stage primpath name": {
			"prefix": "usd_isprimvar(stage, primpath, name)",
			"body": "usd_isprimvar(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Checks if the primitive has a primvar of the given name."
	},
	"usd_settransformorder: stagehandle primpath transformorder": {
			"prefix": "usd_settransformorder(stagehandle, primpath, transformorder)",
			"body": "usd_settransformorder(${1:stagehandle}, ${2:primpath}, ${3:transformorder})",
			"scope": "source.vex",
			"description": "Sets the primitive\u2019s transform order"
	},
	"sensor_save: handle colorfile depthfile": {
			"prefix": "sensor_save(handle, colorfile, depthfile)",
			"body": "sensor_save(${1:handle}, ${2:colorfile}, ${3:depthfile})",
			"scope": "source.vex",
			"description": "Sensor function to save a rendered GL scene."
	},
	"usd_addorient: stagehandle primpath suffix orient": {
			"prefix": "usd_addorient(stagehandle, primpath, suffix, orient)",
			"body": "usd_addorient(${1:stagehandle}, ${2:primpath}, ${3:suffix}, ${4:orient})",
			"scope": "source.vex",
			"description": "Applies a quaternion orientation to the primitive"
	},
	"predicate_orient3d: a b c d": {
			"prefix": "predicate_orient3d(a, b, c, d)",
			"body": "predicate_orient3d(${1:a}, ${2:b}, ${3:c}, ${4:d})",
			"scope": "source.vex",
			"description": "Determines the orientation of a point with respect to a plane."
	},
	"rayimport: name value": {
			"prefix": "rayimport(name, value)",
			"body": "rayimport(${1:name}, ${2:value})",
			"scope": "source.vex",
			"description": "Imports a value sent by a shader in a gather loop."
	},
	"chsetattr: attrclass attrname channel sample value": {
			"prefix": "chsetattr(attrclass, attrname, channel, sample, value)",
			"body": "chsetattr(${1:attrclass}, ${2:attrname}, ${3:channel}, ${4:sample}, ${5:value})",
			"scope": "source.vex",
			"description": "Sets the value of a CHOP attribute."
	},
	"chsetattr: attrname channel sample value": {
			"prefix": "chsetattr(attrname, channel, sample, value)",
			"body": "chsetattr(${1:attrname}, ${2:channel}, ${3:sample}, ${4:value})",
			"scope": "source.vex",
			"description": "Sets the value of a CHOP attribute."
	},
	"dihedral: a b": {
			"prefix": "dihedral(a, b)",
			"body": "dihedral(${1:a}, ${2:b})",
			"scope": "source.vex",
			"description": "Computes the rotation matrix or quaternion which rotates the vector a onto the vector b."
	},
	"sample_sphere_cone: center maxangle u": {
			"prefix": "sample_sphere_cone(center, maxangle, u)",
			"body": "sample_sphere_cone(${1:center}, ${2:maxangle}, ${3:u})",
			"scope": "source.vex",
			"description": "Generates a uniform vector with length < 1, within maxangle of center, given a vector of uniform numbers between 0 and 1."
	},
	"chend: opinput": {
			"prefix": "chend(opinput)",
			"body": "chend(${1:opinput})",
			"scope": "source.vex",
			"description": "Returns the sample number of the last sample in a given CHOP input."
	},
	"log: n": {
			"prefix": "log(n)",
			"body": "log(${1:n})",
			"scope": "source.vex",
			"description": "Returns the natural logarithm of the argument."
	},
	"log: v": {
			"prefix": "log(v)",
			"body": "log(${1:v})",
			"scope": "source.vex",
			"description": "Returns the natural logarithm of the argument."
	},
	"usd_removerelationshiptarget: stagehandle primpath name target": {
			"prefix": "usd_removerelationshiptarget(stagehandle, primpath, name, target)",
			"body": "usd_removerelationshiptarget(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:target})",
			"scope": "source.vex",
			"description": "Remove a target from the primitive\u2019s relationship"
	},
	"getattribute: geometry value attribclass attribute_name element_number vertex_number": {
			"prefix": "getattribute(geometry, value, attribclass, attribute_name, element_number, vertex_number)",
			"body": "getattribute(${1:geometry}, ${2:value}, ${3:attribclass}, ${4:attribute_name}, ${5:element_number}, ${6:vertex_number})",
			"scope": "source.vex",
			"description": "Copies the value of a geometry attribute into a variable and returns a success flag."
	},
	"fuzzy_defuzz_centroid: aggregated_membership min_value max_value": {
			"prefix": "fuzzy_defuzz_centroid(aggregated_membership, min_value, max_value)",
			"body": "fuzzy_defuzz_centroid(${1:aggregated_membership}, ${2:min_value}, ${3:max_value})",
			"scope": "source.vex",
			"description": ""
	},
	"usd_attrib: stage primpath name": {
			"prefix": "usd_attrib(stage, primpath, name)",
			"body": "usd_attrib(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Reads the value of an attribute from the USD primitive."
	},
	"usd_attrib: stage primpath name timecode": {
			"prefix": "usd_attrib(stage, primpath, name, timecode)",
			"body": "usd_attrib(${1:stage}, ${2:primpath}, ${3:name}, ${4:timecode})",
			"scope": "source.vex",
			"description": "Reads the value of an attribute from the USD primitive."
	},
	"phongBRDF: L N V rough": {
			"prefix": "phongBRDF(L, N, V, rough)",
			"body": "phongBRDF(${1:L}, ${2:N}, ${3:V}, ${4:rough})",
			"scope": "source.vex",
			"description": ""
	},
	"storelightexport: lightname exportname value": {
			"prefix": "storelightexport(lightname, exportname, value)",
			"body": "storelightexport(${1:lightname}, ${2:exportname}, ${3:value})",
			"scope": "source.vex",
			"description": "Stores exported data for a light."
	},
	"random_poisson: seed mean": {
			"prefix": "random_poisson(seed, mean)",
			"body": "random_poisson(${1:seed}, ${2:mean})",
			"scope": "source.vex",
			"description": "Generates a random Poisson variable given the mean to the distribution and a seed."
	},
	"random_poisson: seed mean minvalue maxvalue": {
			"prefix": "random_poisson(seed, mean, minvalue, maxvalue)",
			"body": "random_poisson(${1:seed}, ${2:mean}, ${3:minvalue}, ${4:maxvalue})",
			"scope": "source.vex",
			"description": "Generates a random Poisson variable given the mean to the distribution and a seed."
	},
	"argsort: value": {
			"prefix": "argsort(value)",
			"body": "argsort(${1:value})",
			"scope": "source.vex",
			"description": "Returns the indices of a sorted version of an array."
	},
	"agenttransformnames: geometry prim": {
			"prefix": "agenttransformnames(geometry, prim)",
			"body": "agenttransformnames(${1:geometry}, ${2:prim})",
			"scope": "source.vex",
			"description": "Returns the name of each transform in an agent primitive\u2019s rig."
	},
	"intersect: geometry orig dir p u v": {
			"prefix": "intersect(geometry, orig, dir, p, u, v)",
			"body": "intersect(${1:geometry}, ${2:orig}, ${3:dir}, ${4:p}, ${5:u}, ${6:v})",
			"scope": "source.vex",
			"description": "This function computes the first intersection of a ray with geometry."
	},
	"intersect: geometry orig dir p u v ...": {
			"prefix": "intersect(geometry, orig, dir, p, u, v, ...)",
			"body": "intersect(${1:geometry}, ${2:orig}, ${3:dir}, ${4:p}, ${5:u}, ${6:v}, ${7:...})",
			"scope": "source.vex",
			"description": "This function computes the first intersection of a ray with geometry."
	},
	"intersect: geometry orig dir p uvw": {
			"prefix": "intersect(geometry, orig, dir, p, uvw)",
			"body": "intersect(${1:geometry}, ${2:orig}, ${3:dir}, ${4:p}, ${5:uvw})",
			"scope": "source.vex",
			"description": "This function computes the first intersection of a ray with geometry."
	},
	"intersect: geometry group orig dir p uvw": {
			"prefix": "intersect(geometry, group, orig, dir, p, uvw)",
			"body": "intersect(${1:geometry}, ${2:group}, ${3:orig}, ${4:dir}, ${5:p}, ${6:uvw})",
			"scope": "source.vex",
			"description": "This function computes the first intersection of a ray with geometry."
	},
	"strip: value": {
			"prefix": "strip(value)",
			"body": "strip(${1:value})",
			"scope": "source.vex",
			"description": "Strips leading and trailing whitespace from a string."
	},
	"strip: value whitespace": {
			"prefix": "strip(value, whitespace)",
			"body": "strip(${1:value}, ${2:whitespace})",
			"scope": "source.vex",
			"description": "Strips leading and trailing whitespace from a string."
	},
	"filterstep: edge x ...": {
			"prefix": "filterstep(edge, x, ...)",
			"body": "filterstep(${1:edge}, ${2:x}, ${3:...})",
			"scope": "source.vex",
			"description": "Returns the anti-aliased weight of the step function."
	},
	"filterstep: edge x0 x1 ...": {
			"prefix": "filterstep(edge, x0, x1, ...)",
			"body": "filterstep(${1:edge}, ${2:x0}, ${3:x1}, ${4:...})",
			"scope": "source.vex",
			"description": "Returns the anti-aliased weight of the step function."
	},
	"colormap: filename uvw ...": {
			"prefix": "colormap(filename, uvw, ...)",
			"body": "colormap(${1:filename}, ${2:uvw}, ${3:...})",
			"scope": "source.vex",
			"description": "Looks up a (filtered) color from a texture file."
	},
	"colormap: filename u v ...": {
			"prefix": "colormap(filename, u, v, ...)",
			"body": "colormap(${1:filename}, ${2:u}, ${3:v}, ${4:...})",
			"scope": "source.vex",
			"description": "Looks up a (filtered) color from a texture file."
	},
	"colormap: filename uv du dv samples ...": {
			"prefix": "colormap(filename, uv, du, dv, samples, ...)",
			"body": "colormap(${1:filename}, ${2:uv}, ${3:du}, ${4:dv}, ${5:samples}, ${6:...})",
			"scope": "source.vex",
			"description": "Looks up a (filtered) color from a texture file."
	},
	"colormap: filename uv0 uv1 uv2 uv3 ...": {
			"prefix": "colormap(filename, uv0, uv1, uv2, uv3, ...)",
			"body": "colormap(${1:filename}, ${2:uv0}, ${3:uv1}, ${4:uv2}, ${5:uv3}, ${6:...})",
			"scope": "source.vex",
			"description": "Looks up a (filtered) color from a texture file."
	},
	"colormap: filename uv0 uv1 uv2 uv3 samples ...": {
			"prefix": "colormap(filename, uv0, uv1, uv2, uv3, samples, ...)",
			"body": "colormap(${1:filename}, ${2:uv0}, ${3:uv1}, ${4:uv2}, ${5:uv3}, ${6:samples}, ${7:...})",
			"scope": "source.vex",
			"description": "Looks up a (filtered) color from a texture file."
	},
	"colormap: filename u0 v0 u1 v1 u2 v2 u3 v3 samples ...": {
			"prefix": "colormap(filename, u0, v0, u1, v1, u2, v2, u3, v3, samples, ...)",
			"body": "colormap(${1:filename}, ${2:u0}, ${3:v0}, ${4:u1}, ${5:v1}, ${6:u2}, ${7:v2}, ${8:u3}, ${9:v3}, ${10:samples}, ${11:...})",
			"scope": "source.vex",
			"description": "Looks up a (filtered) color from a texture file."
	},
	"vertexprimindex: geometry linearindex": {
			"prefix": "vertexprimindex(geometry, linearindex)",
			"body": "vertexprimindex(${1:geometry}, ${2:linearindex})",
			"scope": "source.vex",
			"description": "Converts a linear vertex index into a primitive vertex number."
	},
	"create_pdf: values": {
			"prefix": "create_pdf(values)",
			"body": "create_pdf(${1:values})",
			"scope": "source.vex",
			"description": "Creates a PDF from an array of input values."
	},
	"erf: v": {
			"prefix": "erf(v)",
			"body": "erf(${1:v})",
			"scope": "source.vex",
			"description": "Gauss error function."
	},
	"iend: opinput": {
			"prefix": "iend(opinput)",
			"body": "iend(${1:opinput})",
			"scope": "source.vex",
			"description": "Returns the last frame of the specified input."
	},
	"wt_vspace: v": {
			"prefix": "wt_vspace(v)",
			"body": "wt_vspace(${1:v})",
			"scope": "source.vex",
			"description": "Transforms a direction vector from World to Texture space."
	},
	"hedge_isvalid: geometry hedge": {
			"prefix": "hedge_isvalid(geometry, hedge)",
			"body": "hedge_isvalid(${1:geometry}, ${2:hedge})",
			"scope": "source.vex",
			"description": "Determines whether a half-edge number corresponds to a valid half-edge."
	},
	"rgbtoxyz: rgb": {
			"prefix": "rgbtoxyz(rgb)",
			"body": "rgbtoxyz(${1:rgb})",
			"scope": "source.vex",
			"description": "Convert a linear sRGB triplet to CIE XYZ tristimulus values."
	},
	"hedge_srcvertex: geometry hedge": {
			"prefix": "hedge_srcvertex(geometry, hedge)",
			"body": "hedge_srcvertex(${1:geometry}, ${2:hedge})",
			"scope": "source.vex",
			"description": "Returns the source vertex of a half-edge."
	},
	"lspline: sample_pos value1 ...": {
			"prefix": "lspline(sample_pos, value1, ...)",
			"body": "lspline(${1:sample_pos}, ${2:value1}, ${3:...})",
			"scope": "source.vex",
			"description": "Samples a polyline defined by linearly spaced values."
	},
	"usd_setcollectionincludes: stagehandle collectionpath includes": {
			"prefix": "usd_setcollectionincludes(stagehandle, collectionpath, includes)",
			"body": "usd_setcollectionincludes(${1:stagehandle}, ${2:collectionpath}, ${3:includes})",
			"scope": "source.vex",
			"description": "Sets the includes list on the collection"
	},
	"chresizebuf: size": {
			"prefix": "chresizebuf(size)",
			"body": "chresizebuf(${1:size})",
			"scope": "source.vex",
			"description": "Resize the CHOP context temporary buffer"
	},
	"relativepath: src dest": {
			"prefix": "relativepath(src, dest)",
			"body": "relativepath(${1:src}, ${2:dest})",
			"scope": "source.vex",
			"description": "Computes the relative path for two full paths."
	},
	"pnoise: x px": {
			"prefix": "pnoise(x, px)",
			"body": "pnoise(${1:x}, ${2:px})",
			"scope": "source.vex",
			"description": "There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space."
	},
	"pnoise: x p": {
			"prefix": "pnoise(x, p)",
			"body": "pnoise(${1:x}, ${2:p})",
			"scope": "source.vex",
			"description": "There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space."
	},
	"pnoise: xyzt p": {
			"prefix": "pnoise(xyzt, p)",
			"body": "pnoise(${1:xyzt}, ${2:p})",
			"scope": "source.vex",
			"description": "There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space."
	},
	"pnoise: x y px py": {
			"prefix": "pnoise(x, y, px, py)",
			"body": "pnoise(${1:x}, ${2:y}, ${3:px}, ${4:py})",
			"scope": "source.vex",
			"description": "There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space."
	},
	"pnoise: xyz px py pz": {
			"prefix": "pnoise(xyz, px, py, pz)",
			"body": "pnoise(${1:xyz}, ${2:px}, ${3:py}, ${4:pz})",
			"scope": "source.vex",
			"description": "There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space."
	},
	"pnoise: xyzt px py pz pt": {
			"prefix": "pnoise(xyzt, px, py, pz, pt)",
			"body": "pnoise(${1:xyzt}, ${2:px}, ${3:py}, ${4:pz}, ${5:pt})",
			"scope": "source.vex",
			"description": "There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space."
	},
	"istart: opinput": {
			"prefix": "istart(opinput)",
			"body": "istart(${1:opinput})",
			"scope": "source.vex",
			"description": "Returns the starting frame of the specified input."
	},
	"getrayweight: ": {
			"prefix": "getrayweight()",
			"body": "getrayweight()",
			"scope": "source.vex",
			"description": "Returns an approximation to the contribution of the ray to the final\npixel color."
	},
	"abspath: relpath": {
			"prefix": "abspath(relpath)",
			"body": "abspath(${1:relpath})",
			"scope": "source.vex",
			"description": "Returns the full path of a file."
	},
	"re_replace: regex replacement input maxreplace": {
			"prefix": "re_replace(regex, replacement, input, maxreplace)",
			"body": "re_replace(${1:regex}, ${2:replacement}, ${3:input}, ${4:maxreplace})",
			"scope": "source.vex",
			"description": "Replaces instances of regex_find with regex_replace"
	},
	"endswith: haystack needle": {
			"prefix": "endswith(haystack, needle)",
			"body": "endswith(${1:haystack}, ${2:needle})",
			"scope": "source.vex",
			"description": "Indicates the string ends with the specified string."
	},
	"reflect: direction normal": {
			"prefix": "reflect(direction, normal)",
			"body": "reflect(${1:direction}, ${2:normal})",
			"scope": "source.vex",
			"description": "Returns the vector representing the reflection of the direction\nagainst the normal."
	},
	"pcnumfound: handle": {
			"prefix": "pcnumfound(handle)",
			"body": "pcnumfound(${1:handle})",
			"scope": "source.vex",
			"description": "This node returns the number of points found by pcopen."
	},
	"isvarying: x": {
			"prefix": "isvarying(x)",
			"body": "isvarying(${1:x})",
			"scope": "source.vex",
			"description": "Check whether a VEX variable is varying or uniform."
	},
	"efit: value omin omax nmin nmax": {
			"prefix": "efit(value, omin, omax, nmin, nmax)",
			"body": "efit(${1:value}, ${2:omin}, ${3:omax}, ${4:nmin}, ${5:nmax})",
			"scope": "source.vex",
			"description": "Takes the value in one range and shifts it to the corresponding value in a new range."
	},
	"prerotate: m amount axis": {
			"prefix": "prerotate(m, amount, axis)",
			"body": "prerotate(${1:m}, ${2:amount}, ${3:axis})",
			"scope": "source.vex",
			"description": "Applies a pre rotation to the given matrix."
	},
	"prerotate: m angles xyz": {
			"prefix": "prerotate(m, angles, xyz)",
			"body": "prerotate(${1:m}, ${2:angles}, ${3:xyz})",
			"scope": "source.vex",
			"description": "Applies a pre rotation to the given matrix."
	},
	"prerotate: m angle axis": {
			"prefix": "prerotate(m, angle, axis)",
			"body": "prerotate(${1:m}, ${2:angle}, ${3:axis})",
			"scope": "source.vex",
			"description": "Applies a pre rotation to the given matrix."
	},
	"pcsize: handle": {
			"prefix": "pcsize(handle)",
			"body": "pcsize(${1:handle})",
			"scope": "source.vex",
			"description": ""
	},
	"usd_setpurpose: stagehandle primpath purpose": {
			"prefix": "usd_setpurpose(stagehandle, primpath, purpose)",
			"body": "usd_setpurpose(${1:stagehandle}, ${2:primpath}, ${3:purpose})",
			"scope": "source.vex",
			"description": "Sets the primitive\u2019s purpose."
	},
	"serialize: vectors": {
			"prefix": "serialize(vectors)",
			"body": "serialize(${1:vectors})",
			"scope": "source.vex",
			"description": "Flattens an array of vector or matrix types into an array of floats."
	},
	"serialize: matrices": {
			"prefix": "serialize(matrices)",
			"body": "serialize(${1:matrices})",
			"scope": "source.vex",
			"description": "Flattens an array of vector or matrix types into an array of floats."
	},
	"geoself: ": {
			"prefix": "geoself()",
			"body": "geoself()",
			"scope": "source.vex",
			"description": "Returns a handle to the current geometry."
	},
	"mspace: P": {
			"prefix": "mspace(P)",
			"body": "mspace(${1:P})",
			"scope": "source.vex",
			"description": "Transforms the position specified into the \"local\" space of the\nmetaball."
	},
	"setagentcliptimes: geohandle prim cliptimes": {
			"prefix": "setagentcliptimes(geohandle, prim, cliptimes)",
			"body": "setagentcliptimes(${1:geohandle}, ${2:prim}, ${3:cliptimes})",
			"scope": "source.vex",
			"description": "Sets the current times for an agent primitive\u2019s animation clips."
	},
	"isotropic: ...": {
			"prefix": "isotropic(...)",
			"body": "isotropic(${1:...})",
			"scope": "source.vex",
			"description": "Returns an isotropic BSDF, which scatters light equally in all directions."
	},
	"getcomp: v index": {
			"prefix": "getcomp(v, index)",
			"body": "getcomp(${1:v}, ${2:index})",
			"scope": "source.vex",
			"description": "Extracts a single component of a vector type, matrix type, or array."
	},
	"getcomp: m row column": {
			"prefix": "getcomp(m, row, column)",
			"body": "getcomp(${1:m}, ${2:row}, ${3:column})",
			"scope": "source.vex",
			"description": "Extracts a single component of a vector type, matrix type, or array."
	},
	"getcomp: array index": {
			"prefix": "getcomp(array, index)",
			"body": "getcomp(${1:array}, ${2:index})",
			"scope": "source.vex",
			"description": "Extracts a single component of a vector type, matrix type, or array."
	},
	"getcomp: value index": {
			"prefix": "getcomp(value, index)",
			"body": "getcomp(${1:value}, ${2:index})",
			"scope": "source.vex",
			"description": "Extracts a single component of a vector type, matrix type, or array."
	},
	"file_stat: filename stat_data ...": {
			"prefix": "file_stat(filename, stat_data, ...)",
			"body": "file_stat(${1:filename}, ${2:stat_data}, ${3:...})",
			"scope": "source.vex",
			"description": "Returns file system status for a given file."
	},
	"relpath: abspath": {
			"prefix": "relpath(abspath)",
			"body": "relpath(${1:abspath})",
			"scope": "source.vex",
			"description": "Returns the relative path to a file."
	},
	"sample_bsdf: F viewer_u dir eval type sx sy ...": {
			"prefix": "sample_bsdf(F, viewer_u, dir, eval, type, sx, sy, ...)",
			"body": "sample_bsdf(${1:F}, ${2:viewer_u}, ${3:dir}, ${4:eval}, ${5:type}, ${6:sx}, ${7:sy}, ${8:...})",
			"scope": "source.vex",
			"description": "Samples a BSDF."
	},
	"sample_bsdf: F viewer_u dir eval type sx sy mask ...": {
			"prefix": "sample_bsdf(F, viewer_u, dir, eval, type, sx, sy, mask, ...)",
			"body": "sample_bsdf(${1:F}, ${2:viewer_u}, ${3:dir}, ${4:eval}, ${5:type}, ${6:sx}, ${7:sy}, ${8:mask}, ${9:...})",
			"scope": "source.vex",
			"description": "Samples a BSDF."
	},
	"sample_bsdf: F viewer_u dir eval pdf type sx sy ...": {
			"prefix": "sample_bsdf(F, viewer_u, dir, eval, pdf, type, sx, sy, ...)",
			"body": "sample_bsdf(${1:F}, ${2:viewer_u}, ${3:dir}, ${4:eval}, ${5:pdf}, ${6:type}, ${7:sx}, ${8:sy}, ${9:...})",
			"scope": "source.vex",
			"description": "Samples a BSDF."
	},
	"sample_bsdf: F viewer_u dir eval pdf type sx sy mask ...": {
			"prefix": "sample_bsdf(F, viewer_u, dir, eval, pdf, type, sx, sy, mask, ...)",
			"body": "sample_bsdf(${1:F}, ${2:viewer_u}, ${3:dir}, ${4:eval}, ${5:pdf}, ${6:type}, ${7:sx}, ${8:sy}, ${9:mask}, ${10:...})",
			"scope": "source.vex",
			"description": "Samples a BSDF."
	},
	"sample_bsdf: b viewer_u normal_v flags dir eval pdf type sx sy mask ...": {
			"prefix": "sample_bsdf(b, viewer_u, normal_v, flags, dir, eval, pdf, type, sx, sy, mask, ...)",
			"body": "sample_bsdf(${1:b}, ${2:viewer_u}, ${3:normal_v}, ${4:flags}, ${5:dir}, ${6:eval}, ${7:pdf}, ${8:type}, ${9:sx}, ${10:sy}, ${11:mask}, ${12:...})",
			"scope": "source.vex",
			"description": "Samples a BSDF."
	},
	"setpointattrib: geohandle name point_num value mode": {
			"prefix": "setpointattrib(geohandle, name, point_num, value, mode)",
			"body": "setpointattrib(${1:geohandle}, ${2:name}, ${3:point_num}, ${4:value}, ${5:mode})",
			"scope": "source.vex",
			"description": "Sets a point attribute in a geometry."
	},
	"__uniform_mul: a b": {
			"prefix": "__uniform_mul(a, b)",
			"body": "__uniform_mul(${1:a}, ${2:b})",
			"scope": "source.vex",
			"description": "Multiply matrices."
	},
	"__uniform_mul: m a b": {
			"prefix": "__uniform_mul(m, a, b)",
			"body": "__uniform_mul(${1:m}, ${2:a}, ${3:b})",
			"scope": "source.vex",
			"description": "Multiply matrices."
	},
	"usd_addtranslate: stagehandle primpath suffix amount": {
			"prefix": "usd_addtranslate(stagehandle, primpath, suffix, amount)",
			"body": "usd_addtranslate(${1:stagehandle}, ${2:primpath}, ${3:suffix}, ${4:amount})",
			"scope": "source.vex",
			"description": "Applies a translation to the primitive"
	},
	"inumplanes: opinput": {
			"prefix": "inumplanes(opinput)",
			"body": "inumplanes(${1:opinput})",
			"scope": "source.vex",
			"description": "Returns the number of planes in the given input."
	},
	"re_findall: regex input": {
			"prefix": "re_findall(regex, input)",
			"body": "re_findall(${1:regex}, ${2:input})",
			"scope": "source.vex",
			"description": "Finds all instances of the given regular expression in the string"
	},
	"re_findall: regex input start": {
			"prefix": "re_findall(regex, input, start)",
			"body": "re_findall(${1:regex}, ${2:input}, ${3:start})",
			"scope": "source.vex",
			"description": "Finds all instances of the given regular expression in the string"
	},
	"re_findall: regex input start end": {
			"prefix": "re_findall(regex, input, start, end)",
			"body": "re_findall(${1:regex}, ${2:input}, ${3:start}, ${4:end})",
			"scope": "source.vex",
			"description": "Finds all instances of the given regular expression in the string"
	},
	"opprerawparmtransform: path": {
			"prefix": "opprerawparmtransform(path)",
			"body": "opprerawparmtransform(${1:path})",
			"scope": "source.vex",
			"description": "Returns the pre and raw parm transform associated with an OP."
	},
	"opprerawparmtransform: path time": {
			"prefix": "opprerawparmtransform(path, time)",
			"body": "opprerawparmtransform(${1:path}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the pre and raw parm transform associated with an OP."
	},
	"opprerawparmtransform: opid": {
			"prefix": "opprerawparmtransform(opid)",
			"body": "opprerawparmtransform(${1:opid})",
			"scope": "source.vex",
			"description": "Returns the pre and raw parm transform associated with an OP."
	},
	"opprerawparmtransform: opid time": {
			"prefix": "opprerawparmtransform(opid, time)",
			"body": "opprerawparmtransform(${1:opid}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the pre and raw parm transform associated with an OP."
	},
	"opprerawparmtransform: opid trsorder xyzorder mask": {
			"prefix": "opprerawparmtransform(opid, trsorder, xyzorder, mask)",
			"body": "opprerawparmtransform(${1:opid}, ${2:trsorder}, ${3:xyzorder}, ${4:mask})",
			"scope": "source.vex",
			"description": "Returns the pre and raw parm transform associated with an OP."
	},
	"sample_circle_edge_uniform: u": {
			"prefix": "sample_circle_edge_uniform(u)",
			"body": "sample_circle_edge_uniform(${1:u})",
			"scope": "source.vex",
			"description": "Generates a uniform unit vector2, given a uniform number between 0 and 1."
	},
	"usd_flattenedprimvarelement: stage primpath name index": {
			"prefix": "usd_flattenedprimvarelement(stage, primpath, name, index)",
			"body": "usd_flattenedprimvarelement(${1:stage}, ${2:primpath}, ${3:name}, ${4:index})",
			"scope": "source.vex",
			"description": "Reads an element value of a flattened array primvar."
	},
	"usd_flattenedprimvarelement: stage primpath name index timecode": {
			"prefix": "usd_flattenedprimvarelement(stage, primpath, name, index, timecode)",
			"body": "usd_flattenedprimvarelement(${1:stage}, ${2:primpath}, ${3:name}, ${4:index}, ${5:timecode})",
			"scope": "source.vex",
			"description": "Reads an element value of a flattened array primvar."
	},
	"israytracing: ": {
			"prefix": "israytracing()",
			"body": "israytracing()",
			"scope": "source.vex",
			"description": "Indicates whether a shader is being executed for ray tracing."
	},
	"bouncelabel: mask": {
			"prefix": "bouncelabel(mask)",
			"body": "bouncelabel(${1:mask})",
			"scope": "source.vex",
			"description": ""
	},
	"expandprimgroup: geometry groupname": {
			"prefix": "expandprimgroup(geometry, groupname)",
			"body": "expandprimgroup(${1:geometry}, ${2:groupname})",
			"scope": "source.vex",
			"description": "Returns an array of prim numbers corresponding to a group string."
	},
	"usd_isarray: stage primpath name": {
			"prefix": "usd_isarray(stage, primpath, name)",
			"body": "usd_isarray(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Checks if the attribute is an array."
	},
	"rawcolormap: filename uvw ...": {
			"prefix": "rawcolormap(filename, uvw, ...)",
			"body": "rawcolormap(${1:filename}, ${2:uvw}, ${3:...})",
			"scope": "source.vex",
			"description": "Looks up an unfiltered color from a texture file."
	},
	"rawcolormap: filename u v ...": {
			"prefix": "rawcolormap(filename, u, v, ...)",
			"body": "rawcolormap(${1:filename}, ${2:u}, ${3:v}, ${4:...})",
			"scope": "source.vex",
			"description": "Looks up an unfiltered color from a texture file."
	},
	"rawcolormap: filename uv du dv samples ...": {
			"prefix": "rawcolormap(filename, uv, du, dv, samples, ...)",
			"body": "rawcolormap(${1:filename}, ${2:uv}, ${3:du}, ${4:dv}, ${5:samples}, ${6:...})",
			"scope": "source.vex",
			"description": "Looks up an unfiltered color from a texture file."
	},
	"rawcolormap: filename uv0 uv1 uv2 uv3 ...": {
			"prefix": "rawcolormap(filename, uv0, uv1, uv2, uv3, ...)",
			"body": "rawcolormap(${1:filename}, ${2:uv0}, ${3:uv1}, ${4:uv2}, ${5:uv3}, ${6:...})",
			"scope": "source.vex",
			"description": "Looks up an unfiltered color from a texture file."
	},
	"rawcolormap: filename uv0 uv1 uv2 uv3 samples ...": {
			"prefix": "rawcolormap(filename, uv0, uv1, uv2, uv3, samples, ...)",
			"body": "rawcolormap(${1:filename}, ${2:uv0}, ${3:uv1}, ${4:uv2}, ${5:uv3}, ${6:samples}, ${7:...})",
			"scope": "source.vex",
			"description": "Looks up an unfiltered color from a texture file."
	},
	"rawcolormap: filename u0 v0 u1 v1 u2 v2 u3 v3 samples ...": {
			"prefix": "rawcolormap(filename, u0, v0, u1, v1, u2, v2, u3, v3, samples, ...)",
			"body": "rawcolormap(${1:filename}, ${2:u0}, ${3:v0}, ${4:u1}, ${5:v1}, ${6:u2}, ${7:v2}, ${8:u3}, ${9:v3}, ${10:samples}, ${11:...})",
			"scope": "source.vex",
			"description": "Looks up an unfiltered color from a texture file."
	},
	"shadow: Cl": {
			"prefix": "shadow(Cl)",
			"body": "shadow(${1:Cl})",
			"scope": "source.vex",
			"description": "Calls shadow shaders for the current light source."
	},
	"shadow: Cl P L": {
			"prefix": "shadow(Cl, P, L)",
			"body": "shadow(${1:Cl}, ${2:P}, ${3:L})",
			"scope": "source.vex",
			"description": "Calls shadow shaders for the current light source."
	},
	"pointattrib: geometry attribute_name pointnumber success": {
			"prefix": "pointattrib(geometry, attribute_name, pointnumber, success)",
			"body": "pointattrib(${1:geometry}, ${2:attribute_name}, ${3:pointnumber}, ${4:success})",
			"scope": "source.vex",
			"description": "Reads a point attribute value from a geometry and outputs a success/fail flag."
	},
	"primuvconvert: filename uv prim_num mode": {
			"prefix": "primuvconvert(filename, uv, prim_num, mode)",
			"body": "primuvconvert(${1:filename}, ${2:uv}, ${3:prim_num}, ${4:mode})",
			"scope": "source.vex",
			"description": "Convert parametric UV locations on curve primitives between different spaces."
	},
	"primuvconvert: filename uv prim_num mode tolerance": {
			"prefix": "primuvconvert(filename, uv, prim_num, mode, tolerance)",
			"body": "primuvconvert(${1:filename}, ${2:uv}, ${3:prim_num}, ${4:mode}, ${5:tolerance})",
			"scope": "source.vex",
			"description": "Convert parametric UV locations on curve primitives between different spaces."
	},
	"orthographic: zoom orthowidth image_aspect pixel_aspect clip_near clip_far": {
			"prefix": "orthographic(zoom, orthowidth, image_aspect, pixel_aspect, clip_near, clip_far)",
			"body": "orthographic(${1:zoom}, ${2:orthowidth}, ${3:image_aspect}, ${4:pixel_aspect}, ${5:clip_near}, ${6:clip_far})",
			"scope": "source.vex",
			"description": "Create an orthographic projection matrix."
	},
	"orthographic: zoom orthowidth image_aspect pixel_aspect clip_near clip_far window": {
			"prefix": "orthographic(zoom, orthowidth, image_aspect, pixel_aspect, clip_near, clip_far, window)",
			"body": "orthographic(${1:zoom}, ${2:orthowidth}, ${3:image_aspect}, ${4:pixel_aspect}, ${5:clip_near}, ${6:clip_far}, ${7:window})",
			"scope": "source.vex",
			"description": "Create an orthographic projection matrix."
	},
	"cregionoverridetransform: path": {
			"prefix": "cregionoverridetransform(path)",
			"body": "cregionoverridetransform(${1:path})",
			"scope": "source.vex",
			"description": "Returns the capture or deform transform associated with a Capture Region SOP based on the global capture override flag."
	},
	"cregionoverridetransform: path time": {
			"prefix": "cregionoverridetransform(path, time)",
			"body": "cregionoverridetransform(${1:path}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the capture or deform transform associated with a Capture Region SOP based on the global capture override flag."
	},
	"cregionoverridetransform: op_id": {
			"prefix": "cregionoverridetransform(op_id)",
			"body": "cregionoverridetransform(${1:op_id})",
			"scope": "source.vex",
			"description": "Returns the capture or deform transform associated with a Capture Region SOP based on the global capture override flag."
	},
	"cregionoverridetransform: op_id time": {
			"prefix": "cregionoverridetransform(op_id, time)",
			"body": "cregionoverridetransform(${1:op_id}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the capture or deform transform associated with a Capture Region SOP based on the global capture override flag."
	},
	"fuzzy_nor: a b ...": {
			"prefix": "fuzzy_nor(a, b, ...)",
			"body": "fuzzy_nor(${1:a}, ${2:b}, ${3:...})",
			"scope": "source.vex",
			"description": ""
	},
	"usd_makerelationshippath: stage primpath name": {
			"prefix": "usd_makerelationshippath(stage, primpath, name)",
			"body": "usd_makerelationshippath(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Constructs an relationship path from a primitive path and a relationship name."
	},
	"oppreconstrainttransform: path": {
			"prefix": "oppreconstrainttransform(path)",
			"body": "oppreconstrainttransform(${1:path})",
			"scope": "source.vex",
			"description": "Returns the preconstraint transform associated with an OP."
	},
	"oppreconstrainttransform: path time": {
			"prefix": "oppreconstrainttransform(path, time)",
			"body": "oppreconstrainttransform(${1:path}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the preconstraint transform associated with an OP."
	},
	"oppreconstrainttransform: opid": {
			"prefix": "oppreconstrainttransform(opid)",
			"body": "oppreconstrainttransform(${1:opid})",
			"scope": "source.vex",
			"description": "Returns the preconstraint transform associated with an OP."
	},
	"oppreconstrainttransform: opid time": {
			"prefix": "oppreconstrainttransform(opid, time)",
			"body": "oppreconstrainttransform(${1:opid}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the preconstraint transform associated with an OP."
	},
	"usd_pointinstance_getbbox_center: stage primpath instance_index purpose": {
			"prefix": "usd_pointinstance_getbbox_center(stage, primpath, instance_index, purpose)",
			"body": "usd_pointinstance_getbbox_center(${1:stage}, ${2:primpath}, ${3:instance_index}, ${4:purpose})",
			"scope": "source.vex",
			"description": "Returns the center of the bounding box for the instance inside a point instancer primitive."
	},
	"append: array value": {
			"prefix": "append(array, value)",
			"body": "append(${1:array}, ${2:value})",
			"scope": "source.vex",
			"description": "Adds an item to an array or string."
	},
	"append: array values": {
			"prefix": "append(array, values)",
			"body": "append(${1:array}, ${2:values})",
			"scope": "source.vex",
			"description": "Adds an item to an array or string."
	},
	"sinh: n": {
			"prefix": "sinh(n)",
			"body": "sinh(${1:n})",
			"scope": "source.vex",
			"description": "Returns the hyperbolic sine of the argument."
	},
	"sinh: v": {
			"prefix": "sinh(v)",
			"body": "sinh(${1:v})",
			"scope": "source.vex",
			"description": "Returns the hyperbolic sine of the argument."
	},
	"fuzzify: ramp_basis ramp_values ramp_positions crisp_value min_value max_value": {
			"prefix": "fuzzify(ramp_basis, ramp_values, ramp_positions, crisp_value, min_value, max_value)",
			"body": "fuzzify(${1:ramp_basis}, ${2:ramp_values}, ${3:ramp_positions}, ${4:crisp_value}, ${5:min_value}, ${6:max_value})",
			"scope": "source.vex",
			"description": ""
	},
	"neighbour: geometry point_num neighbour_num": {
			"prefix": "neighbour(geometry, point_num, neighbour_num)",
			"body": "neighbour(${1:geometry}, ${2:point_num}, ${3:neighbour_num})",
			"scope": "source.vex",
			"description": "Returns the point number of the next point connected to a given point."
	},
	"tanh: n": {
			"prefix": "tanh(n)",
			"body": "tanh(${1:n})",
			"scope": "source.vex",
			"description": "Returns the hyperbolic tangent of the argument"
	},
	"primvertex: geometry primnum vertex": {
			"prefix": "primvertex(geometry, primnum, vertex)",
			"body": "primvertex(${1:geometry}, ${2:primnum}, ${3:vertex})",
			"scope": "source.vex",
			"description": "Converts a primitive/vertex pair into a linear vertex."
	},
	"agentlocaltransform: geometry prim transform": {
			"prefix": "agentlocaltransform(geometry, prim, transform)",
			"body": "agentlocaltransform(${1:geometry}, ${2:prim}, ${3:transform})",
			"scope": "source.vex",
			"description": "Returns the current local space transform of an agent primitive\u2019s bone."
	},
	"primhedge: geometry prim": {
			"prefix": "primhedge(geometry, prim)",
			"body": "primhedge(${1:geometry}, ${2:prim})",
			"scope": "source.vex",
			"description": "Returns one of the half-edges contained in a primitive."
	},
	"extractlocaltransform: world parent_world parent_local mode": {
			"prefix": "extractlocaltransform(world, parent_world, parent_local, mode)",
			"body": "extractlocaltransform(${1:world}, ${2:parent_world}, ${3:parent_local}, ${4:mode})",
			"scope": "source.vex",
			"description": "Extracts Local Transform from a World Transform with Scale Inheritance."
	},
	"usd_addprim: stagehandle primpath typename": {
			"prefix": "usd_addprim(stagehandle, primpath, typename)",
			"body": "usd_addprim(${1:stagehandle}, ${2:primpath}, ${3:typename})",
			"scope": "source.vex",
			"description": "Creates a primitive of a given type."
	},
	"opfullpath: relative_path": {
			"prefix": "opfullpath(relative_path)",
			"body": "opfullpath(${1:relative_path})",
			"scope": "source.vex",
			"description": "Returns the full path for the given relative path"
	},
	"usd_purpose: stage primpath": {
			"prefix": "usd_purpose(stage, primpath)",
			"body": "usd_purpose(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Returns the primitive\u2019s purpose."
	},
	"chsetrate: clip_rate": {
			"prefix": "chsetrate(clip_rate)",
			"body": "chsetrate(${1:clip_rate})",
			"scope": "source.vex",
			"description": "Sets the sampling rate of the CHOP channel data."
	},
	"setagentworldtransforms: geohandle prim transforms": {
			"prefix": "setagentworldtransforms(geohandle, prim, transforms)",
			"body": "setagentworldtransforms(${1:geohandle}, ${2:prim}, ${3:transforms})",
			"scope": "source.vex",
			"description": "Overrides the world space transforms of an agent primitive."
	},
	"svddecomp: input_M output_U output_S output_V": {
			"prefix": "svddecomp(input_M, output_U, output_S, output_V)",
			"body": "svddecomp(${1:input_M}, ${2:output_U}, ${3:output_S}, ${4:output_V})",
			"scope": "source.vex",
			"description": "Computes the singular value decomposition of a 3\u00d73 matrix."
	},
	"svddecomp: input_M": {
			"prefix": "svddecomp(input_M)",
			"body": "svddecomp(${1:input_M})",
			"scope": "source.vex",
			"description": "Computes the singular value decomposition of a 3\u00d73 matrix."
	},
	"detailattrib: geometry attribute_name ignored success": {
			"prefix": "detailattrib(geometry, attribute_name, ignored, success)",
			"body": "detailattrib(${1:geometry}, ${2:attribute_name}, ${3:ignored}, ${4:success})",
			"scope": "source.vex",
			"description": "Reads a detail attribute value from a geometry."
	},
	"setagentlocaltransform: geohandle prim transform index": {
			"prefix": "setagentlocaltransform(geohandle, prim, transform, index)",
			"body": "setagentlocaltransform(${1:geohandle}, ${2:prim}, ${3:transform}, ${4:index})",
			"scope": "source.vex",
			"description": "Overrides the local space transform of an agent primitive\u2019s bone."
	},
	"getlightname: ": {
			"prefix": "getlightname()",
			"body": "getlightname()",
			"scope": "source.vex",
			"description": "Returns the name of the current light when called from within an illuminance loop, or converts an integer light ID into the light\u2019s name."
	},
	"getlightname: lightid": {
			"prefix": "getlightname(lightid)",
			"body": "getlightname(${1:lightid})",
			"scope": "source.vex",
			"description": "Returns the name of the current light when called from within an illuminance loop, or converts an integer light ID into the light\u2019s name."
	},
	"tolower: str": {
			"prefix": "tolower(str)",
			"body": "tolower(${1:str})",
			"scope": "source.vex",
			"description": "Converts all characters in string to lower case"
	},
	"istarttime: opinput": {
			"prefix": "istarttime(opinput)",
			"body": "istarttime(${1:opinput})",
			"scope": "source.vex",
			"description": "Returns the start time of the specified input."
	},
	"filtershadow: P D bias ...": {
			"prefix": "filtershadow(P, D, bias, ...)",
			"body": "filtershadow(${1:P}, ${2:D}, ${3:bias}, ${4:...})",
			"scope": "source.vex",
			"description": "Sends a ray from the position P along direction D."
	},
	"blinnBRDF: L N V rough": {
			"prefix": "blinnBRDF(L, N, V, rough)",
			"body": "blinnBRDF(${1:L}, ${2:N}, ${3:V}, ${4:rough})",
			"scope": "source.vex",
			"description": ""
	},
	"usd_setvariantselection: stage primpath variantset variant": {
			"prefix": "usd_setvariantselection(stage, primpath, variantset, variant)",
			"body": "usd_setvariantselection(${1:stage}, ${2:primpath}, ${3:variantset}, ${4:variant})",
			"scope": "source.vex",
			"description": "Sets the selected variant in the given variant set."
	},
	"usd_collectionexcludes: stage collectionpath": {
			"prefix": "usd_collectionexcludes(stage, collectionpath)",
			"body": "usd_collectionexcludes(${1:stage}, ${2:collectionpath})",
			"scope": "source.vex",
			"description": "Obtains the object paths that are in the collection\u2019s exclude list"
	},
	"ptlined: P0 P1 Q": {
			"prefix": "ptlined(P0, P1, Q)",
			"body": "ptlined(${1:P0}, ${2:P1}, ${3:Q})",
			"scope": "source.vex",
			"description": "This function returns the closest distance between the point Q and a\nfinite line segment between points P0 and P1."
	},
	"attribtypeinfo: geometry attribclass attribute_name": {
			"prefix": "attribtypeinfo(geometry, attribclass, attribute_name)",
			"body": "attribtypeinfo(${1:geometry}, ${2:attribclass}, ${3:attribute_name})",
			"scope": "source.vex",
			"description": "Returns the transformation metadata of a geometry attribute."
	},
	"opparentbonetransform: path": {
			"prefix": "opparentbonetransform(path)",
			"body": "opparentbonetransform(${1:path})",
			"scope": "source.vex",
			"description": "Returns the parent bone transform associated with an OP."
	},
	"opparentbonetransform: path time": {
			"prefix": "opparentbonetransform(path, time)",
			"body": "opparentbonetransform(${1:path}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the parent bone transform associated with an OP."
	},
	"opparentbonetransform: opid": {
			"prefix": "opparentbonetransform(opid)",
			"body": "opparentbonetransform(${1:opid})",
			"scope": "source.vex",
			"description": "Returns the parent bone transform associated with an OP."
	},
	"opparentbonetransform: opid time": {
			"prefix": "opparentbonetransform(opid, time)",
			"body": "opparentbonetransform(${1:opid}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the parent bone transform associated with an OP."
	},
	"mdensity: P": {
			"prefix": "mdensity(P)",
			"body": "mdensity(${1:P})",
			"scope": "source.vex",
			"description": "Returns the density of the metaball field if metaball geometry is\nspecified to i3dgen."
	},
	"getbbox: geometry min max": {
			"prefix": "getbbox(geometry, min, max)",
			"body": "getbbox(${1:geometry}, ${2:min}, ${3:max})",
			"scope": "source.vex",
			"description": "Sets two vectors to the minimum and maximum corners of the bounding box for the geometry."
	},
	"getbbox: geometry primgroup min max": {
			"prefix": "getbbox(geometry, primgroup, min, max)",
			"body": "getbbox(${1:geometry}, ${2:primgroup}, ${3:min}, ${4:max})",
			"scope": "source.vex",
			"description": "Sets two vectors to the minimum and maximum corners of the bounding box for the geometry."
	},
	"getbbox: min max": {
			"prefix": "getbbox(min, max)",
			"body": "getbbox(${1:min}, ${2:max})",
			"scope": "source.vex",
			"description": "Sets two vectors to the minimum and maximum corners of the bounding box for the geometry."
	},
	"agentclipsamplerate: geometry prim clipname": {
			"prefix": "agentclipsamplerate(geometry, prim, clipname)",
			"body": "agentclipsamplerate(${1:geometry}, ${2:prim}, ${3:clipname})",
			"scope": "source.vex",
			"description": "Returns the sample rate of an agent\u2019s animation clip."
	},
	"usd_attribtypename: stage primpath name": {
			"prefix": "usd_attribtypename(stage, primpath, name)",
			"body": "usd_attribtypename(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Returns the name of the attribute type."
	},
	"rgbtohsv: hsv": {
			"prefix": "rgbtohsv(hsv)",
			"body": "rgbtohsv(${1:hsv})",
			"scope": "source.vex",
			"description": "Convert RGB color space to HSV color space."
	},
	"rgbtohsv: h s v": {
			"prefix": "rgbtohsv(h, s, v)",
			"body": "rgbtohsv(${1:h}, ${2:s}, ${3:v})",
			"scope": "source.vex",
			"description": "Convert RGB color space to HSV color space."
	},
	"getpointbbox_max: geometry": {
			"prefix": "getpointbbox_max(geometry)",
			"body": "getpointbbox_max(${1:geometry})",
			"scope": "source.vex",
			"description": "Returns the maximum of the bounding box for the geometry."
	},
	"getpointbbox_max: geometry pointgroup": {
			"prefix": "getpointbbox_max(geometry, pointgroup)",
			"body": "getpointbbox_max(${1:geometry}, ${2:pointgroup})",
			"scope": "source.vex",
			"description": "Returns the maximum of the bounding box for the geometry."
	},
	"hasplane: planename": {
			"prefix": "hasplane(planename)",
			"body": "hasplane(${1:planename})",
			"scope": "source.vex",
			"description": "Returns 1 if the plane specified by the parameter exists in this\nCOP."
	},
	"volumeindex: geometry primnum voxel": {
			"prefix": "volumeindex(geometry, primnum, voxel)",
			"body": "volumeindex(${1:geometry}, ${2:primnum}, ${3:voxel})",
			"scope": "source.vex",
			"description": "Gets the value of a specific voxel."
	},
	"volumeindex: geometry volumename voxel": {
			"prefix": "volumeindex(geometry, volumename, voxel)",
			"body": "volumeindex(${1:geometry}, ${2:volumename}, ${3:voxel})",
			"scope": "source.vex",
			"description": "Gets the value of a specific voxel."
	},
	"getphotonlight: ": {
			"prefix": "getphotonlight()",
			"body": "getphotonlight()",
			"scope": "source.vex",
			"description": "Returns the integer ID of the light being used for photon shading."
	},
	"expandedgegroup: filename groupname": {
			"prefix": "expandedgegroup(filename, groupname)",
			"body": "expandedgegroup(${1:filename}, ${2:groupname})",
			"scope": "source.vex",
			"description": ""
	},
	"expandedgegroup: input groupname": {
			"prefix": "expandedgegroup(input, groupname)",
			"body": "expandedgegroup(${1:input}, ${2:groupname})",
			"scope": "source.vex",
			"description": ""
	},
	"texprintf: u v format ...": {
			"prefix": "texprintf(u, v, format, ...)",
			"body": "texprintf(${1:u}, ${2:v}, ${3:format}, ${4:...})",
			"scope": "source.vex",
			"description": "Similar to sprintf, but does expansion of UDIM or UVTILE texture filename expansion."
	},
	"getpointbbox_center: geometry": {
			"prefix": "getpointbbox_center(geometry)",
			"body": "getpointbbox_center(${1:geometry})",
			"scope": "source.vex",
			"description": "Returns the center of the bounding box for the geometry."
	},
	"getpointbbox_center: geometry pointgroup": {
			"prefix": "getpointbbox_center(geometry, pointgroup)",
			"body": "getpointbbox_center(${1:geometry}, ${2:pointgroup})",
			"scope": "source.vex",
			"description": "Returns the center of the bounding box for the geometry."
	},
	"chsetlength: clip_length": {
			"prefix": "chsetlength(clip_length)",
			"body": "chsetlength(${1:clip_length})",
			"scope": "source.vex",
			"description": "Sets the length of the CHOP channel data."
	},
	"volumesample: geometry primnum pos": {
			"prefix": "volumesample(geometry, primnum, pos)",
			"body": "volumesample(${1:geometry}, ${2:primnum}, ${3:pos})",
			"scope": "source.vex",
			"description": "Samples the volume primitive\u2019s value."
	},
	"volumesample: geometry volumename pos": {
			"prefix": "volumesample(geometry, volumename, pos)",
			"body": "volumesample(${1:geometry}, ${2:volumename}, ${3:pos})",
			"scope": "source.vex",
			"description": "Samples the volume primitive\u2019s value."
	},
	"wo_vspace: v": {
			"prefix": "wo_vspace(v)",
			"body": "wo_vspace(${1:v})",
			"scope": "source.vex",
			"description": "Transforms a direction vector from World to Object space."
	},
	"assert_enabled: ": {
			"prefix": "assert_enabled()",
			"body": "assert_enabled()",
			"scope": "source.vex",
			"description": "Returns 1 if the VEX assertions are enabled (see HOUDINI_VEX_ASSERT) or 0 if assertions are disabled. Used the implement the assert macro."
	},
	"pcfilter: handle channel_name ...": {
			"prefix": "pcfilter(handle, channel_name, ...)",
			"body": "pcfilter(${1:handle}, ${2:channel_name}, ${3:...})",
			"scope": "source.vex",
			"description": "Filters points found by pcopen using a simple reconstruction filter."
	},
	"onoise: pos": {
			"prefix": "onoise(pos)",
			"body": "onoise(${1:pos})",
			"scope": "source.vex",
			"description": "These functions are similar to wnoise and vnoise."
	},
	"onoise: pos turbulence rough atten": {
			"prefix": "onoise(pos, turbulence, rough, atten)",
			"body": "onoise(${1:pos}, ${2:turbulence}, ${3:rough}, ${4:atten})",
			"scope": "source.vex",
			"description": "These functions are similar to wnoise and vnoise."
	},
	"onoise: pos periodX periodY periodZ": {
			"prefix": "onoise(pos, periodX, periodY, periodZ)",
			"body": "onoise(${1:pos}, ${2:periodX}, ${3:periodY}, ${4:periodZ})",
			"scope": "source.vex",
			"description": "These functions are similar to wnoise and vnoise."
	},
	"onoise: pos periodX periodY periodZ turbulence rough atten": {
			"prefix": "onoise(pos, periodX, periodY, periodZ, turbulence, rough, atten)",
			"body": "onoise(${1:pos}, ${2:periodX}, ${3:periodY}, ${4:periodZ}, ${5:turbulence}, ${6:rough}, ${7:atten})",
			"scope": "source.vex",
			"description": "These functions are similar to wnoise and vnoise."
	},
	"usd_addcollectioninclude: stagehandle collectionpath path": {
			"prefix": "usd_addcollectioninclude(stagehandle, collectionpath, path)",
			"body": "usd_addcollectioninclude(${1:stagehandle}, ${2:collectionpath}, ${3:path})",
			"scope": "source.vex",
			"description": "Includes an object in the collection"
	},
	"sample_hemisphere: u": {
			"prefix": "sample_hemisphere(u)",
			"body": "sample_hemisphere(${1:u})",
			"scope": "source.vex",
			"description": "Generates a unit vector, optionally biased, within a hemisphere, given a vector2 of uniform numbers between 0 and 1."
	},
	"sample_hemisphere: center u": {
			"prefix": "sample_hemisphere(center, u)",
			"body": "sample_hemisphere(${1:center}, ${2:u})",
			"scope": "source.vex",
			"description": "Generates a unit vector, optionally biased, within a hemisphere, given a vector2 of uniform numbers between 0 and 1."
	},
	"sample_hemisphere: bias u": {
			"prefix": "sample_hemisphere(bias, u)",
			"body": "sample_hemisphere(${1:bias}, ${2:u})",
			"scope": "source.vex",
			"description": "Generates a unit vector, optionally biased, within a hemisphere, given a vector2 of uniform numbers between 0 and 1."
	},
	"sample_hemisphere: center bias u": {
			"prefix": "sample_hemisphere(center, bias, u)",
			"body": "sample_hemisphere(${1:center}, ${2:bias}, ${3:u})",
			"scope": "source.vex",
			"description": "Generates a unit vector, optionally biased, within a hemisphere, given a vector2 of uniform numbers between 0 and 1."
	},
	"qinvert: quaternion": {
			"prefix": "qinvert(quaternion)",
			"body": "qinvert(${1:quaternion})",
			"scope": "source.vex",
			"description": "Inverts a quaternion rotation."
	},
	"isshadowray: ": {
			"prefix": "isshadowray()",
			"body": "isshadowray()",
			"scope": "source.vex",
			"description": "Returns 1 if the shader is being called to evaluate opacity for\nshadow rays, or 0 if the shader is being called to evaluate for surface\ncolor."
	},
	"split: s": {
			"prefix": "split(s)",
			"body": "split(${1:s})",
			"scope": "source.vex",
			"description": "Splits a string into tokens."
	},
	"split: s separators": {
			"prefix": "split(s, separators)",
			"body": "split(${1:s}, ${2:separators})",
			"scope": "source.vex",
			"description": "Splits a string into tokens."
	},
	"split: s separators maxsplits": {
			"prefix": "split(s, separators, maxsplits)",
			"body": "split(${1:s}, ${2:separators}, ${3:maxsplits})",
			"scope": "source.vex",
			"description": "Splits a string into tokens."
	},
	"usd_primvarlen: stage primpath name": {
			"prefix": "usd_primvarlen(stage, primpath, name)",
			"body": "usd_primvarlen(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Returns the length of the array primvar."
	},
	"usd_primvarlen: stage primpath name timecode": {
			"prefix": "usd_primvarlen(stage, primpath, name, timecode)",
			"body": "usd_primvarlen(${1:stage}, ${2:primpath}, ${3:name}, ${4:timecode})",
			"scope": "source.vex",
			"description": "Returns the length of the array primvar."
	},
	"depthmap: filename uvw": {
			"prefix": "depthmap(filename, uvw)",
			"body": "depthmap(${1:filename}, ${2:uvw})",
			"scope": "source.vex",
			"description": "The depthmap functions work on an image which was rendered as a\nz-depth image from mantra."
	},
	"depthmap: filename u v": {
			"prefix": "depthmap(filename, u, v)",
			"body": "depthmap(${1:filename}, ${2:u}, ${3:v})",
			"scope": "source.vex",
			"description": "The depthmap functions work on an image which was rendered as a\nz-depth image from mantra."
	},
	"specularBRDF: L N V rough": {
			"prefix": "specularBRDF(L, N, V, rough)",
			"body": "specularBRDF(${1:L}, ${2:N}, ${3:V}, ${4:rough})",
			"scope": "source.vex",
			"description": "Returns the computed BRDFs for the different lighting models used in VEX shading."
	},
	"volumeindexactive: geometry primnum voxel": {
			"prefix": "volumeindexactive(geometry, primnum, voxel)",
			"body": "volumeindexactive(${1:geometry}, ${2:primnum}, ${3:voxel})",
			"scope": "source.vex",
			"description": "Gets the active setting of a specific voxel."
	},
	"volumeindexactive: geometry volumename voxel": {
			"prefix": "volumeindexactive(geometry, volumename, voxel)",
			"body": "volumeindexactive(${1:geometry}, ${2:volumename}, ${3:voxel})",
			"scope": "source.vex",
			"description": "Gets the active setting of a specific voxel."
	},
	"hedge_nextequiv: geometry hedge": {
			"prefix": "hedge_nextequiv(geometry, hedge)",
			"body": "hedge_nextequiv(${1:geometry}, ${2:hedge})",
			"scope": "source.vex",
			"description": "Returns the next half-edges equivalent to a given half-edge."
	},
	"iyres: opinput": {
			"prefix": "iyres(opinput)",
			"body": "iyres(${1:opinput})",
			"scope": "source.vex",
			"description": "Returns the Y resolution of the specified input."
	},
	"predicate_orient2d: a b c": {
			"prefix": "predicate_orient2d(a, b, c)",
			"body": "predicate_orient2d(${1:a}, ${2:b}, ${3:c})",
			"scope": "source.vex",
			"description": "Determines the orientation of a point with respect to a line."
	},
	"isfinite: x": {
			"prefix": "isfinite(x)",
			"body": "isfinite(${1:x})",
			"scope": "source.vex",
			"description": "Checks whether a value is a normal finite number."
	},
	"print_once: msg ...": {
			"prefix": "print_once(msg, ...)",
			"body": "print_once(${1:msg}, ${2:...})",
			"scope": "source.vex",
			"description": "Prints a message only once, even in a loop."
	},
	"agentrigfindchannel: geometry prim channelname": {
			"prefix": "agentrigfindchannel(geometry, prim, channelname)",
			"body": "agentrigfindchannel(${1:geometry}, ${2:prim}, ${3:channelname})",
			"scope": "source.vex",
			"description": "Finds the index of a channel in an agent primitive\u2019s rig."
	},
	"addattrib: geohandle attribclass name defvalue": {
			"prefix": "addattrib(geohandle, attribclass, name, defvalue)",
			"body": "addattrib(${1:geohandle}, ${2:attribclass}, ${3:name}, ${4:defvalue})",
			"scope": "source.vex",
			"description": "Adds an attribute to a geometry."
	},
	"atan2: y x": {
			"prefix": "atan2(y, x)",
			"body": "atan2(${1:y}, ${2:x})",
			"scope": "source.vex",
			"description": "Returns the inverse tangent of y/x."
	},
	"getpointbbox_size: geometry": {
			"prefix": "getpointbbox_size(geometry)",
			"body": "getpointbbox_size(${1:geometry})",
			"scope": "source.vex",
			"description": "Returns the size of the bounding box for the geometry."
	},
	"getpointbbox_size: geometry pointgroup": {
			"prefix": "getpointbbox_size(geometry, pointgroup)",
			"body": "getpointbbox_size(${1:geometry}, ${2:pointgroup})",
			"scope": "source.vex",
			"description": "Returns the size of the bounding box for the geometry."
	},
	"getattrib: geometry attribclass attribute_name elemnum success": {
			"prefix": "getattrib(geometry, attribclass, attribute_name, elemnum, success)",
			"body": "getattrib(${1:geometry}, ${2:attribclass}, ${3:attribute_name}, ${4:elemnum}, ${5:success})",
			"scope": "source.vex",
			"description": "Reads an attribute value from geometry, with validity check."
	},
	"hedge_presrcpoint: geometry hedge": {
			"prefix": "hedge_presrcpoint(geometry, hedge)",
			"body": "hedge_presrcpoint(${1:geometry}, ${2:hedge})",
			"scope": "source.vex",
			"description": "Returns the point into which the vertex that precedes the source vertex of a half-edge in its primitive is wired."
	},
	"binput: u v ...": {
			"prefix": "binput(u, v, ...)",
			"body": "binput(${1:u}, ${2:v}, ${3:...})",
			"scope": "source.vex",
			"description": "Samples a 2\u00d72 pixel block around the given UV position, and bilinearly interpolates these pixels."
	},
	"binput: comp u v ...": {
			"prefix": "binput(comp, u, v, ...)",
			"body": "binput(${1:comp}, ${2:u}, ${3:v}, ${4:...})",
			"scope": "source.vex",
			"description": "Samples a 2\u00d72 pixel block around the given UV position, and bilinearly interpolates these pixels."
	},
	"binput: opinput plane u v ...": {
			"prefix": "binput(opinput, plane, u, v, ...)",
			"body": "binput(${1:opinput}, ${2:plane}, ${3:u}, ${4:v}, ${5:...})",
			"scope": "source.vex",
			"description": "Samples a 2\u00d72 pixel block around the given UV position, and bilinearly interpolates these pixels."
	},
	"binput: opinput plane comp u v ...": {
			"prefix": "binput(opinput, plane, comp, u, v, ...)",
			"body": "binput(${1:opinput}, ${2:plane}, ${3:comp}, ${4:u}, ${5:v}, ${6:...})",
			"scope": "source.vex",
			"description": "Samples a 2\u00d72 pixel block around the given UV position, and bilinearly interpolates these pixels."
	},
	"binput: opinput plane array_index comp u v frame ...": {
			"prefix": "binput(opinput, plane, array_index, comp, u, v, frame, ...)",
			"body": "binput(${1:opinput}, ${2:plane}, ${3:array_index}, ${4:comp}, ${5:u}, ${6:v}, ${7:frame}, ${8:...})",
			"scope": "source.vex",
			"description": "Samples a 2\u00d72 pixel block around the given UV position, and bilinearly interpolates these pixels."
	},
	"binput: opinput plane array_index u v frame ...": {
			"prefix": "binput(opinput, plane, array_index, u, v, frame, ...)",
			"body": "binput(${1:opinput}, ${2:plane}, ${3:array_index}, ${4:u}, ${5:v}, ${6:frame}, ${7:...})",
			"scope": "source.vex",
			"description": "Samples a 2\u00d72 pixel block around the given UV position, and bilinearly interpolates these pixels."
	},
	"cinput: u v ...": {
			"prefix": "cinput(u, v, ...)",
			"body": "cinput(${1:u}, ${2:v}, ${3:...})",
			"scope": "source.vex",
			"description": "Samples the exact (unfiltered) pixel color at the given coordinates."
	},
	"cinput: component u v ...": {
			"prefix": "cinput(component, u, v, ...)",
			"body": "cinput(${1:component}, ${2:u}, ${3:v}, ${4:...})",
			"scope": "source.vex",
			"description": "Samples the exact (unfiltered) pixel color at the given coordinates."
	},
	"cinput: opinput planeindex u v ...": {
			"prefix": "cinput(opinput, planeindex, u, v, ...)",
			"body": "cinput(${1:opinput}, ${2:planeindex}, ${3:u}, ${4:v}, ${5:...})",
			"scope": "source.vex",
			"description": "Samples the exact (unfiltered) pixel color at the given coordinates."
	},
	"cinput: opinput planeindex component u v ...": {
			"prefix": "cinput(opinput, planeindex, component, u, v, ...)",
			"body": "cinput(${1:opinput}, ${2:planeindex}, ${3:component}, ${4:u}, ${5:v}, ${6:...})",
			"scope": "source.vex",
			"description": "Samples the exact (unfiltered) pixel color at the given coordinates."
	},
	"cinput: opinput planeindex arrayindex u v frame ...": {
			"prefix": "cinput(opinput, planeindex, arrayindex, u, v, frame, ...)",
			"body": "cinput(${1:opinput}, ${2:planeindex}, ${3:arrayindex}, ${4:u}, ${5:v}, ${6:frame}, ${7:...})",
			"scope": "source.vex",
			"description": "Samples the exact (unfiltered) pixel color at the given coordinates."
	},
	"cinput: opinput planeindex arrayindex component u v frame ...": {
			"prefix": "cinput(opinput, planeindex, arrayindex, component, u, v, frame, ...)",
			"body": "cinput(${1:opinput}, ${2:planeindex}, ${3:arrayindex}, ${4:component}, ${5:u}, ${6:v}, ${7:frame}, ${8:...})",
			"scope": "source.vex",
			"description": "Samples the exact (unfiltered) pixel color at the given coordinates."
	},
	"slerp: q1 q2 bias": {
			"prefix": "slerp(q1, q2, bias)",
			"body": "slerp(${1:q1}, ${2:q2}, ${3:bias})",
			"scope": "source.vex",
			"description": "Quaternion blend between q1 and q2 based on the bias."
	},
	"slerp: qs weights": {
			"prefix": "slerp(qs, weights)",
			"body": "slerp(${1:qs}, ${2:weights})",
			"scope": "source.vex",
			"description": "Quaternion blend between q1 and q2 based on the bias."
	},
	"slerp: m1 m2 bias": {
			"prefix": "slerp(m1, m2, bias)",
			"body": "slerp(${1:m1}, ${2:m2}, ${3:bias})",
			"scope": "source.vex",
			"description": "Quaternion blend between q1 and q2 based on the bias."
	},
	"slerp: ms weights": {
			"prefix": "slerp(ms, weights)",
			"body": "slerp(${1:ms}, ${2:weights})",
			"scope": "source.vex",
			"description": "Quaternion blend between q1 and q2 based on the bias."
	},
	"has_udim: path": {
			"prefix": "has_udim(path)",
			"body": "has_udim(${1:path})",
			"scope": "source.vex",
			"description": "Test string for UDIM or UVTILE patterns."
	},
	"getgroupid: ": {
			"prefix": "getgroupid()",
			"body": "getgroupid()",
			"scope": "source.vex",
			"description": "Returns group id containing current primitive."
	},
	"usd_primvarinterpolation: stage primpath name": {
			"prefix": "usd_primvarinterpolation(stage, primpath, name)",
			"body": "usd_primvarinterpolation(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Returns the element size of the primvar."
	},
	"sample_orientation_uniform: u": {
			"prefix": "sample_orientation_uniform(u)",
			"body": "sample_orientation_uniform(${1:u})",
			"scope": "source.vex",
			"description": "Generates a uniform unit vector4, given a vector of uniform numbers between 0 and 1."
	},
	"setagentclipweights: geohandle prim clipweights": {
			"prefix": "setagentclipweights(geohandle, prim, clipweights)",
			"body": "setagentclipweights(${1:geohandle}, ${2:prim}, ${3:clipweights})",
			"scope": "source.vex",
			"description": "Sets the blend weights for an agent primitive\u2019s animation clips."
	},
	"attrib: geometry attribclass name elemnum": {
			"prefix": "attrib(geometry, attribclass, name, elemnum)",
			"body": "attrib(${1:geometry}, ${2:attribclass}, ${3:name}, ${4:elemnum})",
			"scope": "source.vex",
			"description": "Reads the value of an attribute from geometry."
	},
	"random_ihash: seed": {
			"prefix": "random_ihash(seed)",
			"body": "random_ihash(${1:seed})",
			"scope": "source.vex",
			"description": "Hashes integer numbers to integers."
	},
	"minpos: geometry point": {
			"prefix": "minpos(geometry, point)",
			"body": "minpos(${1:geometry}, ${2:point})",
			"scope": "source.vex",
			"description": "Finds the closest position on the surface of a geometry."
	},
	"minpos: geometry point maxdist": {
			"prefix": "minpos(geometry, point, maxdist)",
			"body": "minpos(${1:geometry}, ${2:point}, ${3:maxdist})",
			"scope": "source.vex",
			"description": "Finds the closest position on the surface of a geometry."
	},
	"minpos: geometry primgroup point": {
			"prefix": "minpos(geometry, primgroup, point)",
			"body": "minpos(${1:geometry}, ${2:primgroup}, ${3:point})",
			"scope": "source.vex",
			"description": "Finds the closest position on the surface of a geometry."
	},
	"minpos: geometry primgroup point maxdist": {
			"prefix": "minpos(geometry, primgroup, point, maxdist)",
			"body": "minpos(${1:geometry}, ${2:primgroup}, ${3:point}, ${4:maxdist})",
			"scope": "source.vex",
			"description": "Finds the closest position on the surface of a geometry."
	},
	"usd_addrelationshiptarget: stagehandle primpath name target": {
			"prefix": "usd_addrelationshiptarget(stagehandle, primpath, name, target)",
			"body": "usd_addrelationshiptarget(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:target})",
			"scope": "source.vex",
			"description": "Adds a target to the primitive\u2019s relationship"
	},
	"velocityname: ": {
			"prefix": "velocityname()",
			"body": "velocityname()",
			"scope": "source.vex",
			"description": "Returns the default name of the velocity plane (as it appears in the\ncompositor preferences)."
	},
	"usd_metadata: stage path name": {
			"prefix": "usd_metadata(stage, path, name)",
			"body": "usd_metadata(${1:stage}, ${2:path}, ${3:name})",
			"scope": "source.vex",
			"description": "Reads the value of metadata from the USD object."
	},
	"fit10: value nmin nmax": {
			"prefix": "fit10(value, nmin, nmax)",
			"body": "fit10(${1:value}, ${2:nmin}, ${3:nmax})",
			"scope": "source.vex",
			"description": "Takes the value in the range (1, 0) and shifts it to the corresponding value in a new range."
	},
	"usd_variantselection: stage primpath variantset": {
			"prefix": "usd_variantselection(stage, primpath, variantset)",
			"body": "usd_variantselection(${1:stage}, ${2:primpath}, ${3:variantset})",
			"scope": "source.vex",
			"description": "Returns the currently selected variant in a given variant set."
	},
	"usd_setdrawmode: stagehandle primpath mode": {
			"prefix": "usd_setdrawmode(stagehandle, primpath, mode)",
			"body": "usd_setdrawmode(${1:stagehandle}, ${2:primpath}, ${3:mode})",
			"scope": "source.vex",
			"description": "Sets the primitive\u2019s draw mode."
	},
	"pcfarthest: handle": {
			"prefix": "pcfarthest(handle)",
			"body": "pcfarthest(${1:handle})",
			"scope": "source.vex",
			"description": "Returns the distance to the farthest point found in the search\nperformed by pcopen."
	},
	"usd_setprimvarindices: stagehandle primpath name indices": {
			"prefix": "usd_setprimvarindices(stagehandle, primpath, name, indices)",
			"body": "usd_setprimvarindices(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:indices})",
			"scope": "source.vex",
			"description": "Sets the indices for the given primvar."
	},
	"agentfindtransformgroup: geometry prim transformgroup": {
			"prefix": "agentfindtransformgroup(geometry, prim, transformgroup)",
			"body": "agentfindtransformgroup(${1:geometry}, ${2:prim}, ${3:transformgroup})",
			"scope": "source.vex",
			"description": "Finds the index of a transform group in an agent\u2019s definition."
	},
	"getfogname: ": {
			"prefix": "getfogname()",
			"body": "getfogname()",
			"scope": "source.vex",
			"description": "Returns the name of the current object whose shader is being run."
	},
	"planeindex: planename": {
			"prefix": "planeindex(planename)",
			"body": "planeindex(${1:planename})",
			"scope": "source.vex",
			"description": "Returns the index of the plane specified by the parameter, starting\nat zero."
	},
	"volumegradient: geometry primnum pos": {
			"prefix": "volumegradient(geometry, primnum, pos)",
			"body": "volumegradient(${1:geometry}, ${2:primnum}, ${3:pos})",
			"scope": "source.vex",
			"description": "Calculates the volume primitive\u2019s gradient."
	},
	"volumegradient: geometry volumename pos": {
			"prefix": "volumegradient(geometry, volumename, pos)",
			"body": "volumegradient(${1:geometry}, ${2:volumename}, ${3:pos})",
			"scope": "source.vex",
			"description": "Calculates the volume primitive\u2019s gradient."
	},
	"henyeygreenstein: anisotropic_bias ...": {
			"prefix": "henyeygreenstein(anisotropic_bias, ...)",
			"body": "henyeygreenstein(${1:anisotropic_bias}, ${2:...})",
			"scope": "source.vex",
			"description": "Returns an anisotropic volumetric BSDF, which can scatter light forward or backward."
	},
	"pcgenerate: filename npoints": {
			"prefix": "pcgenerate(filename, npoints)",
			"body": "pcgenerate(${1:filename}, ${2:npoints})",
			"scope": "source.vex",
			"description": "Generates a point cloud."
	},
	"vertexindex: geometry primnum vertex": {
			"prefix": "vertexindex(geometry, primnum, vertex)",
			"body": "vertexindex(${1:geometry}, ${2:primnum}, ${3:vertex})",
			"scope": "source.vex",
			"description": "Converts a primitive/vertex pair into a linear vertex."
	},
	"chi: channel": {
			"prefix": "chi(channel)",
			"body": "chi(${1:channel})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"chi: channel time": {
			"prefix": "chi(channel, time)",
			"body": "chi(${1:channel}, ${2:time})",
			"scope": "source.vex",
			"description": "Evaluates a channel (or parameter) and return its value."
	},
	"hedge_next: geometry hedge": {
			"prefix": "hedge_next(geometry, hedge)",
			"body": "hedge_next(${1:geometry}, ${2:hedge})",
			"scope": "source.vex",
			"description": "Returns the half-edge that follows a given half-edge in its polygon."
	},
	"usd_blockprimvarindices: stagehandle primpath name": {
			"prefix": "usd_blockprimvarindices(stagehandle, primpath, name)",
			"body": "usd_blockprimvarindices(${1:stagehandle}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Blocks the primvar."
	},
	"invert: m": {
			"prefix": "invert(m)",
			"body": "invert(${1:m})",
			"scope": "source.vex",
			"description": "Inverts a matrix."
	},
	"chstartf: ": {
			"prefix": "chstartf()",
			"body": "chstartf()",
			"scope": "source.vex",
			"description": "Returns the frame corresponding to the first sample of the input\nspecified."
	},
	"chstartf: opinput": {
			"prefix": "chstartf(opinput)",
			"body": "chstartf(${1:opinput})",
			"scope": "source.vex",
			"description": "Returns the frame corresponding to the first sample of the input\nspecified."
	},
	"chinputlimits: opinput channel channel_min channel_max": {
			"prefix": "chinputlimits(opinput, channel, channel_min, channel_max)",
			"body": "chinputlimits(${1:opinput}, ${2:channel}, ${3:channel_min}, ${4:channel_max})",
			"scope": "source.vex",
			"description": "Computes the minimum and maximum value of samples in an input channel."
	},
	"fit11: value nmin nmax": {
			"prefix": "fit11(value, nmin, nmax)",
			"body": "fit11(${1:value}, ${2:nmin}, ${3:nmax})",
			"scope": "source.vex",
			"description": "Takes the value in the range (-1, 1) and shifts it to the corresponding value in a new range."
	},
	"agentclipchannelnames: geometry prim clipname": {
			"prefix": "agentclipchannelnames(geometry, prim, clipname)",
			"body": "agentclipchannelnames(${1:geometry}, ${2:prim}, ${3:clipname})",
			"scope": "source.vex",
			"description": "Returns the names of the channels in an agent\u2019s animation clip."
	},
	"hscript_rand: seed": {
			"prefix": "hscript_rand(seed)",
			"body": "hscript_rand(${1:seed})",
			"scope": "source.vex",
			"description": "Produces the exact same results as the Houdini expression function of\nthe same name."
	},
	"getblurP: delta": {
			"prefix": "getblurP(delta)",
			"body": "getblurP(${1:delta})",
			"scope": "source.vex",
			"description": "Returns the blurred point position (P) vector at a fractional time within the motion blur exposure."
	},
	"tet_faceindex: faceno vtxno": {
			"prefix": "tet_faceindex(faceno, vtxno)",
			"body": "tet_faceindex(${1:faceno}, ${2:vtxno})",
			"scope": "source.vex",
			"description": "Returns vertex indices of each face of a tetrahedron."
	},
	"nextsample: sid sx sy ...": {
			"prefix": "nextsample(sid, sx, sy, ...)",
			"body": "nextsample(${1:sid}, ${2:sx}, ${3:sy}, ${4:...})",
			"scope": "source.vex",
			"description": ""
	},
	"nextsample: sid svec ...": {
			"prefix": "nextsample(sid, svec, ...)",
			"body": "nextsample(${1:sid}, ${2:svec}, ${3:...})",
			"scope": "source.vex",
			"description": ""
	},
	"iplanename: opinput planeindex": {
			"prefix": "iplanename(opinput, planeindex)",
			"body": "iplanename(${1:opinput}, ${2:planeindex})",
			"scope": "source.vex",
			"description": "Returns the name of the plane specified by the planeindex of the given input"
	},
	"chendt: opinput": {
			"prefix": "chendt(opinput)",
			"body": "chendt(${1:opinput})",
			"scope": "source.vex",
			"description": "Returns the time corresponding to the last sample of the input\nspecified."
	},
	"neighbourcount: geometry point_num": {
			"prefix": "neighbourcount(geometry, point_num)",
			"body": "neighbourcount(${1:geometry}, ${2:point_num})",
			"scope": "source.vex",
			"description": "Returns the number of points that are connected to the specified point."
	},
	"usd_addinversetotransformorder: stagehandle primpath name": {
			"prefix": "usd_addinversetotransformorder(stagehandle, primpath, name)",
			"body": "usd_addinversetotransformorder(${1:stagehandle}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Appends an inversed transform operation to the primitive\u2019s transform order"
	},
	"usd_getbbox_size: stage primpath purpose": {
			"prefix": "usd_getbbox_size(stage, primpath, purpose)",
			"body": "usd_getbbox_size(${1:stage}, ${2:primpath}, ${3:purpose})",
			"scope": "source.vex",
			"description": "Returns the size of the bounding box for the primitive."
	},
	"texture3dBox: filename channel min max ...": {
			"prefix": "texture3dBox(filename, channel, min, max, ...)",
			"body": "texture3dBox(${1:filename}, ${2:channel}, ${3:min}, ${4:max}, ${5:...})",
			"scope": "source.vex",
			"description": "This function queries the 3D texture map specified and returns the\nbounding box information of the file."
	},
	"nrandom: ...": {
			"prefix": "nrandom(...)",
			"body": "nrandom(${1:...})",
			"scope": "source.vex",
			"description": "Non-deterministic random number generation function."
	},
	"nrandom: x y ...": {
			"prefix": "nrandom(x, y, ...)",
			"body": "nrandom(${1:x}, ${2:y}, ${3:...})",
			"scope": "source.vex",
			"description": "Non-deterministic random number generation function."
	},
	"agentworldtransforms: geometry prim": {
			"prefix": "agentworldtransforms(geometry, prim)",
			"body": "agentworldtransforms(${1:geometry}, ${2:prim})",
			"scope": "source.vex",
			"description": "Returns the current world space transforms of an agent primitive."
	},
	"usd_addtransform: stagehandle primpath suffix xform": {
			"prefix": "usd_addtransform(stagehandle, primpath, suffix, xform)",
			"body": "usd_addtransform(${1:stagehandle}, ${2:primpath}, ${3:suffix}, ${4:xform})",
			"scope": "source.vex",
			"description": "Applies a transformation to the primitive"
	},
	"environment: texture_filename reflect_dir ...": {
			"prefix": "environment(texture_filename, reflect_dir, ...)",
			"body": "environment(${1:texture_filename}, ${2:reflect_dir}, ${3:...})",
			"scope": "source.vex",
			"description": "Returns the color of the environment texture."
	},
	"environment: texture_filename reflect_dir0 reflect_dir1 reflect_dir2 reflect_dir3 ...": {
			"prefix": "environment(texture_filename, reflect_dir0, reflect_dir1, reflect_dir2, reflect_dir3, ...)",
			"body": "environment(${1:texture_filename}, ${2:reflect_dir0}, ${3:reflect_dir1}, ${4:reflect_dir2}, ${5:reflect_dir3}, ${6:...})",
			"scope": "source.vex",
			"description": "Returns the color of the environment texture."
	},
	"environment: texture_filename reflect_dir filter_angle ...": {
			"prefix": "environment(texture_filename, reflect_dir, filter_angle, ...)",
			"body": "environment(${1:texture_filename}, ${2:reflect_dir}, ${3:filter_angle}, ${4:...})",
			"scope": "source.vex",
			"description": "Returns the color of the environment texture."
	},
	"chreadbuf: index": {
			"prefix": "chreadbuf(index)",
			"body": "chreadbuf(${1:index})",
			"scope": "source.vex",
			"description": "Returns the value of CHOP context temporary buffer at the specified index."
	},
	"usd_attribnames: stage primpath": {
			"prefix": "usd_attribnames(stage, primpath)",
			"body": "usd_attribnames(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Returns the names of the attributes available on the primitive."
	},
	"matchvex_blinn: exponent ...": {
			"prefix": "matchvex_blinn(exponent, ...)",
			"body": "matchvex_blinn(${1:exponent}, ${2:...})",
			"scope": "source.vex",
			"description": "Returns a BSDF that matches the output of the traditional VEX blinn function."
	},
	"matchvex_blinn: nml exponent ...": {
			"prefix": "matchvex_blinn(nml, exponent, ...)",
			"body": "matchvex_blinn(${1:nml}, ${2:exponent}, ${3:...})",
			"scope": "source.vex",
			"description": "Returns a BSDF that matches the output of the traditional VEX blinn function."
	},
	"usd_primvarattribname: stage name": {
			"prefix": "usd_primvarattribname(stage, name)",
			"body": "usd_primvarattribname(${1:stage}, ${2:name})",
			"scope": "source.vex",
			"description": "Returns the namespaced attribute name for the given primvar."
	},
	"sample_circle_uniform: u": {
			"prefix": "sample_circle_uniform(u)",
			"body": "sample_circle_uniform(${1:u})",
			"scope": "source.vex",
			"description": "Generates a uniform vector2 with length < 1, given a vector2 of uniform numbers between 0 and 1."
	},
	"usd_blockrelationship: stagehandle primpath name": {
			"prefix": "usd_blockrelationship(stagehandle, primpath, name)",
			"body": "usd_blockrelationship(${1:stagehandle}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Blocks the primitive\u2019s relationship"
	},
	"length2: v": {
			"prefix": "length2(v)",
			"body": "length2(${1:v})",
			"scope": "source.vex",
			"description": "Returns the squared distance of the vector or vector4."
	},
	"usd_getbbox_center: stage primpath purpose": {
			"prefix": "usd_getbbox_center(stage, primpath, purpose)",
			"body": "usd_getbbox_center(${1:stage}, ${2:primpath}, ${3:purpose})",
			"scope": "source.vex",
			"description": "Returns the center of the bounding box for the primitive."
	},
	"choplocal: filename channel sample": {
			"prefix": "choplocal(filename, channel, sample)",
			"body": "choplocal(${1:filename}, ${2:channel}, ${3:sample})",
			"scope": "source.vex",
			"description": "Returns the value of a CHOP local transform channel at the specified sample."
	},
	"getpackedtransform: input primnum": {
			"prefix": "getpackedtransform(input, primnum)",
			"body": "getpackedtransform(${1:input}, ${2:primnum})",
			"scope": "source.vex",
			"description": "Gets the transform of a packed primitive."
	},
	"slice: s start end": {
			"prefix": "slice(s, start, end)",
			"body": "slice(${1:s}, ${2:start}, ${3:end})",
			"scope": "source.vex",
			"description": "Slices a sub-string or sub-array of a string or array."
	},
	"slice: s start end step": {
			"prefix": "slice(s, start, end, step)",
			"body": "slice(${1:s}, ${2:start}, ${3:end}, ${4:step})",
			"scope": "source.vex",
			"description": "Slices a sub-string or sub-array of a string or array."
	},
	"slice: s hasstart start hasend end hasstep step": {
			"prefix": "slice(s, hasstart, start, hasend, end, hasstep, step)",
			"body": "slice(${1:s}, ${2:hasstart}, ${3:start}, ${4:hasend}, ${5:end}, ${6:hasstep}, ${7:step})",
			"scope": "source.vex",
			"description": "Slices a sub-string or sub-array of a string or array."
	},
	"slice: array hasstart start hasend end hasstep step": {
			"prefix": "slice(array, hasstart, start, hasend, end, hasstep, step)",
			"body": "slice(${1:array}, ${2:hasstart}, ${3:start}, ${4:hasend}, ${5:end}, ${6:hasstep}, ${7:step})",
			"scope": "source.vex",
			"description": "Slices a sub-string or sub-array of a string or array."
	},
	"vertexattrib: geometry attribute_name linear_vertex_index success": {
			"prefix": "vertexattrib(geometry, attribute_name, linear_vertex_index, success)",
			"body": "vertexattrib(${1:geometry}, ${2:attribute_name}, ${3:linear_vertex_index}, ${4:success})",
			"scope": "source.vex",
			"description": "Reads a vertex attribute value from a geometry."
	},
	"find: haystack needle": {
			"prefix": "find(haystack, needle)",
			"body": "find(${1:haystack}, ${2:needle})",
			"scope": "source.vex",
			"description": "Finds an item in an array or string."
	},
	"find: haystack needle start": {
			"prefix": "find(haystack, needle, start)",
			"body": "find(${1:haystack}, ${2:needle}, ${3:start})",
			"scope": "source.vex",
			"description": "Finds an item in an array or string."
	},
	"find: haystack needle start end": {
			"prefix": "find(haystack, needle, start, end)",
			"body": "find(${1:haystack}, ${2:needle}, ${3:start}, ${4:end})",
			"scope": "source.vex",
			"description": "Finds an item in an array or string."
	},
	"find: array target": {
			"prefix": "find(array, target)",
			"body": "find(${1:array}, ${2:target})",
			"scope": "source.vex",
			"description": "Finds an item in an array or string."
	},
	"find: array target start": {
			"prefix": "find(array, target, start)",
			"body": "find(${1:array}, ${2:target}, ${3:start})",
			"scope": "source.vex",
			"description": "Finds an item in an array or string."
	},
	"find: array target start end": {
			"prefix": "find(array, target, start, end)",
			"body": "find(${1:array}, ${2:target}, ${3:start}, ${4:end})",
			"scope": "source.vex",
			"description": "Finds an item in an array or string."
	},
	"Dv: n ...": {
			"prefix": "Dv(n, ...)",
			"body": "Dv(${1:n}, ${2:...})",
			"scope": "source.vex",
			"description": "Returns the derivative of the given value with respect to V."
	},
	"xnoised: x v dvdx": {
			"prefix": "xnoised(x, v, dvdx)",
			"body": "xnoised(${1:x}, ${2:v}, ${3:dvdx})",
			"scope": "source.vex",
			"description": "Derivatives of Simplex Noise."
	},
	"xnoised: x y v dvdx dvdy": {
			"prefix": "xnoised(x, y, v, dvdx, dvdy)",
			"body": "xnoised(${1:x}, ${2:y}, ${3:v}, ${4:dvdx}, ${5:dvdy})",
			"scope": "source.vex",
			"description": "Derivatives of Simplex Noise."
	},
	"xnoised: xyz v dvdx dvdy dvdz": {
			"prefix": "xnoised(xyz, v, dvdx, dvdy, dvdz)",
			"body": "xnoised(${1:xyz}, ${2:v}, ${3:dvdx}, ${4:dvdy}, ${5:dvdz})",
			"scope": "source.vex",
			"description": "Derivatives of Simplex Noise."
	},
	"xnoised: xyzw v dvdx dvdy dvdz dvdw": {
			"prefix": "xnoised(xyzw, v, dvdx, dvdy, dvdz, dvdw)",
			"body": "xnoised(${1:xyzw}, ${2:v}, ${3:dvdx}, ${4:dvdy}, ${5:dvdz}, ${6:dvdw})",
			"scope": "source.vex",
			"description": "Derivatives of Simplex Noise."
	},
	"assign: c1 c2 source": {
			"prefix": "assign(c1, c2, source)",
			"body": "assign(${1:c1}, ${2:c2}, ${3:source})",
			"scope": "source.vex",
			"description": "An efficient way of extracting the components of a vector or matrix into float variables."
	},
	"assign: c1 c2 c3 source": {
			"prefix": "assign(c1, c2, c3, source)",
			"body": "assign(${1:c1}, ${2:c2}, ${3:c3}, ${4:source})",
			"scope": "source.vex",
			"description": "An efficient way of extracting the components of a vector or matrix into float variables."
	},
	"assign: c1 c2 c3 c4 source": {
			"prefix": "assign(c1, c2, c3, c4, source)",
			"body": "assign(${1:c1}, ${2:c2}, ${3:c3}, ${4:c4}, ${5:source})",
			"scope": "source.vex",
			"description": "An efficient way of extracting the components of a vector or matrix into float variables."
	},
	"assign: c1 c2 c3 c4 c5 c6 c7 c8 c9 source": {
			"prefix": "assign(c1, c2, c3, c4, c5, c6, c7, c8, c9, source)",
			"body": "assign(${1:c1}, ${2:c2}, ${3:c3}, ${4:c4}, ${5:c5}, ${6:c6}, ${7:c7}, ${8:c8}, ${9:c9}, ${10:source})",
			"scope": "source.vex",
			"description": "An efficient way of extracting the components of a vector or matrix into float variables."
	},
	"assign: c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 c11 c12 c13 c14 c15 c16 source": {
			"prefix": "assign(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, source)",
			"body": "assign(${1:c1}, ${2:c2}, ${3:c3}, ${4:c4}, ${5:c5}, ${6:c6}, ${7:c7}, ${8:c8}, ${9:c9}, ${10:c10}, ${11:c11}, ${12:c12}, ${13:c13}, ${14:c14}, ${15:c15}, ${16:c16}, ${17:source})",
			"scope": "source.vex",
			"description": "An efficient way of extracting the components of a vector or matrix into float variables."
	},
	"agentworldtransform: geometry prim transform": {
			"prefix": "agentworldtransform(geometry, prim, transform)",
			"body": "agentworldtransform(${1:geometry}, ${2:prim}, ${3:transform})",
			"scope": "source.vex",
			"description": "Returns the current world space transform of an agent primitive\u2019s bone."
	},
	"intersect_all: geometry group orig dir pos prim uvw tol ttol": {
			"prefix": "intersect_all(geometry, group, orig, dir, pos, prim, uvw, tol, ttol)",
			"body": "intersect_all(${1:geometry}, ${2:group}, ${3:orig}, ${4:dir}, ${5:pos}, ${6:prim}, ${7:uvw}, ${8:tol}, ${9:ttol})",
			"scope": "source.vex",
			"description": "Computes all intersections of the specified ray with geometry."
	},
	"phonglobe: dir exponent ...": {
			"prefix": "phonglobe(dir, exponent, ...)",
			"body": "phonglobe(${1:dir}, ${2:exponent}, ${3:...})",
			"scope": "source.vex",
			"description": ""
	},
	"phonglobe: nml dir exponent ...": {
			"prefix": "phonglobe(nml, dir, exponent, ...)",
			"body": "phonglobe(${1:nml}, ${2:dir}, ${3:exponent}, ${4:...})",
			"scope": "source.vex",
			"description": ""
	},
	"phonglobe: dir exponentx exponenty framex framey ...": {
			"prefix": "phonglobe(dir, exponentx, exponenty, framex, framey, ...)",
			"body": "phonglobe(${1:dir}, ${2:exponentx}, ${3:exponenty}, ${4:framex}, ${5:framey}, ${6:...})",
			"scope": "source.vex",
			"description": ""
	},
	"phonglobe: nml dir exponentx exponenty framex framey ...": {
			"prefix": "phonglobe(nml, dir, exponentx, exponenty, framex, framey, ...)",
			"body": "phonglobe(${1:nml}, ${2:dir}, ${3:exponentx}, ${4:exponenty}, ${5:framex}, ${6:framey}, ${7:...})",
			"scope": "source.vex",
			"description": ""
	},
	"mask_bsdf: b mask": {
			"prefix": "mask_bsdf(b, mask)",
			"body": "mask_bsdf(${1:b}, ${2:mask})",
			"scope": "source.vex",
			"description": "Returns new BSDF that only includes the components specified by the mask."
	},
	"shr: a bits": {
			"prefix": "shr(a, bits)",
			"body": "shr(${1:a}, ${2:bits})",
			"scope": "source.vex",
			"description": "Bit-shifts an integer right."
	},
	"smooth: value1 value2 amount": {
			"prefix": "smooth(value1, value2, amount)",
			"body": "smooth(${1:value1}, ${2:value2}, ${3:amount})",
			"scope": "source.vex",
			"description": "Computes ease in/out interpolation between values."
	},
	"smooth: value1 value2 amount rolloff": {
			"prefix": "smooth(value1, value2, amount, rolloff)",
			"body": "smooth(${1:value1}, ${2:value2}, ${3:amount}, ${4:rolloff})",
			"scope": "source.vex",
			"description": "Computes ease in/out interpolation between values."
	},
	"hscript_noise: pos": {
			"prefix": "hscript_noise(pos)",
			"body": "hscript_noise(${1:pos})",
			"scope": "source.vex",
			"description": "Generates noise matching the output of the Hscript noise() expression function."
	},
	"ninput: opinput plane component array_index u v frame ...": {
			"prefix": "ninput(opinput, plane, component, array_index, u, v, frame, ...)",
			"body": "ninput(${1:opinput}, ${2:plane}, ${3:component}, ${4:array_index}, ${5:u}, ${6:v}, ${7:frame}, ${8:...})",
			"scope": "source.vex",
			"description": "Reads a component from a pixel and its eight neighbors."
	},
	"pcimportbyidxv: handle channel_name idx": {
			"prefix": "pcimportbyidxv(handle, channel_name, idx)",
			"body": "pcimportbyidxv(${1:handle}, ${2:channel_name}, ${3:idx})",
			"scope": "source.vex",
			"description": "Imports channel data from a point cloud outside a pciterate or a pcunshaded loop."
	},
	"attribclass: geometry attribute_name": {
			"prefix": "attribclass(geometry, attribute_name)",
			"body": "attribclass(${1:geometry}, ${2:attribute_name})",
			"scope": "source.vex",
			"description": "Returns the class of a geometry attribute."
	},
	"idtoprim: geometry id": {
			"prefix": "idtoprim(geometry, id)",
			"body": "idtoprim(${1:geometry}, ${2:id})",
			"scope": "source.vex",
			"description": "Finds a primitive by its id attribute."
	},
	"max: value1 value2 ...": {
			"prefix": "max(value1, value2, ...)",
			"body": "max(${1:value1}, ${2:value2}, ${3:...})",
			"scope": "source.vex",
			"description": ""
	},
	"max: values": {
			"prefix": "max(values)",
			"body": "max(${1:values})",
			"scope": "source.vex",
			"description": ""
	},
	"max: value": {
			"prefix": "max(value)",
			"body": "max(${1:value})",
			"scope": "source.vex",
			"description": ""
	},
	"normal_bsdf: b": {
			"prefix": "normal_bsdf(b)",
			"body": "normal_bsdf(${1:b})",
			"scope": "source.vex",
			"description": "Returns the normal for the diffuse component of a BSDF."
	},
	"ptexture: map face_id ...": {
			"prefix": "ptexture(map, face_id, ...)",
			"body": "ptexture(${1:map}, ${2:face_id}, ${3:...})",
			"scope": "source.vex",
			"description": "Computes a filtered sample from a ptex texture map. Use texture instead."
	},
	"ptexture: map face_id s t ...": {
			"prefix": "ptexture(map, face_id, s, t, ...)",
			"body": "ptexture(${1:map}, ${2:face_id}, ${3:s}, ${4:t}, ${5:...})",
			"scope": "source.vex",
			"description": "Computes a filtered sample from a ptex texture map. Use texture instead."
	},
	"setagentworldtransform: geohandle prim transform index": {
			"prefix": "setagentworldtransform(geohandle, prim, transform, index)",
			"body": "setagentworldtransform(${1:geohandle}, ${2:prim}, ${3:transform}, ${4:index})",
			"scope": "source.vex",
			"description": "Overrides the world space transform of an agent primitive\u2019s bone."
	},
	"hscript_turb: pos depth": {
			"prefix": "hscript_turb(pos, depth)",
			"body": "hscript_turb(${1:pos}, ${2:depth})",
			"scope": "source.vex",
			"description": "Generates turbulence matching the output of the HScript turb() expression function."
	},
	"set: v1 v2": {
			"prefix": "set(v1, v2)",
			"body": "set(${1:v1}, ${2:v2})",
			"scope": "source.vex",
			"description": "Creates a new value based on its arguments, such as creating a vector from its components."
	},
	"set: v1 v2 v3": {
			"prefix": "set(v1, v2, v3)",
			"body": "set(${1:v1}, ${2:v2}, ${3:v3})",
			"scope": "source.vex",
			"description": "Creates a new value based on its arguments, such as creating a vector from its components."
	},
	"set: v1 v2 v3 v4": {
			"prefix": "set(v1, v2, v3, v4)",
			"body": "set(${1:v1}, ${2:v2}, ${3:v3}, ${4:v4})",
			"scope": "source.vex",
			"description": "Creates a new value based on its arguments, such as creating a vector from its components."
	},
	"set: v1 v2 v4 v4 v5 v6 v7 v8 v9": {
			"prefix": "set(v1, v2, v4, v4, v5, v6, v7, v8, v9)",
			"body": "set(${1:v1}, ${2:v2}, ${3:v4}, ${4:v4}, ${5:v5}, ${6:v6}, ${7:v7}, ${8:v8}, ${9:v9})",
			"scope": "source.vex",
			"description": "Creates a new value based on its arguments, such as creating a vector from its components."
	},
	"set: v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15 v16": {
			"prefix": "set(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16)",
			"body": "set(${1:v1}, ${2:v2}, ${3:v3}, ${4:v4}, ${5:v5}, ${6:v6}, ${7:v7}, ${8:v8}, ${9:v9}, ${10:v10}, ${11:v11}, ${12:v12}, ${13:v13}, ${14:v14}, ${15:v15}, ${16:v16})",
			"scope": "source.vex",
			"description": "Creates a new value based on its arguments, such as creating a vector from its components."
	},
	"set: nums": {
			"prefix": "set(nums)",
			"body": "set(${1:nums})",
			"scope": "source.vex",
			"description": "Creates a new value based on its arguments, such as creating a vector from its components."
	},
	"set: v": {
			"prefix": "set(v)",
			"body": "set(${1:v})",
			"scope": "source.vex",
			"description": "Creates a new value based on its arguments, such as creating a vector from its components."
	},
	"set: row1 row2": {
			"prefix": "set(row1, row2)",
			"body": "set(${1:row1}, ${2:row2})",
			"scope": "source.vex",
			"description": "Creates a new value based on its arguments, such as creating a vector from its components."
	},
	"set: row1 row2 row3": {
			"prefix": "set(row1, row2, row3)",
			"body": "set(${1:row1}, ${2:row2}, ${3:row3})",
			"scope": "source.vex",
			"description": "Creates a new value based on its arguments, such as creating a vector from its components."
	},
	"set: row1 row2 row3 row4": {
			"prefix": "set(row1, row2, row3, row4)",
			"body": "set(${1:row1}, ${2:row2}, ${3:row3}, ${4:row4})",
			"scope": "source.vex",
			"description": "Creates a new value based on its arguments, such as creating a vector from its components."
	},
	"set: rows": {
			"prefix": "set(rows)",
			"body": "set(${1:rows})",
			"scope": "source.vex",
			"description": "Creates a new value based on its arguments, such as creating a vector from its components."
	},
	"set: m": {
			"prefix": "set(m)",
			"body": "set(${1:m})",
			"scope": "source.vex",
			"description": "Creates a new value based on its arguments, such as creating a vector from its components."
	},
	"set: vs": {
			"prefix": "set(vs)",
			"body": "set(${1:vs})",
			"scope": "source.vex",
			"description": "Creates a new value based on its arguments, such as creating a vector from its components."
	},
	"set: num": {
			"prefix": "set(num)",
			"body": "set(${1:num})",
			"scope": "source.vex",
			"description": "Creates a new value based on its arguments, such as creating a vector from its components."
	},
	"encodeattrib: str": {
			"prefix": "encodeattrib(str)",
			"body": "encodeattrib(${1:str})",
			"scope": "source.vex",
			"description": "Encodes any string into a valid geometry attribute name."
	},
	"getobjectid: ": {
			"prefix": "getobjectid()",
			"body": "getobjectid()",
			"scope": "source.vex",
			"description": "Returns the object id for the current shading context."
	},
	"nprimitives: geometry": {
			"prefix": "nprimitives(geometry)",
			"body": "nprimitives(${1:geometry})",
			"scope": "source.vex",
			"description": "Returns the number of primitives in the input or geometry file."
	},
	"usd_getbbox_min: stage primpath purpose": {
			"prefix": "usd_getbbox_min(stage, primpath, purpose)",
			"body": "usd_getbbox_min(${1:stage}, ${2:primpath}, ${3:purpose})",
			"scope": "source.vex",
			"description": "Returns the minimum of the bounding box for the primitive."
	},
	"agentchannelvalue: geometry prim channel": {
			"prefix": "agentchannelvalue(geometry, prim, channel)",
			"body": "agentchannelvalue(${1:geometry}, ${2:prim}, ${3:channel})",
			"scope": "source.vex",
			"description": "Returns the current value of an agent primitive\u2019s channel."
	},
	"wirediffuse: tangent ...": {
			"prefix": "wirediffuse(tangent, ...)",
			"body": "wirediffuse(${1:tangent}, ${2:...})",
			"scope": "source.vex",
			"description": ""
	},
	"npointsgroup: geometry groupname": {
			"prefix": "npointsgroup(geometry, groupname)",
			"body": "npointsgroup(${1:geometry}, ${2:groupname})",
			"scope": "source.vex",
			"description": "Returns the number of points in the group."
	},
	"issamples: ": {
			"prefix": "issamples()",
			"body": "issamples()",
			"scope": "source.vex",
			"description": "Returns 1 if the Vex CHOP\u2019s Unit Menu is currently set to 'samples',\n0 otherwise."
	},
	"Dw: p ...": {
			"prefix": "Dw(p, ...)",
			"body": "Dw(${1:p}, ${2:...})",
			"scope": "source.vex",
			"description": "Returns the derivative of the given value with respect to the 3rd axis (for volume rendering)."
	},
	"agentlayershapes: geometry prim layername shapetype": {
			"prefix": "agentlayershapes(geometry, prim, layername, shapetype)",
			"body": "agentlayershapes(${1:geometry}, ${2:prim}, ${3:layername}, ${4:shapetype})",
			"scope": "source.vex",
			"description": "Returns the names of the shapes referenced by an agent primitive\u2019s layer."
	},
	"agentlayershapes: geometry prim layername transform": {
			"prefix": "agentlayershapes(geometry, prim, layername, transform)",
			"body": "agentlayershapes(${1:geometry}, ${2:prim}, ${3:layername}, ${4:transform})",
			"scope": "source.vex",
			"description": "Returns the names of the shapes referenced by an agent primitive\u2019s layer."
	},
	"transpose: m": {
			"prefix": "transpose(m)",
			"body": "transpose(${1:m})",
			"scope": "source.vex",
			"description": "Transposes the given matrix."
	},
	"erfc: v": {
			"prefix": "erfc(v)",
			"body": "erfc(${1:v})",
			"scope": "source.vex",
			"description": "Gauss error function\u2019s complement."
	},
	"usd_pointinstance_relbbox: stage primpath instance_index purpose position": {
			"prefix": "usd_pointinstance_relbbox(stage, primpath, instance_index, purpose, position)",
			"body": "usd_pointinstance_relbbox(${1:stage}, ${2:primpath}, ${3:instance_index}, ${4:purpose}, ${5:position})",
			"scope": "source.vex",
			"description": "Returns the relative position of the point given with respect to the bounding box of the geometry."
	},
	"sample_light: lightid pos sam time pos clr scale ...": {
			"prefix": "sample_light(lightid, pos, sam, time, pos, clr, scale, ...)",
			"body": "sample_light(${1:lightid}, ${2:pos}, ${3:sam}, ${4:time}, ${5:pos}, ${6:clr}, ${7:scale}, ${8:...})",
			"scope": "source.vex",
			"description": "Samples a 3D position on a light source and runs the light shader at that point."
	},
	"agentaddclip: geohandle prim clipname clippath keepref": {
			"prefix": "agentaddclip(geohandle, prim, clipname, clippath, keepref)",
			"body": "agentaddclip(${1:geohandle}, ${2:prim}, ${3:clipname}, ${4:clippath}, ${5:keepref})",
			"scope": "source.vex",
			"description": "Add a clip into an agent\u2019s definition."
	},
	"photonmap: mapname position normal ...": {
			"prefix": "photonmap(mapname, position, normal, ...)",
			"body": "photonmap(${1:mapname}, ${2:position}, ${3:normal}, ${4:...})",
			"scope": "source.vex",
			"description": "Samples a color from a photon map."
	},
	"photonmap: mapname position normal color area ...": {
			"prefix": "photonmap(mapname, position, normal, color, area, ...)",
			"body": "photonmap(${1:mapname}, ${2:position}, ${3:normal}, ${4:color}, ${5:area}, ${6:...})",
			"scope": "source.vex",
			"description": "Samples a color from a photon map."
	},
	"toNDC: point": {
			"prefix": "toNDC(point)",
			"body": "toNDC(${1:point})",
			"scope": "source.vex",
			"description": "Transforms a position into normal device coordinates."
	},
	"toNDC: camera_name point": {
			"prefix": "toNDC(camera_name, point)",
			"body": "toNDC(${1:camera_name}, ${2:point})",
			"scope": "source.vex",
			"description": "Transforms a position into normal device coordinates."
	},
	"solvecurve: lengths closed orienttonormal tangent points normals": {
			"prefix": "solvecurve(lengths, closed, orienttonormal, tangent, points, normals)",
			"body": "solvecurve(${1:lengths}, ${2:closed}, ${3:orienttonormal}, ${4:tangent}, ${5:points}, ${6:normals})",
			"scope": "source.vex",
			"description": "Applies a curve inverse kinematics algorithm to a skeleton."
	},
	"solvecurve: op lengths closed orienttonormal tangent normalcalcmethod relmat": {
			"prefix": "solvecurve(op, lengths, closed, orienttonormal, tangent, normalcalcmethod, relmat)",
			"body": "solvecurve(${1:op}, ${2:lengths}, ${3:closed}, ${4:orienttonormal}, ${5:tangent}, ${6:normalcalcmethod}, ${7:relmat})",
			"scope": "source.vex",
			"description": "Applies a curve inverse kinematics algorithm to a skeleton."
	},
	"fuzzy_nand: a b ...": {
			"prefix": "fuzzy_nand(a, b, ...)",
			"body": "fuzzy_nand(${1:a}, ${2:b}, ${3:...})",
			"scope": "source.vex",
			"description": ""
	},
	"isalpha: str": {
			"prefix": "isalpha(str)",
			"body": "isalpha(${1:str})",
			"scope": "source.vex",
			"description": "Returns 1 if all the characters in the string are alphabetic"
	},
	"polyneighbours: geometry primnum": {
			"prefix": "polyneighbours(geometry, primnum)",
			"body": "polyneighbours(${1:geometry}, ${2:primnum})",
			"scope": "source.vex",
			"description": "Returns an array of the primitive numbers of the edge-neighbours of a polygon."
	},
	"solvetriangleSSS: sides": {
			"prefix": "solvetriangleSSS(sides)",
			"body": "solvetriangleSSS(${1:sides})",
			"scope": "source.vex",
			"description": "Finds the angles of a triangle from its sides."
	},
	"solvetriangleSSS: a b c": {
			"prefix": "solvetriangleSSS(a, b, c)",
			"body": "solvetriangleSSS(${1:a}, ${2:b}, ${3:c})",
			"scope": "source.vex",
			"description": "Finds the angles of a triangle from its sides."
	},
	"usd_primvar: stage primpath name": {
			"prefix": "usd_primvar(stage, primpath, name)",
			"body": "usd_primvar(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Reads the value of a primvar from the USD primitive."
	},
	"usd_primvar: stage primpath name timecode": {
			"prefix": "usd_primvar(stage, primpath, name, timecode)",
			"body": "usd_primvar(${1:stage}, ${2:primpath}, ${3:name}, ${4:timecode})",
			"scope": "source.vex",
			"description": "Reads the value of a primvar from the USD primitive."
	},
	"slideframe: t0 t1 v0": {
			"prefix": "slideframe(t0, t1, v0)",
			"body": "slideframe(${1:t0}, ${2:t1}, ${3:v0})",
			"scope": "source.vex",
			"description": "Finds the normal component of frame slid along a curve. "
	},
	"slideframe: x0 t0 v0 x1 t1": {
			"prefix": "slideframe(x0, t0, v0, x1, t1)",
			"body": "slideframe(${1:x0}, ${2:t0}, ${3:v0}, ${4:x1}, ${5:t1})",
			"scope": "source.vex",
			"description": "Finds the normal component of frame slid along a curve. "
	},
	"trace: cv of af P D shadow_bias max_contrib ...": {
			"prefix": "trace(cv, of, af, P, D, shadow_bias, max_contrib, ...)",
			"body": "trace(${1:cv}, ${2:of}, ${3:af}, ${4:P}, ${5:D}, ${6:shadow_bias}, ${7:max_contrib}, ${8:...})",
			"scope": "source.vex",
			"description": "Sends a ray from P along the normalized vector D."
	},
	"trace: pos dir time ...": {
			"prefix": "trace(pos, dir, time, ...)",
			"body": "trace(${1:pos}, ${2:dir}, ${3:time}, ${4:...})",
			"scope": "source.vex",
			"description": "Sends a ray from P along the normalized vector D."
	},
	"getcomponents: ": {
			"prefix": "getcomponents()",
			"body": "getcomponents()",
			"scope": "source.vex",
			"description": ""
	},
	"perspective: zoom image_aspect pixel_aspect clip_near clip_far": {
			"prefix": "perspective(zoom, image_aspect, pixel_aspect, clip_near, clip_far)",
			"body": "perspective(${1:zoom}, ${2:image_aspect}, ${3:pixel_aspect}, ${4:clip_near}, ${5:clip_far})",
			"scope": "source.vex",
			"description": "Create a perspective projection matrix."
	},
	"perspective: zoom image_aspect pixel_aspect clip_near clip_far window": {
			"prefix": "perspective(zoom, image_aspect, pixel_aspect, clip_near, clip_far, window)",
			"body": "perspective(${1:zoom}, ${2:image_aspect}, ${3:pixel_aspect}, ${4:clip_near}, ${5:clip_far}, ${6:window})",
			"scope": "source.vex",
			"description": "Create a perspective projection matrix."
	},
	"resample_linear: input new_length": {
			"prefix": "resample_linear(input, new_length)",
			"body": "resample_linear(${1:input}, ${2:new_length})",
			"scope": "source.vex",
			"description": ""
	},
	"determinant: m": {
			"prefix": "determinant(m)",
			"body": "determinant(${1:m})",
			"scope": "source.vex",
			"description": "Computes the determinant of the matrix."
	},
	"lerp: value1 value2 amount": {
			"prefix": "lerp(value1, value2, amount)",
			"body": "lerp(${1:value1}, ${2:value2}, ${3:amount})",
			"scope": "source.vex",
			"description": "Performs bilinear interpolation between the values."
	},
	"lerp: bsdf1 bsdf2 amount": {
			"prefix": "lerp(bsdf1, bsdf2, amount)",
			"body": "lerp(${1:bsdf1}, ${2:bsdf2}, ${3:amount})",
			"scope": "source.vex",
			"description": "Performs bilinear interpolation between the values."
	},
	"wt_nspace: v": {
			"prefix": "wt_nspace(v)",
			"body": "wt_nspace(${1:v})",
			"scope": "source.vex",
			"description": "Transforms a normal vector from World to Texture space."
	},
	"sample_hypersphere_cone: center maxangle u": {
			"prefix": "sample_hypersphere_cone(center, maxangle, u)",
			"body": "sample_hypersphere_cone(${1:center}, ${2:maxangle}, ${3:u})",
			"scope": "source.vex",
			"description": "Generates a uniform vector4 with length < 1, within maxangle of center, given a vector4 of uniform numbers between 0 and 1."
	},
	"isnan: x": {
			"prefix": "isnan(x)",
			"body": "isnan(${1:x})",
			"scope": "source.vex",
			"description": "Checks whether a value is not a number."
	},
	"usd_addprimvar: stagehandle primpath name typename": {
			"prefix": "usd_addprimvar(stagehandle, primpath, name, typename)",
			"body": "usd_addprimvar(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:typename})",
			"scope": "source.vex",
			"description": "Creates a primvar of a given type on a primitive."
	},
	"usd_addprimvar: stagehandle primpath name typename interpolation": {
			"prefix": "usd_addprimvar(stagehandle, primpath, name, typename, interpolation)",
			"body": "usd_addprimvar(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:typename}, ${5:interpolation})",
			"scope": "source.vex",
			"description": "Creates a primvar of a given type on a primitive."
	},
	"osd_lookuppatch: geometry face_id face_u face_v patch_id patch_u patch_v": {
			"prefix": "osd_lookuppatch(geometry, face_id, face_u, face_v, patch_id, patch_u, patch_v)",
			"body": "osd_lookuppatch(${1:geometry}, ${2:face_id}, ${3:face_u}, ${4:face_v}, ${5:patch_id}, ${6:patch_u}, ${7:patch_v})",
			"scope": "source.vex",
			"description": "Outputs the OSD patch and UV coordinates corresponding to the given coordinates on a Houdini polygon face."
	},
	"osd_lookuppatch: geometry face_id face_u face_v patch_id patch_u patch_v attribute": {
			"prefix": "osd_lookuppatch(geometry, face_id, face_u, face_v, patch_id, patch_u, patch_v, attribute)",
			"body": "osd_lookuppatch(${1:geometry}, ${2:face_id}, ${3:face_u}, ${4:face_v}, ${5:patch_id}, ${6:patch_u}, ${7:patch_v}, ${8:attribute})",
			"scope": "source.vex",
			"description": "Outputs the OSD patch and UV coordinates corresponding to the given coordinates on a Houdini polygon face."
	},
	"setattribtypeinfo: geohandle attribclass name typeinfo": {
			"prefix": "setattribtypeinfo(geohandle, attribclass, name, typeinfo)",
			"body": "setattribtypeinfo(${1:geohandle}, ${2:attribclass}, ${3:name}, ${4:typeinfo})",
			"scope": "source.vex",
			"description": "Sets the meaning of an attribute in geometry."
	},
	"polardecomp: transform": {
			"prefix": "polardecomp(transform)",
			"body": "polardecomp(${1:transform})",
			"scope": "source.vex",
			"description": "Computes the polar decomposition of a matrix."
	},
	"setvertexpoint: geohandle prim vtxofprim pt": {
			"prefix": "setvertexpoint(geohandle, prim, vtxofprim, pt)",
			"body": "setvertexpoint(${1:geohandle}, ${2:prim}, ${3:vtxofprim}, ${4:pt})",
			"scope": "source.vex",
			"description": "Rewires a vertex in the geometry to a different point."
	},
	"specular: dir ...": {
			"prefix": "specular(dir, ...)",
			"body": "specular(${1:dir}, ${2:...})",
			"scope": "source.vex",
			"description": "Returns a specular BSDF or computes specular shading."
	},
	"specular: nml V roughness ...": {
			"prefix": "specular(nml, V, roughness, ...)",
			"body": "specular(${1:nml}, ${2:V}, ${3:roughness}, ${4:...})",
			"scope": "source.vex",
			"description": "Returns a specular BSDF or computes specular shading."
	},
	"agentrigparent: geometry prim transform": {
			"prefix": "agentrigparent(geometry, prim, transform)",
			"body": "agentrigparent(${1:geometry}, ${2:prim}, ${3:transform})",
			"scope": "source.vex",
			"description": "Returns the parent transform of a transform in an agent primitive\u2019s rig."
	},
	"setagentclips: geohandle prim clip_names clip_times clip_weights clip_transform_groups clip_layer_ids layer_blend_modes layer_weights layer_parent_ids": {
			"prefix": "setagentclips(geohandle, prim, clip_names, clip_times, clip_weights, clip_transform_groups, clip_layer_ids, layer_blend_modes, layer_weights, layer_parent_ids)",
			"body": "setagentclips(${1:geohandle}, ${2:prim}, ${3:clip_names}, ${4:clip_times}, ${5:clip_weights}, ${6:clip_transform_groups}, ${7:clip_layer_ids}, ${8:layer_blend_modes}, ${9:layer_weights}, ${10:layer_parent_ids})",
			"scope": "source.vex",
			"description": "Sets the animation clips that an agent should use to compute its transforms."
	},
	"printf: format ...": {
			"prefix": "printf(format, ...)",
			"body": "printf(${1:format}, ${2:...})",
			"scope": "source.vex",
			"description": "Prints values to the console which started the VEX program."
	},
	"pow: n exponent": {
			"prefix": "pow(n, exponent)",
			"body": "pow(${1:n}, ${2:exponent})",
			"scope": "source.vex",
			"description": "Raises the first argument to the power of the second argument."
	},
	"pow: v exponent": {
			"prefix": "pow(v, exponent)",
			"body": "pow(${1:v}, ${2:exponent})",
			"scope": "source.vex",
			"description": "Raises the first argument to the power of the second argument."
	},
	"curlxnoise2d: x y": {
			"prefix": "curlxnoise2d(x, y)",
			"body": "curlxnoise2d(${1:x}, ${2:y})",
			"scope": "source.vex",
			"description": "Computes 2d divergence free noise based on simplex noise."
	},
	"curlxnoise2d: xyt": {
			"prefix": "curlxnoise2d(xyt)",
			"body": "curlxnoise2d(${1:xyt})",
			"scope": "source.vex",
			"description": "Computes 2d divergence free noise based on simplex noise."
	},
	"pointattribtype: geometry attribute_name": {
			"prefix": "pointattribtype(geometry, attribute_name)",
			"body": "pointattribtype(${1:geometry}, ${2:attribute_name})",
			"scope": "source.vex",
			"description": "Returns the type of a geometry point attribute."
	},
	"Du: n ...": {
			"prefix": "Du(n, ...)",
			"body": "Du(${1:n}, ${2:...})",
			"scope": "source.vex",
			"description": "Returns the derivative of the given value with respect to U."
	},
	"pathtrace: P N ...": {
			"prefix": "pathtrace(P, N, ...)",
			"body": "pathtrace(${1:P}, ${2:N}, ${3:...})",
			"scope": "source.vex",
			"description": "Computes global illumination using PBR for secondary bounces."
	},
	"error: format ...": {
			"prefix": "error(format, ...)",
			"body": "error(${1:format}, ${2:...})",
			"scope": "source.vex",
			"description": "Reports a custom runtime VEX error."
	},
	"usd_isindexedprimvar: stage primpath name": {
			"prefix": "usd_isindexedprimvar(stage, primpath, name)",
			"body": "usd_isindexedprimvar(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Checks if the primvar is indexed."
	},
	"pcsegment: geometry PChannel P0 P1 max_distance maxpoints": {
			"prefix": "pcsegment(geometry, PChannel, P0, P1, max_distance, maxpoints)",
			"body": "pcsegment(${1:geometry}, ${2:PChannel}, ${3:P0}, ${4:P1}, ${5:max_distance}, ${6:maxpoints})",
			"scope": "source.vex",
			"description": "Returns a list of closest points to a line segment from a specified file"
	},
	"pcsegment: geometry ptgroup PChannel P0 P1 max_distance maxpoints": {
			"prefix": "pcsegment(geometry, ptgroup, PChannel, P0, P1, max_distance, maxpoints)",
			"body": "pcsegment(${1:geometry}, ${2:ptgroup}, ${3:PChannel}, ${4:P0}, ${5:P1}, ${6:max_distance}, ${7:maxpoints})",
			"scope": "source.vex",
			"description": "Returns a list of closest points to a line segment from a specified file"
	},
	"pcsegment: geometry PChannel P0 P1 max_distance maxpoints distances": {
			"prefix": "pcsegment(geometry, PChannel, P0, P1, max_distance, maxpoints, distances)",
			"body": "pcsegment(${1:geometry}, ${2:PChannel}, ${3:P0}, ${4:P1}, ${5:max_distance}, ${6:maxpoints}, ${7:distances})",
			"scope": "source.vex",
			"description": "Returns a list of closest points to a line segment from a specified file"
	},
	"pcsegment: geometry ptgroup PChannel P0 P1 max_distance maxpoints distances": {
			"prefix": "pcsegment(geometry, ptgroup, PChannel, P0, P1, max_distance, maxpoints, distances)",
			"body": "pcsegment(${1:geometry}, ${2:ptgroup}, ${3:PChannel}, ${4:P0}, ${5:P1}, ${6:max_distance}, ${7:maxpoints}, ${8:distances})",
			"scope": "source.vex",
			"description": "Returns a list of closest points to a line segment from a specified file"
	},
	"accessframe: frame": {
			"prefix": "accessframe(frame)",
			"body": "accessframe(${1:frame})",
			"scope": "source.vex",
			"description": "Tells the COP manager that you need access to the given frame."
	},
	"maskname: ": {
			"prefix": "maskname()",
			"body": "maskname()",
			"scope": "source.vex",
			"description": "Returns the default name of the mask plane (as it appears in the\ncompositor preferences)."
	},
	"setcomp: target value index": {
			"prefix": "setcomp(target, value, index)",
			"body": "setcomp(${1:target}, ${2:value}, ${3:index})",
			"scope": "source.vex",
			"description": "Sets a single component of a vector or matrix type, or an item in an array."
	},
	"setcomp: target value row column": {
			"prefix": "setcomp(target, value, row, column)",
			"body": "setcomp(${1:target}, ${2:value}, ${3:row}, ${4:column})",
			"scope": "source.vex",
			"description": "Sets a single component of a vector or matrix type, or an item in an array."
	},
	"setcomp: array value index": {
			"prefix": "setcomp(array, value, index)",
			"body": "setcomp(${1:array}, ${2:value}, ${3:index})",
			"scope": "source.vex",
			"description": "Sets a single component of a vector or matrix type, or an item in an array."
	},
	"usd_cleartransformorder: stagehandle primpath": {
			"prefix": "usd_cleartransformorder(stagehandle, primpath)",
			"body": "usd_cleartransformorder(${1:stagehandle}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Clears the primitive\u2019s transform order"
	},
	"lumname: ": {
			"prefix": "lumname()",
			"body": "lumname()",
			"scope": "source.vex",
			"description": "Returns the default name of the luminaence plane (as it appears in the\ncompositor preferences)."
	},
	"chinput: channel_index sample": {
			"prefix": "chinput(channel_index, sample)",
			"body": "chinput(${1:channel_index}, ${2:sample})",
			"scope": "source.vex",
			"description": "Returns the value of a channel at the specified sample."
	},
	"chinput: opinput channel_index sample": {
			"prefix": "chinput(opinput, channel_index, sample)",
			"body": "chinput(${1:opinput}, ${2:channel_index}, ${3:sample})",
			"scope": "source.vex",
			"description": "Returns the value of a channel at the specified sample."
	},
	"chinput: channel_name sample": {
			"prefix": "chinput(channel_name, sample)",
			"body": "chinput(${1:channel_name}, ${2:sample})",
			"scope": "source.vex",
			"description": "Returns the value of a channel at the specified sample."
	},
	"chinput: opinput channel_name sample": {
			"prefix": "chinput(opinput, channel_name, sample)",
			"body": "chinput(${1:opinput}, ${2:channel_name}, ${3:sample})",
			"scope": "source.vex",
			"description": "Returns the value of a channel at the specified sample."
	},
	"chinput: channel_index sample t r s": {
			"prefix": "chinput(channel_index, sample, t, r, s)",
			"body": "chinput(${1:channel_index}, ${2:sample}, ${3:t}, ${4:r}, ${5:s})",
			"scope": "source.vex",
			"description": "Returns the value of a channel at the specified sample."
	},
	"chinput: opinput channel_index sample t r s": {
			"prefix": "chinput(opinput, channel_index, sample, t, r, s)",
			"body": "chinput(${1:opinput}, ${2:channel_index}, ${3:sample}, ${4:t}, ${5:r}, ${6:s})",
			"scope": "source.vex",
			"description": "Returns the value of a channel at the specified sample."
	},
	"chinput: channel_name sample t r s": {
			"prefix": "chinput(channel_name, sample, t, r, s)",
			"body": "chinput(${1:channel_name}, ${2:sample}, ${3:t}, ${4:r}, ${5:s})",
			"scope": "source.vex",
			"description": "Returns the value of a channel at the specified sample."
	},
	"chinput: opinput channel_name sample t r s": {
			"prefix": "chinput(opinput, channel_name, sample, t, r, s)",
			"body": "chinput(${1:opinput}, ${2:channel_name}, ${3:sample}, ${4:t}, ${5:r}, ${6:s})",
			"scope": "source.vex",
			"description": "Returns the value of a channel at the specified sample."
	},
	"setprimvertex: geohandle prim vtxofprim pt": {
			"prefix": "setprimvertex(geohandle, prim, vtxofprim, pt)",
			"body": "setprimvertex(${1:geohandle}, ${2:prim}, ${3:vtxofprim}, ${4:pt})",
			"scope": "source.vex",
			"description": "Rewires a vertex in the geometry to a different point."
	},
	"usd_settransformreset: stagehandle primpath flag": {
			"prefix": "usd_settransformreset(stagehandle, primpath, flag)",
			"body": "usd_settransformreset(${1:stagehandle}, ${2:primpath}, ${3:flag})",
			"scope": "source.vex",
			"description": "Sets/clears the primitive\u2019s transform reset flag"
	},
	"pcimportbyidx4: handle channel_name idx": {
			"prefix": "pcimportbyidx4(handle, channel_name, idx)",
			"body": "pcimportbyidx4(${1:handle}, ${2:channel_name}, ${3:idx})",
			"scope": "source.vex",
			"description": "Imports channel data from a point cloud outside a pciterate or a pcunshaded loop."
	},
	"getlights: ...": {
			"prefix": "getlights(...)",
			"body": "getlights(${1:...})",
			"scope": "source.vex",
			"description": "Returns an array of light identifiers for the currently shaded surface."
	},
	"getlights: P ...": {
			"prefix": "getlights(P, ...)",
			"body": "getlights(${1:P}, ${2:...})",
			"scope": "source.vex",
			"description": "Returns an array of light identifiers for the currently shaded surface."
	},
	"getlights: mat P ...": {
			"prefix": "getlights(mat, P, ...)",
			"body": "getlights(${1:mat}, ${2:P}, ${3:...})",
			"scope": "source.vex",
			"description": "Returns an array of light identifiers for the currently shaded surface."
	},
	"agentclipsamplelocal: geometry prim clipname time": {
			"prefix": "agentclipsamplelocal(geometry, prim, clipname, time)",
			"body": "agentclipsamplelocal(${1:geometry}, ${2:prim}, ${3:clipname}, ${4:time})",
			"scope": "source.vex",
			"description": "Samples an agent\u2019s animation clip at a specific time."
	},
	"agentclipsamplelocal: geometry prim clipname time transform": {
			"prefix": "agentclipsamplelocal(geometry, prim, clipname, time, transform)",
			"body": "agentclipsamplelocal(${1:geometry}, ${2:prim}, ${3:clipname}, ${4:time}, ${5:transform})",
			"scope": "source.vex",
			"description": "Samples an agent\u2019s animation clip at a specific time."
	},
	"limit_sample_space: minu maxu u": {
			"prefix": "limit_sample_space(minu, maxu, u)",
			"body": "limit_sample_space(${1:minu}, ${2:maxu}, ${3:u})",
			"scope": "source.vex",
			"description": "Limits a unit value in a way that maintains uniformity and in-range consistency."
	},
	"limit_sample_space: maxu u": {
			"prefix": "limit_sample_space(maxu, u)",
			"body": "limit_sample_space(${1:maxu}, ${2:u})",
			"scope": "source.vex",
			"description": "Limits a unit value in a way that maintains uniformity and in-range consistency."
	},
	"tan: n": {
			"prefix": "tan(n)",
			"body": "tan(${1:n})",
			"scope": "source.vex",
			"description": "Returns the trigonometric tangent of the argument"
	},
	"tan: v": {
			"prefix": "tan(v)",
			"body": "tan(${1:v})",
			"scope": "source.vex",
			"description": "Returns the trigonometric tangent of the argument"
	},
	"usd_attribsize: stage primpath name": {
			"prefix": "usd_attribsize(stage, primpath, name)",
			"body": "usd_attribsize(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Returns the tuple size of the attribute."
	},
	"oppreparmtransform: path": {
			"prefix": "oppreparmtransform(path)",
			"body": "oppreparmtransform(${1:path})",
			"scope": "source.vex",
			"description": "Returns the pre and parm transform associated with an OP."
	},
	"oppreparmtransform: path time": {
			"prefix": "oppreparmtransform(path, time)",
			"body": "oppreparmtransform(${1:path}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the pre and parm transform associated with an OP."
	},
	"oppreparmtransform: opid": {
			"prefix": "oppreparmtransform(opid)",
			"body": "oppreparmtransform(${1:opid})",
			"scope": "source.vex",
			"description": "Returns the pre and parm transform associated with an OP."
	},
	"oppreparmtransform: opid time": {
			"prefix": "oppreparmtransform(opid, time)",
			"body": "oppreparmtransform(${1:opid}, ${2:time})",
			"scope": "source.vex",
			"description": "Returns the pre and parm transform associated with an OP."
	},
	"planesphereintersect: plane_pos plane_normal sphere_pos sphere_radius intersect_pos intersect_radius intersect_distance": {
			"prefix": "planesphereintersect(plane_pos, plane_normal, sphere_pos, sphere_radius, intersect_pos, intersect_radius, intersect_distance)",
			"body": "planesphereintersect(${1:plane_pos}, ${2:plane_normal}, ${3:sphere_pos}, ${4:sphere_radius}, ${5:intersect_pos}, ${6:intersect_radius}, ${7:intersect_distance})",
			"scope": "source.vex",
			"description": "Computes the intersection of a 3D sphere and an infinite 3D plane."
	},
	"ow_nspace: v": {
			"prefix": "ow_nspace(v)",
			"body": "ow_nspace(${1:v})",
			"scope": "source.vex",
			"description": "Transforms a normal vector from Object to World space."
	},
	"usd_relationshipnames: stage primpath": {
			"prefix": "usd_relationshipnames(stage, primpath)",
			"body": "usd_relationshipnames(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Returns the names of the relationships available on the primitive."
	},
	"vertexprev: geometry linearvertex": {
			"prefix": "vertexprev(geometry, linearvertex)",
			"body": "vertexprev(${1:geometry}, ${2:linearvertex})",
			"scope": "source.vex",
			"description": "Returns the linear vertex number of the previous vertex sharing a point with a given vertex."
	},
	"planename: planeindex": {
			"prefix": "planename(planeindex)",
			"body": "planename(${1:planeindex})",
			"scope": "source.vex",
			"description": "Returns the name of the plane specified by the index (e."
	},
	"inedgegroup: filename groupname pointnum0 pointnum1": {
			"prefix": "inedgegroup(filename, groupname, pointnum0, pointnum1)",
			"body": "inedgegroup(${1:filename}, ${2:groupname}, ${3:pointnum0}, ${4:pointnum1})",
			"scope": "source.vex",
			"description": "Returns 1 if the edge specified by the point pair is in the group specified by the string."
	},
	"inedgegroup: input groupname pointnum0 pointnum1": {
			"prefix": "inedgegroup(input, groupname, pointnum0, pointnum1)",
			"body": "inedgegroup(${1:input}, ${2:groupname}, ${3:pointnum0}, ${4:pointnum1})",
			"scope": "source.vex",
			"description": "Returns 1 if the edge specified by the point pair is in the group specified by the string."
	},
	"getobjectname: ": {
			"prefix": "getobjectname()",
			"body": "getobjectname()",
			"scope": "source.vex",
			"description": "Returns the name of the current object whose shader is being run."
	},
	"uniquevals: geometry attribclass attribute_name": {
			"prefix": "uniquevals(geometry, attribclass, attribute_name)",
			"body": "uniquevals(${1:geometry}, ${2:attribclass}, ${3:attribute_name})",
			"scope": "source.vex",
			"description": "Returns the set of unique values across all values for an int or string attribute."
	},
	"ckspline: t value pos ...": {
			"prefix": "ckspline(t, value, pos, ...)",
			"body": "ckspline(${1:t}, ${2:value}, ${3:pos}, ${4:...})",
			"scope": "source.vex",
			"description": "Samples a Catmull-Rom (Cardinal) spline defined by position/value keys."
	},
	"xyztorgb: xyz": {
			"prefix": "xyztorgb(xyz)",
			"body": "xyztorgb(${1:xyz})",
			"scope": "source.vex",
			"description": "Convert CIE XYZ tristimulus values to a linear sRGB triplet."
	},
	"pcclose: handle": {
			"prefix": "pcclose(handle)",
			"body": "pcclose(${1:handle})",
			"scope": "source.vex",
			"description": "This function closes the handle associated with a pcopen\nfunction."
	},
	"sensor_panorama_create: time pos size near far candidateobj includeobj excludeobj uselit": {
			"prefix": "sensor_panorama_create(time, pos, size, near, far, candidateobj, includeobj, excludeobj, uselit)",
			"body": "sensor_panorama_create(${1:time}, ${2:pos}, ${3:size}, ${4:near}, ${5:far}, ${6:candidateobj}, ${7:includeobj}, ${8:excludeobj}, ${9:uselit})",
			"scope": "source.vex",
			"description": "Sensor function to render GL scene and query the result."
	},
	"exp: n": {
			"prefix": "exp(n)",
			"body": "exp(${1:n})",
			"scope": "source.vex",
			"description": "Returns the exponential function of the argument."
	},
	"pointattribsize: geometry attribute_name": {
			"prefix": "pointattribsize(geometry, attribute_name)",
			"body": "pointattribsize(${1:geometry}, ${2:attribute_name})",
			"scope": "source.vex",
			"description": "Returns the size of a geometry point attribute."
	},
	"chsetstart: start": {
			"prefix": "chsetstart(start)",
			"body": "chsetstart(${1:start})",
			"scope": "source.vex",
			"description": "Sets the CHOP start sample in the channel data."
	},
	"volumevoxeldiameter: geometry primnum": {
			"prefix": "volumevoxeldiameter(geometry, primnum)",
			"body": "volumevoxeldiameter(${1:geometry}, ${2:primnum})",
			"scope": "source.vex",
			"description": "Computes the approximate diameter of a voxel."
	},
	"volumevoxeldiameter: geometry primname": {
			"prefix": "volumevoxeldiameter(geometry, primname)",
			"body": "volumevoxeldiameter(${1:geometry}, ${2:primname})",
			"scope": "source.vex",
			"description": "Computes the approximate diameter of a voxel."
	},
	"usd_primvarnames: stage primpath": {
			"prefix": "usd_primvarnames(stage, primpath)",
			"body": "usd_primvarnames(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Returns the names of the primvars available on the primitive."
	},
	"usd_collectionincludes: stage collectionpath": {
			"prefix": "usd_collectionincludes(stage, collectionpath)",
			"body": "usd_collectionincludes(${1:stage}, ${2:collectionpath})",
			"scope": "source.vex",
			"description": "Obtains the object paths that are in the collection\u2019s include list"
	},
	"random: position": {
			"prefix": "random(position)",
			"body": "random(${1:position})",
			"scope": "source.vex",
			"description": "Generate a random number based on the position in 1-4D space."
	},
	"random: xpos ypos": {
			"prefix": "random(xpos, ypos)",
			"body": "random(${1:xpos}, ${2:ypos})",
			"scope": "source.vex",
			"description": "Generate a random number based on the position in 1-4D space."
	},
	"detailintrinsic: geometry intrinsic_name": {
			"prefix": "detailintrinsic(geometry, intrinsic_name)",
			"body": "detailintrinsic(${1:geometry}, ${2:intrinsic_name})",
			"scope": "source.vex",
			"description": "Reads the value of a detail intrinsic from a geometry."
	},
	"primarclen: geometry uv1 uv2 prim_num": {
			"prefix": "primarclen(geometry, uv1, uv2, prim_num)",
			"body": "primarclen(${1:geometry}, ${2:uv1}, ${3:uv2}, ${4:prim_num})",
			"scope": "source.vex",
			"description": "Evaluates the length of an arc on a primitive using parametric uv coordinates."
	},
	"primarclen: geometry uv1 uv2 prim_num divs": {
			"prefix": "primarclen(geometry, uv1, uv2, prim_num, divs)",
			"body": "primarclen(${1:geometry}, ${2:uv1}, ${3:uv2}, ${4:prim_num}, ${5:divs})",
			"scope": "source.vex",
			"description": "Evaluates the length of an arc on a primitive using parametric uv coordinates."
	},
	"isshadingRHS: ": {
			"prefix": "isshadingRHS()",
			"body": "isshadingRHS()",
			"scope": "source.vex",
			"description": "Detects the orientation of default shading space."
	},
	"usd_haspayload: stage primpath": {
			"prefix": "usd_haspayload(stage, primpath)",
			"body": "usd_haspayload(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Checks if the primitive adheres to the given API."
	},
	"usd_iscollection: stage collectionpath": {
			"prefix": "usd_iscollection(stage, collectionpath)",
			"body": "usd_iscollection(${1:stage}, ${2:collectionpath})",
			"scope": "source.vex",
			"description": "Checks if the collection exists."
	},
	"primintrinsic: geometry intrinsic_name prim_num": {
			"prefix": "primintrinsic(geometry, intrinsic_name, prim_num)",
			"body": "primintrinsic(${1:geometry}, ${2:intrinsic_name}, ${3:prim_num})",
			"scope": "source.vex",
			"description": "Reads a primitive intrinsic from a geometry."
	},
	"usd_getbbox: stage primpath purpose min max": {
			"prefix": "usd_getbbox(stage, primpath, purpose, min, max)",
			"body": "usd_getbbox(${1:stage}, ${2:primpath}, ${3:purpose}, ${4:min}, ${5:max})",
			"scope": "source.vex",
			"description": "Sets two vectors to the minimum and maximum corners of the bounding box for the primitive."
	},
	"usd_metadataelement: stage path name index": {
			"prefix": "usd_metadataelement(stage, path, name, index)",
			"body": "usd_metadataelement(${1:stage}, ${2:path}, ${3:name}, ${4:index})",
			"scope": "source.vex",
			"description": "Reads the value of an element from the array metadata."
	},
	"noise: pos": {
			"prefix": "noise(pos)",
			"body": "noise(${1:pos})",
			"scope": "source.vex",
			"description": "There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space."
	},
	"noise: posx posy": {
			"prefix": "noise(posx, posy)",
			"body": "noise(${1:posx}, ${2:posy})",
			"scope": "source.vex",
			"description": "There are two forms of Perlin-style noise: a non-periodic noise which\nchanges randomly throughout N-dimensional space, and a periodic form\nwhich repeats over a given range of space."
	},
	"usd_makeattribpath: stage primpath name": {
			"prefix": "usd_makeattribpath(stage, primpath, name)",
			"body": "usd_makeattribpath(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Constructs an attribute path from a primitive path and an attribute name."
	},
	"getuvtangents: objName P dir Tu Tv": {
			"prefix": "getuvtangents(objName, P, dir, Tu, Tv)",
			"body": "getuvtangents(${1:objName}, ${2:P}, ${3:dir}, ${4:Tu}, ${5:Tv})",
			"scope": "source.vex",
			"description": "Evaluates UV tangents at a point on an arbitrary object."
	},
	"getuvtangents: objName P dir Tu Tv Tn": {
			"prefix": "getuvtangents(objName, P, dir, Tu, Tv, Tn)",
			"body": "getuvtangents(${1:objName}, ${2:P}, ${3:dir}, ${4:Tu}, ${5:Tv}, ${6:Tn})",
			"scope": "source.vex",
			"description": "Evaluates UV tangents at a point on an arbitrary object."
	},
	"radians: num_in_degs": {
			"prefix": "radians(num_in_degs)",
			"body": "radians(${1:num_in_degs})",
			"scope": "source.vex",
			"description": "Converts the argument from degrees into radians."
	},
	"radians: nums_in_degs": {
			"prefix": "radians(nums_in_degs)",
			"body": "radians(${1:nums_in_degs})",
			"scope": "source.vex",
			"description": "Converts the argument from degrees into radians."
	},
	"translucent: nml ng ...": {
			"prefix": "translucent(nml, ng, ...)",
			"body": "translucent(${1:nml}, ${2:ng}, ${3:...})",
			"scope": "source.vex",
			"description": "Returns a Lambertian translucence BSDF."
	},
	"volumeindexv: geometry primnum voxel": {
			"prefix": "volumeindexv(geometry, primnum, voxel)",
			"body": "volumeindexv(${1:geometry}, ${2:primnum}, ${3:voxel})",
			"scope": "source.vex",
			"description": "Gets the vector value of a specific voxel."
	},
	"volumeindexv: geometry volumename voxel": {
			"prefix": "volumeindexv(geometry, volumename, voxel)",
			"body": "volumeindexv(${1:geometry}, ${2:volumename}, ${3:voxel})",
			"scope": "source.vex",
			"description": "Gets the vector value of a specific voxel."
	},
	"agentclipchannel: geometry prim clipname channel": {
			"prefix": "agentclipchannel(geometry, prim, clipname, channel)",
			"body": "agentclipchannel(${1:geometry}, ${2:prim}, ${3:clipname}, ${4:channel})",
			"scope": "source.vex",
			"description": "Finds the index of a channel in an agent\u2019s animation clip."
	},
	"addprimattrib: geohandle name defvalue": {
			"prefix": "addprimattrib(geohandle, name, defvalue)",
			"body": "addprimattrib(${1:geohandle}, ${2:name}, ${3:defvalue})",
			"scope": "source.vex",
			"description": "Adds a primitive attribute to a geometry."
	},
	"addprimattrib: geohandle name defvalue typeinfo": {
			"prefix": "addprimattrib(geohandle, name, defvalue, typeinfo)",
			"body": "addprimattrib(${1:geohandle}, ${2:name}, ${3:defvalue}, ${4:typeinfo})",
			"scope": "source.vex",
			"description": "Adds a primitive attribute to a geometry."
	},
	"osd_patchcount: geometry": {
			"prefix": "osd_patchcount(geometry)",
			"body": "osd_patchcount(${1:geometry})",
			"scope": "source.vex",
			"description": ""
	},
	"osd_patchcount: geometry face_id": {
			"prefix": "osd_patchcount(geometry, face_id)",
			"body": "osd_patchcount(${1:geometry}, ${2:face_id})",
			"scope": "source.vex",
			"description": ""
	},
	"agentcliptimes: geometry prim": {
			"prefix": "agentcliptimes(geometry, prim)",
			"body": "agentcliptimes(${1:geometry}, ${2:prim})",
			"scope": "source.vex",
			"description": "Returns the current times for an agent primitive\u2019s animation clips."
	},
	"pcfind_radius: geometry Pchannel RadChannel radscale P radius maxpoints": {
			"prefix": "pcfind_radius(geometry, Pchannel, RadChannel, radscale, P, radius, maxpoints)",
			"body": "pcfind_radius(${1:geometry}, ${2:Pchannel}, ${3:RadChannel}, ${4:radscale}, ${5:P}, ${6:radius}, ${7:maxpoints})",
			"scope": "source.vex",
			"description": "Returns a list of closest points from a file taking into account their radii."
	},
	"pcfind_radius: geometry ptgroup Pchannel RadChannel radscale P radius maxpoints": {
			"prefix": "pcfind_radius(geometry, ptgroup, Pchannel, RadChannel, radscale, P, radius, maxpoints)",
			"body": "pcfind_radius(${1:geometry}, ${2:ptgroup}, ${3:Pchannel}, ${4:RadChannel}, ${5:radscale}, ${6:P}, ${7:radius}, ${8:maxpoints})",
			"scope": "source.vex",
			"description": "Returns a list of closest points from a file taking into account their radii."
	},
	"pcfind_radius: geometry Pchannel RadChannel radscale P radius maxpoints distances": {
			"prefix": "pcfind_radius(geometry, Pchannel, RadChannel, radscale, P, radius, maxpoints, distances)",
			"body": "pcfind_radius(${1:geometry}, ${2:Pchannel}, ${3:RadChannel}, ${4:radscale}, ${5:P}, ${6:radius}, ${7:maxpoints}, ${8:distances})",
			"scope": "source.vex",
			"description": "Returns a list of closest points from a file taking into account their radii."
	},
	"pcfind_radius: geometry ptgroup Pchannel RadChannel radscale P radius maxpoints distances": {
			"prefix": "pcfind_radius(geometry, ptgroup, Pchannel, RadChannel, radscale, P, radius, maxpoints, distances)",
			"body": "pcfind_radius(${1:geometry}, ${2:ptgroup}, ${3:Pchannel}, ${4:RadChannel}, ${5:radscale}, ${6:P}, ${7:radius}, ${8:maxpoints}, ${9:distances})",
			"scope": "source.vex",
			"description": "Returns a list of closest points from a file taking into account their radii."
	},
	"eval_bsdf: b viewer light ...": {
			"prefix": "eval_bsdf(b, viewer, light, ...)",
			"body": "eval_bsdf(${1:b}, ${2:viewer}, ${3:light}, ${4:...})",
			"scope": "source.vex",
			"description": "Evaluates a bsdf given two vectors."
	},
	"eval_bsdf: b viewer light mask ...": {
			"prefix": "eval_bsdf(b, viewer, light, mask, ...)",
			"body": "eval_bsdf(${1:b}, ${2:viewer}, ${3:light}, ${4:mask}, ${5:...})",
			"scope": "source.vex",
			"description": "Evaluates a bsdf given two vectors."
	},
	"eval_bsdf: b viewer light pdf mask ...": {
			"prefix": "eval_bsdf(b, viewer, light, pdf, mask, ...)",
			"body": "eval_bsdf(${1:b}, ${2:viewer}, ${3:light}, ${4:pdf}, ${5:mask}, ${6:...})",
			"scope": "source.vex",
			"description": "Evaluates a bsdf given two vectors."
	},
	"eval_bsdf: b viewer light normal ...": {
			"prefix": "eval_bsdf(b, viewer, light, normal, ...)",
			"body": "eval_bsdf(${1:b}, ${2:viewer}, ${3:light}, ${4:normal}, ${5:...})",
			"scope": "source.vex",
			"description": "Evaluates a bsdf given two vectors."
	},
	"eval_bsdf: b viewer light normal mask ...": {
			"prefix": "eval_bsdf(b, viewer, light, normal, mask, ...)",
			"body": "eval_bsdf(${1:b}, ${2:viewer}, ${3:light}, ${4:normal}, ${5:mask}, ${6:...})",
			"scope": "source.vex",
			"description": "Evaluates a bsdf given two vectors."
	},
	"eval_bsdf: b viewer light normal pdf mask ...": {
			"prefix": "eval_bsdf(b, viewer, light, normal, pdf, mask, ...)",
			"body": "eval_bsdf(${1:b}, ${2:viewer}, ${3:light}, ${4:normal}, ${5:pdf}, ${6:mask}, ${7:...})",
			"scope": "source.vex",
			"description": "Evaluates a bsdf given two vectors."
	},
	"usd_primvarelement: stage primpath name index": {
			"prefix": "usd_primvarelement(stage, primpath, name, index)",
			"body": "usd_primvarelement(${1:stage}, ${2:primpath}, ${3:name}, ${4:index})",
			"scope": "source.vex",
			"description": "Reads the value of an element from the array primvar."
	},
	"usd_primvarelement: stage primpath name index timecode": {
			"prefix": "usd_primvarelement(stage, primpath, name, index, timecode)",
			"body": "usd_primvarelement(${1:stage}, ${2:primpath}, ${3:name}, ${4:index}, ${5:timecode})",
			"scope": "source.vex",
			"description": "Reads the value of an element from the array primvar."
	},
	"switch: direct indirect": {
			"prefix": "switch(direct, indirect)",
			"body": "switch(${1:direct}, ${2:indirect})",
			"scope": "source.vex",
			"description": "Use a different bsdf for direct or indirect lighting."
	},
	"usd_setcollectionexcludes: stagehandle collectionpath excludes": {
			"prefix": "usd_setcollectionexcludes(stagehandle, collectionpath, excludes)",
			"body": "usd_setcollectionexcludes(${1:stagehandle}, ${2:collectionpath}, ${3:excludes})",
			"scope": "source.vex",
			"description": "Sets the excludes list on the collection"
	},
	"fuzzy_nxor: a b ...": {
			"prefix": "fuzzy_nxor(a, b, ...)",
			"body": "fuzzy_nxor(${1:a}, ${2:b}, ${3:...})",
			"scope": "source.vex",
			"description": ""
	},
	"pluralize: noun": {
			"prefix": "pluralize(noun)",
			"body": "pluralize(${1:noun})",
			"scope": "source.vex",
			"description": "Converts an English noun to its plural."
	},
	"decodeparm: str": {
			"prefix": "decodeparm(str)",
			"body": "decodeparm(${1:str})",
			"scope": "source.vex",
			"description": "Decodes a node parameter name that was previously encoded."
	},
	"pciterate: handle": {
			"prefix": "pciterate(handle)",
			"body": "pciterate(${1:handle})",
			"scope": "source.vex",
			"description": "This function can be used to iterate over all the points which were\nfound in the pcopen query."
	},
	"chstart: ": {
			"prefix": "chstart()",
			"body": "chstart()",
			"scope": "source.vex",
			"description": "Returns the start sample of the input specified."
	},
	"chstart: opinput": {
			"prefix": "chstart(opinput)",
			"body": "chstart(${1:opinput})",
			"scope": "source.vex",
			"description": "Returns the start sample of the input specified."
	},
	"ident: ": {
			"prefix": "ident()",
			"body": "ident()",
			"scope": "source.vex",
			"description": "Returns an identity matrix."
	},
	"removeprim: geohandle prim_number andpoints": {
			"prefix": "removeprim(geohandle, prim_number, andpoints)",
			"body": "removeprim(${1:geohandle}, ${2:prim_number}, ${3:andpoints})",
			"scope": "source.vex",
			"description": "Removes a primitive from the geometry."
	},
	"agentchannelnames: geometry prim": {
			"prefix": "agentchannelnames(geometry, prim)",
			"body": "agentchannelnames(${1:geometry}, ${2:prim})",
			"scope": "source.vex",
			"description": "Returns the names of the channels in an agent primitive\u2019s rig."
	},
	"pointedge: geometry point1 point2": {
			"prefix": "pointedge(geometry, point1, point2)",
			"body": "pointedge(${1:geometry}, ${2:point1}, ${3:point2})",
			"scope": "source.vex",
			"description": "Finds and returns a half-edge with the given endpoints."
	},
	"geounwrap: geometry unwrap_attribute": {
			"prefix": "geounwrap(geometry, unwrap_attribute)",
			"body": "geounwrap(${1:geometry}, ${2:unwrap_attribute})",
			"scope": "source.vex",
			"description": "Returns an oppath: string to unwrap the geometry in-place."
	},
	"atoi: str": {
			"prefix": "atoi(str)",
			"body": "atoi(${1:str})",
			"scope": "source.vex",
			"description": "Converts a string to an integer."
	},
	"atoi: str base": {
			"prefix": "atoi(str, base)",
			"body": "atoi(${1:str}, ${2:base})",
			"scope": "source.vex",
			"description": "Converts a string to an integer."
	},
	"acos: v": {
			"prefix": "acos(v)",
			"body": "acos(${1:v})",
			"scope": "source.vex",
			"description": "Returns the inverse cosine of the argument."
	},
	"rint: n": {
			"prefix": "rint(n)",
			"body": "rint(${1:n})",
			"scope": "source.vex",
			"description": "Rounds the number to the closest whole number."
	},
	"rint: v": {
			"prefix": "rint(v)",
			"body": "rint(${1:v})",
			"scope": "source.vex",
			"description": "Rounds the number to the closest whole number."
	},
	"hedge_postdstpoint: geometry hedge": {
			"prefix": "hedge_postdstpoint(geometry, hedge)",
			"body": "hedge_postdstpoint(${1:geometry}, ${2:hedge})",
			"scope": "source.vex",
			"description": "Returns the point into which the vertex following the destination vertex of a half-edge in its primitive is wired."
	},
	"pcimportbyidxf: handle channel_name idx": {
			"prefix": "pcimportbyidxf(handle, channel_name, idx)",
			"body": "pcimportbyidxf(${1:handle}, ${2:channel_name}, ${3:idx})",
			"scope": "source.vex",
			"description": "Imports channel data from a point cloud outside a pciterate or a pcunshaded loop."
	},
	"reverse: str": {
			"prefix": "reverse(str)",
			"body": "reverse(${1:str})",
			"scope": "source.vex",
			"description": "Returns an array or string in reverse order."
	},
	"reverse: values": {
			"prefix": "reverse(values)",
			"body": "reverse(${1:values})",
			"scope": "source.vex",
			"description": "Returns an array or string in reverse order."
	},
	"sort: values": {
			"prefix": "sort(values)",
			"body": "sort(${1:values})",
			"scope": "source.vex",
			"description": "Returns the array sorted in increasing order."
	},
	"invertexgroup: filename groupname vertexnum": {
			"prefix": "invertexgroup(filename, groupname, vertexnum)",
			"body": "invertexgroup(${1:filename}, ${2:groupname}, ${3:vertexnum})",
			"scope": "source.vex",
			"description": "Returns 1 if the vertex specified by the vertex number is in the group specified by the string."
	},
	"invertexgroup: opinput groupname vertexnum": {
			"prefix": "invertexgroup(opinput, groupname, vertexnum)",
			"body": "invertexgroup(${1:opinput}, ${2:groupname}, ${3:vertexnum})",
			"scope": "source.vex",
			"description": "Returns 1 if the vertex specified by the vertex number is in the group specified by the string."
	},
	"getpointbbox: geometry min max": {
			"prefix": "getpointbbox(geometry, min, max)",
			"body": "getpointbbox(${1:geometry}, ${2:min}, ${3:max})",
			"scope": "source.vex",
			"description": "Sets two vectors to the minimum and maximum corners of the bounding box for the geometry."
	},
	"getpointbbox: geometry pointgroup min max": {
			"prefix": "getpointbbox(geometry, pointgroup, min, max)",
			"body": "getpointbbox(${1:geometry}, ${2:pointgroup}, ${3:min}, ${4:max})",
			"scope": "source.vex",
			"description": "Sets two vectors to the minimum and maximum corners of the bounding box for the geometry."
	},
	"osd_patches: geometry face_id": {
			"prefix": "osd_patches(geometry, face_id)",
			"body": "osd_patches(${1:geometry}, ${2:face_id})",
			"scope": "source.vex",
			"description": "Returns a list of patch IDs for the patches in a subdivision hull."
	},
	"pcimportbyidxp: handle channel_name idx": {
			"prefix": "pcimportbyidxp(handle, channel_name, idx)",
			"body": "pcimportbyidxp(${1:handle}, ${2:channel_name}, ${3:idx})",
			"scope": "source.vex",
			"description": "Imports channel data from a point cloud outside a pciterate or a pcunshaded loop."
	},
	"inprimgroup: geometry groupname primnum": {
			"prefix": "inprimgroup(geometry, groupname, primnum)",
			"body": "inprimgroup(${1:geometry}, ${2:groupname}, ${3:primnum})",
			"scope": "source.vex",
			"description": "Returns 1 if the primitive specified by the primitive number is in the group specified by the string."
	},
	"asin: n": {
			"prefix": "asin(n)",
			"body": "asin(${1:n})",
			"scope": "source.vex",
			"description": "Returns the inverse sine of the argument."
	},
	"setagentlocaltransforms: geohandle prim transforms": {
			"prefix": "setagentlocaltransforms(geohandle, prim, transforms)",
			"body": "setagentlocaltransforms(${1:geohandle}, ${2:prim}, ${3:transforms})",
			"scope": "source.vex",
			"description": "Overrides the local space transforms of an agent primitive."
	},
	"expandvertexgroup: geometry groupname": {
			"prefix": "expandvertexgroup(geometry, groupname)",
			"body": "expandvertexgroup(${1:geometry}, ${2:groupname})",
			"scope": "source.vex",
			"description": "Returns an array of linear vertex numbers corresponding to a group string."
	},
	"tet_adjacent: geometry primindex faceno": {
			"prefix": "tet_adjacent(geometry, primindex, faceno)",
			"body": "tet_adjacent(${1:geometry}, ${2:primindex}, ${3:faceno})",
			"scope": "source.vex",
			"description": "Returns primitive number of an adjacent tetrahedron."
	},
	"pccone: geometry PChannel P dir angle max_distance maxpoints": {
			"prefix": "pccone(geometry, PChannel, P, dir, angle, max_distance, maxpoints)",
			"body": "pccone(${1:geometry}, ${2:PChannel}, ${3:P}, ${4:dir}, ${5:angle}, ${6:max_distance}, ${7:maxpoints})",
			"scope": "source.vex",
			"description": "Returns a list of closest points from a file within a specified cone."
	},
	"pccone: geometry ptgroup PChannel P dir angle max_distance maxpoints": {
			"prefix": "pccone(geometry, ptgroup, PChannel, P, dir, angle, max_distance, maxpoints)",
			"body": "pccone(${1:geometry}, ${2:ptgroup}, ${3:PChannel}, ${4:P}, ${5:dir}, ${6:angle}, ${7:max_distance}, ${8:maxpoints})",
			"scope": "source.vex",
			"description": "Returns a list of closest points from a file within a specified cone."
	},
	"agentlayers: geometry prim": {
			"prefix": "agentlayers(geometry, prim)",
			"body": "agentlayers(${1:geometry}, ${2:prim})",
			"scope": "source.vex",
			"description": "Returns all of the layers that have been loaded for an agent primitive."
	},
	"opstart: message": {
			"prefix": "opstart(message)",
			"body": "opstart(${1:message})",
			"scope": "source.vex",
			"description": "Start a long operation."
	},
	"concat: s1 s2 ...": {
			"prefix": "concat(s1, s2, ...)",
			"body": "concat(${1:s1}, ${2:s2}, ${3:...})",
			"scope": "source.vex",
			"description": "Concatenate all the strings specified to form a single string."
	},
	"opdigits: str": {
			"prefix": "opdigits(str)",
			"body": "opdigits(${1:str})",
			"scope": "source.vex",
			"description": "Returns the integer value of the last sequence of digits of a string"
	},
	"opdigits: ": {
			"prefix": "opdigits()",
			"body": "opdigits()",
			"scope": "source.vex",
			"description": "Returns the integer value of the last sequence of digits of a string"
	},
	"splitpath: fullpath dir name": {
			"prefix": "splitpath(fullpath, dir, name)",
			"body": "splitpath(${1:fullpath}, ${2:dir}, ${3:name})",
			"scope": "source.vex",
			"description": "Splits a file path into the directory and name parts."
	},
	"distance2: a b": {
			"prefix": "distance2(a, b)",
			"body": "distance2(${1:a}, ${2:b})",
			"scope": "source.vex",
			"description": "Returns the squared distance between the two points."
	},
	"cross: a b": {
			"prefix": "cross(a, b)",
			"body": "cross(${1:a}, ${2:b})",
			"scope": "source.vex",
			"description": "Returns the cross product between the two vectors."
	},
	"addprim: geohandle type": {
			"prefix": "addprim(geohandle, type)",
			"body": "addprim(${1:geohandle}, ${2:type})",
			"scope": "source.vex",
			"description": "Adds a primitive to the geometry."
	},
	"addprim: geohandle type pt0": {
			"prefix": "addprim(geohandle, type, pt0)",
			"body": "addprim(${1:geohandle}, ${2:type}, ${3:pt0})",
			"scope": "source.vex",
			"description": "Adds a primitive to the geometry."
	},
	"addprim: geohandle type pt0 pt1": {
			"prefix": "addprim(geohandle, type, pt0, pt1)",
			"body": "addprim(${1:geohandle}, ${2:type}, ${3:pt0}, ${4:pt1})",
			"scope": "source.vex",
			"description": "Adds a primitive to the geometry."
	},
	"addprim: geohandle type pt0 pt1 pt2": {
			"prefix": "addprim(geohandle, type, pt0, pt1, pt2)",
			"body": "addprim(${1:geohandle}, ${2:type}, ${3:pt0}, ${4:pt1}, ${5:pt2})",
			"scope": "source.vex",
			"description": "Adds a primitive to the geometry."
	},
	"addprim: geohandle type pt0 pt1 pt2 pt3": {
			"prefix": "addprim(geohandle, type, pt0, pt1, pt2, pt3)",
			"body": "addprim(${1:geohandle}, ${2:type}, ${3:pt0}, ${4:pt1}, ${5:pt2}, ${6:pt3})",
			"scope": "source.vex",
			"description": "Adds a primitive to the geometry."
	},
	"addprim: geohandle type points": {
			"prefix": "addprim(geohandle, type, points)",
			"body": "addprim(${1:geohandle}, ${2:type}, ${3:points})",
			"scope": "source.vex",
			"description": "Adds a primitive to the geometry."
	},
	"addprim: prim_num geohandle type pt0 vertices": {
			"prefix": "addprim(prim_num, geohandle, type, pt0, vertices)",
			"body": "addprim(${1:prim_num}, ${2:geohandle}, ${3:type}, ${4:pt0}, ${5:vertices})",
			"scope": "source.vex",
			"description": "Adds a primitive to the geometry."
	},
	"addprim: prim_num geohandle type pt0 pt1 vertices": {
			"prefix": "addprim(prim_num, geohandle, type, pt0, pt1, vertices)",
			"body": "addprim(${1:prim_num}, ${2:geohandle}, ${3:type}, ${4:pt0}, ${5:pt1}, ${6:vertices})",
			"scope": "source.vex",
			"description": "Adds a primitive to the geometry."
	},
	"addprim: prim_num geohandle type pt0 pt1 pt2 vertices": {
			"prefix": "addprim(prim_num, geohandle, type, pt0, pt1, pt2, vertices)",
			"body": "addprim(${1:prim_num}, ${2:geohandle}, ${3:type}, ${4:pt0}, ${5:pt1}, ${6:pt2}, ${7:vertices})",
			"scope": "source.vex",
			"description": "Adds a primitive to the geometry."
	},
	"addprim: prim_num geohandle type pt0 pt1 pt2 pt3 vertices": {
			"prefix": "addprim(prim_num, geohandle, type, pt0, pt1, pt2, pt3, vertices)",
			"body": "addprim(${1:prim_num}, ${2:geohandle}, ${3:type}, ${4:pt0}, ${5:pt1}, ${6:pt2}, ${7:pt3}, ${8:vertices})",
			"scope": "source.vex",
			"description": "Adds a primitive to the geometry."
	},
	"addprim: prim_num geohandle type points vertices": {
			"prefix": "addprim(prim_num, geohandle, type, points, vertices)",
			"body": "addprim(${1:prim_num}, ${2:geohandle}, ${3:type}, ${4:points}, ${5:vertices})",
			"scope": "source.vex",
			"description": "Adds a primitive to the geometry."
	},
	"getsmoothP: smoothP ray_origin ...": {
			"prefix": "getsmoothP(smoothP, ray_origin, ...)",
			"body": "getsmoothP(${1:smoothP}, ${2:ray_origin}, ${3:...})",
			"scope": "source.vex",
			"description": "Returns modified surface position based on a smoothing function."
	},
	"getsmoothP: ...": {
			"prefix": "getsmoothP(...)",
			"body": "getsmoothP(${1:...})",
			"scope": "source.vex",
			"description": "Returns modified surface position based on a smoothing function."
	},
	"sample_lognormal_by_median: median stddev u": {
			"prefix": "sample_lognormal_by_median(median, stddev, u)",
			"body": "sample_lognormal_by_median(${1:median}, ${2:stddev}, ${3:u})",
			"scope": "source.vex",
			"description": "Samples the log-normal distribution based on median and standard deviation."
	},
	"sample_lognormal_by_median: origmedian origstddev minvalue maxvalue u": {
			"prefix": "sample_lognormal_by_median(origmedian, origstddev, minvalue, maxvalue, u)",
			"body": "sample_lognormal_by_median(${1:origmedian}, ${2:origstddev}, ${3:minvalue}, ${4:maxvalue}, ${5:u})",
			"scope": "source.vex",
			"description": "Samples the log-normal distribution based on median and standard deviation."
	},
	"setpackedtransform: input primnum transform": {
			"prefix": "setpackedtransform(input, primnum, transform)",
			"body": "setpackedtransform(${1:input}, ${2:primnum}, ${3:transform})",
			"scope": "source.vex",
			"description": "Sets the transform of a packed primitive."
	},
	"normalize: v": {
			"prefix": "normalize(v)",
			"body": "normalize(${1:v})",
			"scope": "source.vex",
			"description": "Returns a normalized vector."
	},
	"diffuseBRDF: L N": {
			"prefix": "diffuseBRDF(L, N)",
			"body": "diffuseBRDF(${1:L}, ${2:N})",
			"scope": "source.vex",
			"description": ""
	},
	"diffuseBRDF: L N V rough": {
			"prefix": "diffuseBRDF(L, N, V, rough)",
			"body": "diffuseBRDF(${1:L}, ${2:N}, ${3:V}, ${4:rough})",
			"scope": "source.vex",
			"description": ""
	},
	"phong: exponent ...": {
			"prefix": "phong(exponent, ...)",
			"body": "phong(${1:exponent}, ${2:...})",
			"scope": "source.vex",
			"description": "Returns a Phong BSDF or computes Phong shading."
	},
	"phong: nml exponent ...": {
			"prefix": "phong(nml, exponent, ...)",
			"body": "phong(${1:nml}, ${2:exponent}, ${3:...})",
			"scope": "source.vex",
			"description": "Returns a Phong BSDF or computes Phong shading."
	},
	"phong: nml V shinyness ...": {
			"prefix": "phong(nml, V, shinyness, ...)",
			"body": "phong(${1:nml}, ${2:V}, ${3:shinyness}, ${4:...})",
			"scope": "source.vex",
			"description": "Returns a Phong BSDF or computes Phong shading."
	},
	"swizzle: v i0 i1": {
			"prefix": "swizzle(v, i0, i1)",
			"body": "swizzle(${1:v}, ${2:i0}, ${3:i1})",
			"scope": "source.vex",
			"description": "Rearranges the components of a vector."
	},
	"swizzle: v i0 i1 i2": {
			"prefix": "swizzle(v, i0, i1, i2)",
			"body": "swizzle(${1:v}, ${2:i0}, ${3:i1}, ${4:i2})",
			"scope": "source.vex",
			"description": "Rearranges the components of a vector."
	},
	"swizzle: v i0 i1 i2 i3": {
			"prefix": "swizzle(v, i0, i1, i2, i3)",
			"body": "swizzle(${1:v}, ${2:i0}, ${3:i1}, ${4:i2}, ${5:i3})",
			"scope": "source.vex",
			"description": "Rearranges the components of a vector."
	},
	"vertexnext: geometry linearvertex": {
			"prefix": "vertexnext(geometry, linearvertex)",
			"body": "vertexnext(${1:geometry}, ${2:linearvertex})",
			"scope": "source.vex",
			"description": "Returns the linear vertex number of the next vertex sharing a point with a given vertex."
	},
	"vertexpoint: geometry linearvertex": {
			"prefix": "vertexpoint(geometry, linearvertex)",
			"body": "vertexpoint(${1:geometry}, ${2:linearvertex})",
			"scope": "source.vex",
			"description": "Returns the point number of linear vertex in a geometry."
	},
	"nearpoint: geometry pt": {
			"prefix": "nearpoint(geometry, pt)",
			"body": "nearpoint(${1:geometry}, ${2:pt})",
			"scope": "source.vex",
			"description": "Finds the closest point in a geometry."
	},
	"nearpoint: geometry pt maxdist": {
			"prefix": "nearpoint(geometry, pt, maxdist)",
			"body": "nearpoint(${1:geometry}, ${2:pt}, ${3:maxdist})",
			"scope": "source.vex",
			"description": "Finds the closest point in a geometry."
	},
	"nearpoint: geometry ptgroup pt": {
			"prefix": "nearpoint(geometry, ptgroup, pt)",
			"body": "nearpoint(${1:geometry}, ${2:ptgroup}, ${3:pt})",
			"scope": "source.vex",
			"description": "Finds the closest point in a geometry."
	},
	"nearpoint: geometry ptgroup pt maxdist": {
			"prefix": "nearpoint(geometry, ptgroup, pt, maxdist)",
			"body": "nearpoint(${1:geometry}, ${2:ptgroup}, ${3:pt}, ${4:maxdist})",
			"scope": "source.vex",
			"description": "Finds the closest point in a geometry."
	},
	"fresnel: i n eta kr kt": {
			"prefix": "fresnel(i, n, eta, kr, kt)",
			"body": "fresnel(${1:i}, ${2:n}, ${3:eta}, ${4:kr}, ${5:kt})",
			"scope": "source.vex",
			"description": "Computes the fresnel reflection/refraction contributions given an\nincoming vector, surface normal (both normalized), and an index of\nrefraction (eta)."
	},
	"fresnel: i n eta kr kt R T": {
			"prefix": "fresnel(i, n, eta, kr, kt, R, T)",
			"body": "fresnel(${1:i}, ${2:n}, ${3:eta}, ${4:kr}, ${5:kt}, ${6:R}, ${7:T})",
			"scope": "source.vex",
			"description": "Computes the fresnel reflection/refraction contributions given an\nincoming vector, surface normal (both normalized), and an index of\nrefraction (eta)."
	},
	"getmaterial: ": {
			"prefix": "getmaterial()",
			"body": "getmaterial()",
			"scope": "source.vex",
			"description": "Returns a material struct for the current surface."
	},
	"match: pattern subject": {
			"prefix": "match(pattern, subject)",
			"body": "match(${1:pattern}, ${2:subject})",
			"scope": "source.vex",
			"description": "This function returns 1 if the subject matches the pattern specified,\nor 0 if the subject doesn\u2019t match."
	},
	"sample_circle_arc: center maxangle u": {
			"prefix": "sample_circle_arc(center, maxangle, u)",
			"body": "sample_circle_arc(${1:center}, ${2:maxangle}, ${3:u})",
			"scope": "source.vex",
			"description": "Generates a uniform unit vector2, within maxangle of center, given a uniform number between 0 and 1."
	},
	"hedge_isprimary: geometry hedge": {
			"prefix": "hedge_isprimary(geometry, hedge)",
			"body": "hedge_isprimary(${1:geometry}, ${2:hedge})",
			"scope": "source.vex",
			"description": "Determines whether a half-edge number corresponds to a primary half-edge."
	},
	"hedge_isprimary: opinput hendge": {
			"prefix": "hedge_isprimary(opinput, hendge)",
			"body": "hedge_isprimary(${1:opinput}, ${2:hendge})",
			"scope": "source.vex",
			"description": "Determines whether a half-edge number corresponds to a primary half-edge."
	},
	"hscript_snoise: pos": {
			"prefix": "hscript_snoise(pos)",
			"body": "hscript_snoise(${1:pos})",
			"scope": "source.vex",
			"description": ""
	},
	"floor: n": {
			"prefix": "floor(n)",
			"body": "floor(${1:n})",
			"scope": "source.vex",
			"description": "Returns the largest integer less than or equal to the argument."
	},
	"floor: v": {
			"prefix": "floor(v)",
			"body": "floor(${1:v})",
			"scope": "source.vex",
			"description": "Returns the largest integer less than or equal to the argument."
	},
	"simport: name value": {
			"prefix": "simport(name, value)",
			"body": "simport(${1:name}, ${2:value})",
			"scope": "source.vex",
			"description": "Imports a variable sent by a surface shader in an illuminance loop."
	},
	"chnumchan: ": {
			"prefix": "chnumchan()",
			"body": "chnumchan()",
			"scope": "source.vex",
			"description": "Returns the number of channels in the input specified."
	},
	"chnumchan: opinput": {
			"prefix": "chnumchan(opinput)",
			"body": "chnumchan(${1:opinput})",
			"scope": "source.vex",
			"description": "Returns the number of channels in the input specified."
	},
	"nedgesgroup: filename groupname": {
			"prefix": "nedgesgroup(filename, groupname)",
			"body": "nedgesgroup(${1:filename}, ${2:groupname})",
			"scope": "source.vex",
			"description": "Returns the number of edges in the group."
	},
	"nedgesgroup: input groupname": {
			"prefix": "nedgesgroup(input, groupname)",
			"body": "nedgesgroup(${1:input}, ${2:groupname})",
			"scope": "source.vex",
			"description": "Returns the number of edges in the group."
	},
	"prescale: m scale_vector": {
			"prefix": "prescale(m, scale_vector)",
			"body": "prescale(${1:m}, ${2:scale_vector})",
			"scope": "source.vex",
			"description": "Prescales the given matrix in three directions simultaneously (X, Y, Z -\ngiven by the components of the scale_vector)."
	},
	"setprimintrinsic: geohandle name prim_num value mode": {
			"prefix": "setprimintrinsic(geohandle, name, prim_num, value, mode)",
			"body": "setprimintrinsic(${1:geohandle}, ${2:name}, ${3:prim_num}, ${4:value}, ${5:mode})",
			"scope": "source.vex",
			"description": "Sets the value of a writeable primitive intrinsic attribute."
	},
	"usd_setprimvar: stagehandle primpath name value": {
			"prefix": "usd_setprimvar(stagehandle, primpath, name, value)",
			"body": "usd_setprimvar(${1:stagehandle}, ${2:primpath}, ${3:name}, ${4:value})",
			"scope": "source.vex",
			"description": "Sets the value of a primvar."
	},
	"agentlocaltransforms: geometry prim": {
			"prefix": "agentlocaltransforms(geometry, prim)",
			"body": "agentlocaltransforms(${1:geometry}, ${2:prim})",
			"scope": "source.vex",
			"description": "Returns the current local space transforms of an agent primitive."
	},
	"eulertoquaternion: rotations order": {
			"prefix": "eulertoquaternion(rotations, order)",
			"body": "eulertoquaternion(${1:rotations}, ${2:order})",
			"scope": "source.vex",
			"description": "Creates a vector4 representing a quaternion from euler angles."
	},
	"addpointattrib: geohandle name defvalue": {
			"prefix": "addpointattrib(geohandle, name, defvalue)",
			"body": "addpointattrib(${1:geohandle}, ${2:name}, ${3:defvalue})",
			"scope": "source.vex",
			"description": "Adds a point attribute to a geometry."
	},
	"addpointattrib: geohandle name defvalue typeinfo": {
			"prefix": "addpointattrib(geohandle, name, defvalue, typeinfo)",
			"body": "addpointattrib(${1:geohandle}, ${2:name}, ${3:defvalue}, ${4:typeinfo})",
			"scope": "source.vex",
			"description": "Adds a point attribute to a geometry."
	},
	"usd_flattenedprimvar: stage primpath name": {
			"prefix": "usd_flattenedprimvar(stage, primpath, name)",
			"body": "usd_flattenedprimvar(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Reads the value of an flattened primvar from the USD primitive."
	},
	"usd_flattenedprimvar: stage primpath name timecode": {
			"prefix": "usd_flattenedprimvar(stage, primpath, name, timecode)",
			"body": "usd_flattenedprimvar(${1:stage}, ${2:primpath}, ${3:name}, ${4:timecode})",
			"scope": "source.vex",
			"description": "Reads the value of an flattened primvar from the USD primitive."
	},
	"pcwrite: filename ...": {
			"prefix": "pcwrite(filename, ...)",
			"body": "pcwrite(${1:filename}, ${2:...})",
			"scope": "source.vex",
			"description": "Writes data to a point cloud file."
	},
	"shimport: variable_name value": {
			"prefix": "shimport(variable_name, value)",
			"body": "shimport(${1:variable_name}, ${2:value})",
			"scope": "source.vex",
			"description": "Imports a variable from the shadow shader for the surface."
	},
	"chadd: channel_names": {
			"prefix": "chadd(channel_names)",
			"body": "chadd(${1:channel_names})",
			"scope": "source.vex",
			"description": "Adds new channels to a CHOP node."
	},
	"usd_hasapi: stage primpath api": {
			"prefix": "usd_hasapi(stage, primpath, api)",
			"body": "usd_hasapi(${1:stage}, ${2:primpath}, ${3:api})",
			"scope": "source.vex",
			"description": "Checks if the primitive adheres to the given API."
	},
	"vnoise: position jitter seed f1 f2 pos1 pos2": {
			"prefix": "vnoise(position, jitter, seed, f1, f2, pos1, pos2)",
			"body": "vnoise(${1:position}, ${2:jitter}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:pos1}, ${7:pos2})",
			"scope": "source.vex",
			"description": "Generates Voronoi (cellular) noise."
	},
	"vnoise: position jitter seed f1 f2 pos1 pos2 period": {
			"prefix": "vnoise(position, jitter, seed, f1, f2, pos1, pos2, period)",
			"body": "vnoise(${1:position}, ${2:jitter}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:pos1}, ${7:pos2}, ${8:period})",
			"scope": "source.vex",
			"description": "Generates Voronoi (cellular) noise."
	},
	"vnoise: posx posy jittx jitty seed f1 f2 pos1x pos1y pos2x pos2y": {
			"prefix": "vnoise(posx, posy, jittx, jitty, seed, f1, f2, pos1x, pos1y, pos2x, pos2y)",
			"body": "vnoise(${1:posx}, ${2:posy}, ${3:jittx}, ${4:jitty}, ${5:seed}, ${6:f1}, ${7:f2}, ${8:pos1x}, ${9:pos1y}, ${10:pos2x}, ${11:pos2y})",
			"scope": "source.vex",
			"description": "Generates Voronoi (cellular) noise."
	},
	"vnoise: posx posy jittx jitty seed f1 f2 pos1x pos1y pos2x pos2 periodx periody": {
			"prefix": "vnoise(posx, posy, jittx, jitty, seed, f1, f2, pos1x, pos1y, pos2x, pos2, periodx, periody)",
			"body": "vnoise(${1:posx}, ${2:posy}, ${3:jittx}, ${4:jitty}, ${5:seed}, ${6:f1}, ${7:f2}, ${8:pos1x}, ${9:pos1y}, ${10:pos2x}, ${11:pos2}, ${12:periodx}, ${13:periody})",
			"scope": "source.vex",
			"description": "Generates Voronoi (cellular) noise."
	},
	"vnoise: position jitter seed f1 f2 pos1 pos2 periodx periody periodz": {
			"prefix": "vnoise(position, jitter, seed, f1, f2, pos1, pos2, periodx, periody, periodz)",
			"body": "vnoise(${1:position}, ${2:jitter}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:pos1}, ${7:pos2}, ${8:periodx}, ${9:periody}, ${10:periodz})",
			"scope": "source.vex",
			"description": "Generates Voronoi (cellular) noise."
	},
	"vnoise: position jitter seed f1 f2 pos1 pos2 periodx periody periodz periodw": {
			"prefix": "vnoise(position, jitter, seed, f1, f2, pos1, pos2, periodx, periody, periodz, periodw)",
			"body": "vnoise(${1:position}, ${2:jitter}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:pos1}, ${7:pos2}, ${8:periodx}, ${9:periody}, ${10:periodz}, ${11:periodw})",
			"scope": "source.vex",
			"description": "Generates Voronoi (cellular) noise."
	},
	"wnoise: position seed f1 f2": {
			"prefix": "wnoise(position, seed, f1, f2)",
			"body": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise."
	},
	"wnoise: position seed f1 f2 f3 f4": {
			"prefix": "wnoise(position, seed, f1, f2, f3, f4)",
			"body": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise."
	},
	"wnoise: position seed f1 f2 peiod": {
			"prefix": "wnoise(position, seed, f1, f2, peiod)",
			"body": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:peiod})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise."
	},
	"wnoise: position seed f1 f2 f4 f4 period": {
			"prefix": "wnoise(position, seed, f1, f2, f4, f4, period)",
			"body": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f4}, ${6:f4}, ${7:period})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise."
	},
	"wnoise: posx posy seed f1 f2": {
			"prefix": "wnoise(posx, posy, seed, f1, f2)",
			"body": "wnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise."
	},
	"wnoise: posx posy seed f1 f2 f3 f4": {
			"prefix": "wnoise(posx, posy, seed, f1, f2, f3, f4)",
			"body": "wnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:f3}, ${7:f4})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise."
	},
	"wnoise: posx posy seed f1 f2 periodx periody": {
			"prefix": "wnoise(posx, posy, seed, f1, f2, periodx, periody)",
			"body": "wnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:periodx}, ${7:periody})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise."
	},
	"wnoise: posx posy seed f1 f2 f3 f4 periodx periody": {
			"prefix": "wnoise(posx, posy, seed, f1, f2, f3, f4, periodx, periody)",
			"body": "wnoise(${1:posx}, ${2:posy}, ${3:seed}, ${4:f1}, ${5:f2}, ${6:f3}, ${7:f4}, ${8:periodx}, ${9:periody})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise."
	},
	"wnoise: position seed f1 f2 periodx periody": {
			"prefix": "wnoise(position, seed, f1, f2, periodx, periody)",
			"body": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:periodx}, ${6:periody})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise."
	},
	"wnoise: position seed f1 f2 f3 f4 periodx periody": {
			"prefix": "wnoise(position, seed, f1, f2, f3, f4, periodx, periody)",
			"body": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4}, ${7:periodx}, ${8:periody})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise."
	},
	"wnoise: position seed f1 f2 periodx periody periodx": {
			"prefix": "wnoise(position, seed, f1, f2, periodx, periody, periodx)",
			"body": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:periodx}, ${6:periody}, ${7:periodx})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise."
	},
	"wnoise: position seed f1 f2 f3 f4 periodx periody periodz": {
			"prefix": "wnoise(position, seed, f1, f2, f3, f4, periodx, periody, periodz)",
			"body": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4}, ${7:periodx}, ${8:periody}, ${9:periodz})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise."
	},
	"wnoise: position seed f1 f2 periodx periody periodz periodw": {
			"prefix": "wnoise(position, seed, f1, f2, periodx, periody, periodz, periodw)",
			"body": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:periodx}, ${6:periody}, ${7:periodz}, ${8:periodw})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise."
	},
	"wnoise: position seed f1 f2 f3 f4 periodx periody periodz periodw": {
			"prefix": "wnoise(position, seed, f1, f2, f3, f4, periodx, periody, periodz, periodw)",
			"body": "wnoise(${1:position}, ${2:seed}, ${3:f1}, ${4:f2}, ${5:f3}, ${6:f4}, ${7:periodx}, ${8:periody}, ${9:periodz}, ${10:periodw})",
			"scope": "source.vex",
			"description": "Generates Worley (cellular) noise."
	},
	"volumepostoindex: geometry primnum position": {
			"prefix": "volumepostoindex(geometry, primnum, position)",
			"body": "volumepostoindex(${1:geometry}, ${2:primnum}, ${3:position})",
			"scope": "source.vex",
			"description": "Converts a position into a volume voxel index."
	},
	"volumepostoindex: geometry volumename position": {
			"prefix": "volumepostoindex(geometry, volumename, position)",
			"body": "volumepostoindex(${1:geometry}, ${2:volumename}, ${3:position})",
			"scope": "source.vex",
			"description": "Converts a position into a volume voxel index."
	},
	"usd_pointinstance_getbbox_min: stage primpath instance_index purpose": {
			"prefix": "usd_pointinstance_getbbox_min(stage, primpath, instance_index, purpose)",
			"body": "usd_pointinstance_getbbox_min(${1:stage}, ${2:primpath}, ${3:instance_index}, ${4:purpose})",
			"scope": "source.vex",
			"description": "Returns the minimum position of the bounding box for the instance inside a point instancer primitive."
	},
	"usd_addtotransformorder: stagehandle primpath name": {
			"prefix": "usd_addtotransformorder(stagehandle, primpath, name)",
			"body": "usd_addtotransformorder(${1:stagehandle}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Appends a transform operation to the primitive\u2019s transform order"
	},
	"refract: direction normal index": {
			"prefix": "refract(direction, normal, index)",
			"body": "refract(${1:direction}, ${2:normal}, ${3:index})",
			"scope": "source.vex",
			"description": "Returns the refraction ray given an incoming direction, the\nnormalized normal and an index of refraction."
	},
	"wo_nspace: v": {
			"prefix": "wo_nspace(v)",
			"body": "wo_nspace(${1:v})",
			"scope": "source.vex",
			"description": "Transforms a normal vector from World to Object space."
	},
	"sensor_panorama_getcolor: handle dir": {
			"prefix": "sensor_panorama_getcolor(handle, dir)",
			"body": "sensor_panorama_getcolor(${1:handle}, ${2:dir})",
			"scope": "source.vex",
			"description": "Sensor function query a rendered GL scene."
	},
	"usd_transformtype: name": {
			"prefix": "usd_transformtype(name)",
			"body": "usd_transformtype(${1:name})",
			"scope": "source.vex",
			"description": "Infers the transform operation type from the full name"
	},
	"pcimportbyidx3: handle channel_name idx": {
			"prefix": "pcimportbyidx3(handle, channel_name, idx)",
			"body": "pcimportbyidx3(${1:handle}, ${2:channel_name}, ${3:idx})",
			"scope": "source.vex",
			"description": "Imports channel data from a point cloud outside a pciterate or a pcunshaded loop."
	},
	"texture: map ...": {
			"prefix": "texture(map, ...)",
			"body": "texture(${1:map}, ${2:...})",
			"scope": "source.vex",
			"description": "Computes a filtered sample of the texture map specified."
	},
	"texture: map ss tt ...": {
			"prefix": "texture(map, ss, tt, ...)",
			"body": "texture(${1:map}, ${2:ss}, ${3:tt}, ${4:...})",
			"scope": "source.vex",
			"description": "Computes a filtered sample of the texture map specified."
	},
	"texture: map s0 t0 s1 t1 s2 t2 s3 t3 ...": {
			"prefix": "texture(map, s0, t0, s1, t1, s2, t2, s3, t3, ...)",
			"body": "texture(${1:map}, ${2:s0}, ${3:t0}, ${4:s1}, ${5:t1}, ${6:s2}, ${7:t2}, ${8:s3}, ${9:t3}, ${10:...})",
			"scope": "source.vex",
			"description": "Computes a filtered sample of the texture map specified."
	},
	"nearpoints: geometry pt maxdist": {
			"prefix": "nearpoints(geometry, pt, maxdist)",
			"body": "nearpoints(${1:geometry}, ${2:pt}, ${3:maxdist})",
			"scope": "source.vex",
			"description": "Finds the all the closest point in a geometry."
	},
	"nearpoints: geometry pt maxdist maxpts": {
			"prefix": "nearpoints(geometry, pt, maxdist, maxpts)",
			"body": "nearpoints(${1:geometry}, ${2:pt}, ${3:maxdist}, ${4:maxpts})",
			"scope": "source.vex",
			"description": "Finds the all the closest point in a geometry."
	},
	"nearpoints: geometry ptgroup pt maxdist": {
			"prefix": "nearpoints(geometry, ptgroup, pt, maxdist)",
			"body": "nearpoints(${1:geometry}, ${2:ptgroup}, ${3:pt}, ${4:maxdist})",
			"scope": "source.vex",
			"description": "Finds the all the closest point in a geometry."
	},
	"nearpoints: geometry ptgroup pt maxdist maxpts": {
			"prefix": "nearpoints(geometry, ptgroup, pt, maxdist, maxpts)",
			"body": "nearpoints(${1:geometry}, ${2:ptgroup}, ${3:pt}, ${4:maxdist}, ${5:maxpts})",
			"scope": "source.vex",
			"description": "Finds the all the closest point in a geometry."
	},
	"iaspect: opinput": {
			"prefix": "iaspect(opinput)",
			"body": "iaspect(${1:opinput})",
			"scope": "source.vex",
			"description": "Returns the aspect ratio of the specified input."
	},
	"kspline: basis sample_pos value1 key_pos1 ...": {
			"prefix": "kspline(basis, sample_pos, value1, key_pos1, ...)",
			"body": "kspline(${1:basis}, ${2:sample_pos}, ${3:value1}, ${4:key_pos1}, ${5:...})",
			"scope": "source.vex",
			"description": "Returns an interpolated value along a curve defined by a basis and key/position pairs."
	},
	"wo_space: ": {
			"prefix": "wo_space()",
			"body": "wo_space()",
			"scope": "source.vex",
			"description": "Transforms a position value from World to Object space."
	},
	"wo_space: pos": {
			"prefix": "wo_space(pos)",
			"body": "wo_space(${1:pos})",
			"scope": "source.vex",
			"description": "Transforms a position value from World to Object space."
	},
	"pcimportbyidxs: handle channel_name idx": {
			"prefix": "pcimportbyidxs(handle, channel_name, idx)",
			"body": "pcimportbyidxs(${1:handle}, ${2:channel_name}, ${3:idx})",
			"scope": "source.vex",
			"description": "Imports channel data from a point cloud outside a pciterate or a pcunshaded loop."
	},
	"usd_isattrib: stage primpath name": {
			"prefix": "usd_isattrib(stage, primpath, name)",
			"body": "usd_isattrib(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Checks if the primitive has an attribute by the given name."
	},
	"getbbox_size: geometry": {
			"prefix": "getbbox_size(geometry)",
			"body": "getbbox_size(${1:geometry})",
			"scope": "source.vex",
			"description": "Returns the size of the bounding box for the geometry."
	},
	"getbbox_size: geometry primgroup": {
			"prefix": "getbbox_size(geometry, primgroup)",
			"body": "getbbox_size(${1:geometry}, ${2:primgroup})",
			"scope": "source.vex",
			"description": "Returns the size of the bounding box for the geometry."
	},
	"eigenvalues: nroot mat real imaginary": {
			"prefix": "eigenvalues(nroot, mat, real, imaginary)",
			"body": "eigenvalues(${1:nroot}, ${2:mat}, ${3:real}, ${4:imaginary})",
			"scope": "source.vex",
			"description": "Computes the eigenvalues of a 3\u00d73 matrix."
	},
	"agentsolvefbik: geometry outgeo prim targets targetxforms xformgroup iters": {
			"prefix": "agentsolvefbik(geometry, outgeo, prim, targets, targetxforms, xformgroup, iters)",
			"body": "agentsolvefbik(${1:geometry}, ${2:outgeo}, ${3:prim}, ${4:targets}, ${5:targetxforms}, ${6:xformgroup}, ${7:iters})",
			"scope": "source.vex",
			"description": "Applies a full-body inverse kinematics algorithm to an agent\u2019s skeleton."
	},
	"agentsolvefbik: geometry outgeo prim targets targetxforms xformgroup iters tolerance pinroot": {
			"prefix": "agentsolvefbik(geometry, outgeo, prim, targets, targetxforms, xformgroup, iters, tolerance, pinroot)",
			"body": "agentsolvefbik(${1:geometry}, ${2:outgeo}, ${3:prim}, ${4:targets}, ${5:targetxforms}, ${6:xformgroup}, ${7:iters}, ${8:tolerance}, ${9:pinroot})",
			"scope": "source.vex",
			"description": "Applies a full-body inverse kinematics algorithm to an agent\u2019s skeleton."
	},
	"agentsolvefbik: geometry outgeo prim targets targetxforms xformgroup iters tolerance pinroot targetweights targetpriorities targetdepths": {
			"prefix": "agentsolvefbik(geometry, outgeo, prim, targets, targetxforms, xformgroup, iters, tolerance, pinroot, targetweights, targetpriorities, targetdepths)",
			"body": "agentsolvefbik(${1:geometry}, ${2:outgeo}, ${3:prim}, ${4:targets}, ${5:targetxforms}, ${6:xformgroup}, ${7:iters}, ${8:tolerance}, ${9:pinroot}, ${10:targetweights}, ${11:targetpriorities}, ${12:targetdepths})",
			"scope": "source.vex",
			"description": "Applies a full-body inverse kinematics algorithm to an agent\u2019s skeleton."
	},
	"agentsolvefbik: geometry outgeo prim targets targetxforms xformgroup iters tolerance pinroot targetweights targetpriorities targetdepths targettypes targetoffsets": {
			"prefix": "agentsolvefbik(geometry, outgeo, prim, targets, targetxforms, xformgroup, iters, tolerance, pinroot, targetweights, targetpriorities, targetdepths, targettypes, targetoffsets)",
			"body": "agentsolvefbik(${1:geometry}, ${2:outgeo}, ${3:prim}, ${4:targets}, ${5:targetxforms}, ${6:xformgroup}, ${7:iters}, ${8:tolerance}, ${9:pinroot}, ${10:targetweights}, ${11:targetpriorities}, ${12:targetdepths}, ${13:targettypes}, ${14:targetoffsets})",
			"scope": "source.vex",
			"description": "Applies a full-body inverse kinematics algorithm to an agent\u2019s skeleton."
	},
	"agentsolvefbik: geometry outgeo prim targets targetxforms xformgroup iters tolerance pinroot targetweights targetpriorities targetdepths goalxformattrib constrainedxformattrib jointlimitsattrib": {
			"prefix": "agentsolvefbik(geometry, outgeo, prim, targets, targetxforms, xformgroup, iters, tolerance, pinroot, targetweights, targetpriorities, targetdepths, goalxformattrib, constrainedxformattrib, jointlimitsattrib)",
			"body": "agentsolvefbik(${1:geometry}, ${2:outgeo}, ${3:prim}, ${4:targets}, ${5:targetxforms}, ${6:xformgroup}, ${7:iters}, ${8:tolerance}, ${9:pinroot}, ${10:targetweights}, ${11:targetpriorities}, ${12:targetdepths}, ${13:goalxformattrib}, ${14:constrainedxformattrib}, ${15:jointlimitsattrib})",
			"scope": "source.vex",
			"description": "Applies a full-body inverse kinematics algorithm to an agent\u2019s skeleton."
	},
	"agentsolvefbik: geometry outgeo prim targets targetxforms xformgroup iters tolerance pinroot targetweights targetpriorities targetdepths targettypes targetoffsets goalxformattrib constrainedxformattrib jointlimitsattrib": {
			"prefix": "agentsolvefbik(geometry, outgeo, prim, targets, targetxforms, xformgroup, iters, tolerance, pinroot, targetweights, targetpriorities, targetdepths, targettypes, targetoffsets, goalxformattrib, constrainedxformattrib, jointlimitsattrib)",
			"body": "agentsolvefbik(${1:geometry}, ${2:outgeo}, ${3:prim}, ${4:targets}, ${5:targetxforms}, ${6:xformgroup}, ${7:iters}, ${8:tolerance}, ${9:pinroot}, ${10:targetweights}, ${11:targetpriorities}, ${12:targetdepths}, ${13:targettypes}, ${14:targetoffsets}, ${15:goalxformattrib}, ${16:constrainedxformattrib}, ${17:jointlimitsattrib})",
			"scope": "source.vex",
			"description": "Applies a full-body inverse kinematics algorithm to an agent\u2019s skeleton."
	},
	"startswith: str startswith": {
			"prefix": "startswith(str, startswith)",
			"body": "startswith(${1:str}, ${2:startswith})",
			"scope": "source.vex",
			"description": "Returns 1 if the string starts with the specified string."
	},
	"usd_isactive: stage primpath": {
			"prefix": "usd_isactive(stage, primpath)",
			"body": "usd_isactive(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Checks if the primitive is active."
	},
	"usd_addscale: stagehandle primpath suffix scale": {
			"prefix": "usd_addscale(stagehandle, primpath, suffix, scale)",
			"body": "usd_addscale(${1:stagehandle}, ${2:primpath}, ${3:suffix}, ${4:scale})",
			"scope": "source.vex",
			"description": "Applies a scale to the primitive"
	},
	"maketransform: zaxis yaxis": {
			"prefix": "maketransform(zaxis, yaxis)",
			"body": "maketransform(${1:zaxis}, ${2:yaxis})",
			"scope": "source.vex",
			"description": "Builds a 3\u00d73 or 4\u00d74 transform matrix."
	},
	"maketransform: xyz angles": {
			"prefix": "maketransform(xyz, angles)",
			"body": "maketransform(${1:xyz}, ${2:angles})",
			"scope": "source.vex",
			"description": "Builds a 3\u00d73 or 4\u00d74 transform matrix."
	},
	"maketransform: zaxis yaxis translate": {
			"prefix": "maketransform(zaxis, yaxis, translate)",
			"body": "maketransform(${1:zaxis}, ${2:yaxis}, ${3:translate})",
			"scope": "source.vex",
			"description": "Builds a 3\u00d73 or 4\u00d74 transform matrix."
	},
	"maketransform: trs xyz t r": {
			"prefix": "maketransform(trs, xyz, t, r)",
			"body": "maketransform(${1:trs}, ${2:xyz}, ${3:t}, ${4:r})",
			"scope": "source.vex",
			"description": "Builds a 3\u00d73 or 4\u00d74 transform matrix."
	},
	"maketransform: trs xyz t r s": {
			"prefix": "maketransform(trs, xyz, t, r, s)",
			"body": "maketransform(${1:trs}, ${2:xyz}, ${3:t}, ${4:r}, ${5:s})",
			"scope": "source.vex",
			"description": "Builds a 3\u00d73 or 4\u00d74 transform matrix."
	},
	"maketransform: trs xyz t r s p": {
			"prefix": "maketransform(trs, xyz, t, r, s, p)",
			"body": "maketransform(${1:trs}, ${2:xyz}, ${3:t}, ${4:r}, ${5:s}, ${6:p})",
			"scope": "source.vex",
			"description": "Builds a 3\u00d73 or 4\u00d74 transform matrix."
	},
	"maketransform: trs xyz t r s p pr": {
			"prefix": "maketransform(trs, xyz, t, r, s, p, pr)",
			"body": "maketransform(${1:trs}, ${2:xyz}, ${3:t}, ${4:r}, ${5:s}, ${6:p}, ${7:pr})",
			"scope": "source.vex",
			"description": "Builds a 3\u00d73 or 4\u00d74 transform matrix."
	},
	"maketransform: trs xyz t r s p pr shears": {
			"prefix": "maketransform(trs, xyz, t, r, s, p, pr, shears)",
			"body": "maketransform(${1:trs}, ${2:xyz}, ${3:t}, ${4:r}, ${5:s}, ${6:p}, ${7:pr}, ${8:shears})",
			"scope": "source.vex",
			"description": "Builds a 3\u00d73 or 4\u00d74 transform matrix."
	},
	"metaweight: filename p": {
			"prefix": "metaweight(filename, p)",
			"body": "metaweight(${1:filename}, ${2:p})",
			"scope": "source.vex",
			"description": "Returns the metaweight of the geometry at position p."
	},
	"sample_sphere_shell_uniform: u alpha": {
			"prefix": "sample_sphere_shell_uniform(u, alpha)",
			"body": "sample_sphere_shell_uniform(${1:u}, ${2:alpha})",
			"scope": "source.vex",
			"description": "Generates a uniform vector with alpha < length < 1, where 0 < alpha < 1, given a vector of uniform numbers between 0 and 1."
	},
	"pxnoised: x px v dvdx": {
			"prefix": "pxnoised(x, px, v, dvdx)",
			"body": "pxnoised(${1:x}, ${2:px}, ${3:v}, ${4:dvdx})",
			"scope": "source.vex",
			"description": "Periodic derivatives of Simplex Noise."
	},
	"pxnoised: x y px py v dvdx dvdy": {
			"prefix": "pxnoised(x, y, px, py, v, dvdx, dvdy)",
			"body": "pxnoised(${1:x}, ${2:y}, ${3:px}, ${4:py}, ${5:v}, ${6:dvdx}, ${7:dvdy})",
			"scope": "source.vex",
			"description": "Periodic derivatives of Simplex Noise."
	},
	"pxnoised: xyz px py pz v dvdx dvdy dvdz": {
			"prefix": "pxnoised(xyz, px, py, pz, v, dvdx, dvdy, dvdz)",
			"body": "pxnoised(${1:xyz}, ${2:px}, ${3:py}, ${4:pz}, ${5:v}, ${6:dvdx}, ${7:dvdy}, ${8:dvdz})",
			"scope": "source.vex",
			"description": "Periodic derivatives of Simplex Noise."
	},
	"pxnoised: xyzw px py pz pw v dvdx dvdy dvdz dvdw": {
			"prefix": "pxnoised(xyzw, px, py, pz, pw, v, dvdx, dvdy, dvdz, dvdw)",
			"body": "pxnoised(${1:xyzw}, ${2:px}, ${3:py}, ${4:pz}, ${5:pw}, ${6:v}, ${7:dvdx}, ${8:dvdy}, ${9:dvdz}, ${10:dvdw})",
			"scope": "source.vex",
			"description": "Periodic derivatives of Simplex Noise."
	},
	"usd_kind: stage primpath": {
			"prefix": "usd_kind(stage, primpath)",
			"body": "usd_kind(${1:stage}, ${2:primpath})",
			"scope": "source.vex",
			"description": "Returns the primitive\u2019s kind."
	},
	"reorder: value indices": {
			"prefix": "reorder(value, indices)",
			"body": "reorder(${1:value}, ${2:indices})",
			"scope": "source.vex",
			"description": "Reorders items in an array or string."
	},
	"reorder: values indices": {
			"prefix": "reorder(values, indices)",
			"body": "reorder(${1:values}, ${2:indices})",
			"scope": "source.vex",
			"description": "Reorders items in an array or string."
	},
	"agenttransformgroupmemberchannel: geometry prim transformgroupidx channel": {
			"prefix": "agenttransformgroupmemberchannel(geometry, prim, transformgroupidx, channel)",
			"body": "agenttransformgroupmemberchannel(${1:geometry}, ${2:prim}, ${3:transformgroupidx}, ${4:channel})",
			"scope": "source.vex",
			"description": "Returns whether a channel is a member of the specified transform group."
	},
	"pop: array": {
			"prefix": "pop(array)",
			"body": "pop(${1:array})",
			"scope": "source.vex",
			"description": "Removes the last element of an array and returns it."
	},
	"pop: array index": {
			"prefix": "pop(array, index)",
			"body": "pop(${1:array}, ${2:index})",
			"scope": "source.vex",
			"description": "Removes the last element of an array and returns it."
	},
	"toupper: str": {
			"prefix": "toupper(str)",
			"body": "toupper(${1:str})",
			"scope": "source.vex",
			"description": "Converts all characters in string to upper case"
	},
	"blinn: exponent ...": {
			"prefix": "blinn(exponent, ...)",
			"body": "blinn(${1:exponent}, ${2:...})",
			"scope": "source.vex",
			"description": "Returns a Blinn BSDF or computes Blinn shading."
	},
	"blinn: nml exponent ...": {
			"prefix": "blinn(nml, exponent, ...)",
			"body": "blinn(${1:nml}, ${2:exponent}, ${3:...})",
			"scope": "source.vex",
			"description": "Returns a Blinn BSDF or computes Blinn shading."
	},
	"blinn: nml V roughness ...": {
			"prefix": "blinn(nml, V, roughness, ...)",
			"body": "blinn(${1:nml}, ${2:V}, ${3:roughness}, ${4:...})",
			"scope": "source.vex",
			"description": "Returns a Blinn BSDF or computes Blinn shading."
	},
	"writepixel: channel ndc_x ndc_y clr": {
			"prefix": "writepixel(channel, ndc_x, ndc_y, clr)",
			"body": "writepixel(${1:channel}, ${2:ndc_x}, ${3:ndc_y}, ${4:clr})",
			"scope": "source.vex",
			"description": "Writes color information to a pixel in the output image "
	},
	"atten: attenuation distance": {
			"prefix": "atten(attenuation, distance)",
			"body": "atten(${1:attenuation}, ${2:distance})",
			"scope": "source.vex",
			"description": "Computes attenuated falloff."
	},
	"setagentcurrentlayer: geohandle prim layername": {
			"prefix": "setagentcurrentlayer(geohandle, prim, layername)",
			"body": "setagentcurrentlayer(${1:geohandle}, ${2:prim}, ${3:layername})",
			"scope": "source.vex",
			"description": "Sets the current layer of an agent primitive."
	},
	"pgfind: geometry P radius maxpoints divsize": {
			"prefix": "pgfind(geometry, P, radius, maxpoints, divsize)",
			"body": "pgfind(${1:geometry}, ${2:P}, ${3:radius}, ${4:maxpoints}, ${5:divsize})",
			"scope": "source.vex",
			"description": "Returns a list of closest points from a file."
	},
	"pgfind: geometry ptgroup P radius maxpoints divsize": {
			"prefix": "pgfind(geometry, ptgroup, P, radius, maxpoints, divsize)",
			"body": "pgfind(${1:geometry}, ${2:ptgroup}, ${3:P}, ${4:radius}, ${5:maxpoints}, ${6:divsize})",
			"scope": "source.vex",
			"description": "Returns a list of closest points from a file."
	},
	"lightstate: query value": {
			"prefix": "lightstate(query, value)",
			"body": "lightstate(${1:query}, ${2:value})",
			"scope": "source.vex",
			"description": "Queries the renderer for a named property."
	},
	"usd_primvartypename: stage primpath name": {
			"prefix": "usd_primvartypename(stage, primpath, name)",
			"body": "usd_primvartypename(${1:stage}, ${2:primpath}, ${3:name})",
			"scope": "source.vex",
			"description": "Returns the name of the primvar type."
	},
	"agenttransformtolocal: geometry prim transforms": {
			"prefix": "agenttransformtolocal(geometry, prim, transforms)",
			"body": "agenttransformtolocal(${1:geometry}, ${2:prim}, ${3:transforms})",
			"scope": "source.vex",
			"description": "Converts transforms from world space to local space for an agent primitive."
	},
	"push: array value": {
			"prefix": "push(array, value)",
			"body": "push(${1:array}, ${2:value})",
			"scope": "source.vex",
			"description": "Adds an item to an array."
	},
	"push: array values": {
			"prefix": "push(array, values)",
			"body": "push(${1:array}, ${2:values})",
			"scope": "source.vex",
			"description": "Adds an item to an array."
	},
	"getbbox_min: geometry": {
			"prefix": "getbbox_min(geometry)",
			"body": "getbbox_min(${1:geometry})",
			"scope": "source.vex",
			"description": "Returns the minimum of the bounding box for the geometry."
	},
	"getbbox_min: geometry primgroup": {
			"prefix": "getbbox_min(geometry, primgroup)",
			"body": "getbbox_min(${1:geometry}, ${2:primgroup})",
			"scope": "source.vex",
			"description": "Returns the minimum of the bounding box for the geometry."
	},
	"pointhedge: geometry point": {
			"prefix": "pointhedge(geometry, point)",
			"body": "pointhedge(${1:geometry}, ${2:point})",
			"scope": "source.vex",
			"description": "Finds and returns a half-edge with a given source point or with given source and destination points."
	},
	"pointhedge: geometry srcpoint dstpoint": {
			"prefix": "pointhedge(geometry, srcpoint, dstpoint)",
			"body": "pointhedge(${1:geometry}, ${2:srcpoint}, ${3:dstpoint})",
			"scope": "source.vex",
			"description": "Finds and returns a half-edge with a given source point or with given source and destination points."
	},
	"erf_inv: v": {
			"prefix": "erf_inv(v)",
			"body": "erf_inv(${1:v})",
			"scope": "source.vex",
			"description": "Inverse Gauss error function."
	}
}